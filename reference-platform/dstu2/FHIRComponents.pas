{!Wrapper uses FHIRBase, FHIRBase_Wrapper, FHIRTypes, FHIRTypes_Wrapper}

unit FHIRComponents;

{
Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 * Neither the name of HL7 nor the names of its contributors may be used to
   endorse or promote products derived from this software without specific
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
}

{$IFNDEF FHIR_DSTU1}
This is the dstu1 version of the FHIR code
{$ENDIF}


interface

// FHIR v0.0.82 generated Tue, Sep 30, 2014 18:08+1000

uses
  SysUtils, Classes, StringSupport, DecimalSupport, AdvBuffers,  FHIRBase, FHIRTypes;

Type
  TFhirAdverseReactionSymptom = class;
  TFhirAdverseReactionSymptomList = class;
  TFhirAdverseReactionExposure = class;
  TFhirAdverseReactionExposureList = class;
  TFhirCarePlanParticipant = class;
  TFhirCarePlanParticipantList = class;
  TFhirCarePlanGoal = class;
  TFhirCarePlanGoalList = class;
  TFhirCarePlanActivity = class;
  TFhirCarePlanActivityList = class;
  TFhirCarePlanActivitySimple = class;
  TFhirCarePlanActivitySimpleList = class;
  TFhirCompositionAttester = class;
  TFhirCompositionAttesterList = class;
  TFhirCompositionEvent = class;
  TFhirCompositionEventList = class;
  TFhirCompositionSection = class;
  TFhirCompositionSectionList = class;
  TFhirConceptMapConcept = class;
  TFhirConceptMapConceptList = class;
  TFhirConceptMapConceptDependsOn = class;
  TFhirConceptMapConceptDependsOnList = class;
  TFhirConceptMapConceptMap = class;
  TFhirConceptMapConceptMapList = class;
  TFhirConditionStage = class;
  TFhirConditionStageList = class;
  TFhirConditionEvidence = class;
  TFhirConditionEvidenceList = class;
  TFhirConditionLocation = class;
  TFhirConditionLocationList = class;
  TFhirConditionRelatedItem = class;
  TFhirConditionRelatedItemList = class;
  TFhirConformanceSoftware = class;
  TFhirConformanceSoftwareList = class;
  TFhirConformanceImplementation = class;
  TFhirConformanceImplementationList = class;
  TFhirConformanceRest = class;
  TFhirConformanceRestList = class;
  TFhirConformanceRestSecurity = class;
  TFhirConformanceRestSecurityList = class;
  TFhirConformanceRestSecurityCertificate = class;
  TFhirConformanceRestSecurityCertificateList = class;
  TFhirConformanceRestResource = class;
  TFhirConformanceRestResourceList = class;
  TFhirConformanceRestResourceOperation = class;
  TFhirConformanceRestResourceOperationList = class;
  TFhirConformanceRestResourceSearchParam = class;
  TFhirConformanceRestResourceSearchParamList = class;
  TFhirConformanceRestOperation = class;
  TFhirConformanceRestOperationList = class;
  TFhirConformanceRestQuery = class;
  TFhirConformanceRestQueryList = class;
  TFhirConformanceMessaging = class;
  TFhirConformanceMessagingList = class;
  TFhirConformanceMessagingEvent = class;
  TFhirConformanceMessagingEventList = class;
  TFhirConformanceDocument = class;
  TFhirConformanceDocumentList = class;
  TFhirDeviceObservationReportVirtualDevice = class;
  TFhirDeviceObservationReportVirtualDeviceList = class;
  TFhirDeviceObservationReportVirtualDeviceChannel = class;
  TFhirDeviceObservationReportVirtualDeviceChannelList = class;
  TFhirDeviceObservationReportVirtualDeviceChannelMetric = class;
  TFhirDeviceObservationReportVirtualDeviceChannelMetricList = class;
  TFhirDiagnosticOrderEvent = class;
  TFhirDiagnosticOrderEventList = class;
  TFhirDiagnosticOrderItem = class;
  TFhirDiagnosticOrderItemList = class;
  TFhirDiagnosticReportImage = class;
  TFhirDiagnosticReportImageList = class;
  TFhirDocumentReferenceRelatesTo = class;
  TFhirDocumentReferenceRelatesToList = class;
  TFhirDocumentReferenceService = class;
  TFhirDocumentReferenceServiceList = class;
  TFhirDocumentReferenceServiceParameter = class;
  TFhirDocumentReferenceServiceParameterList = class;
  TFhirDocumentReferenceContext = class;
  TFhirDocumentReferenceContextList = class;
  TFhirEncounterParticipant = class;
  TFhirEncounterParticipantList = class;
  TFhirEncounterHospitalization = class;
  TFhirEncounterHospitalizationList = class;
  TFhirEncounterHospitalizationAccomodation = class;
  TFhirEncounterHospitalizationAccomodationList = class;
  TFhirEncounterLocation = class;
  TFhirEncounterLocationList = class;
  TFhirFamilyHistoryRelation = class;
  TFhirFamilyHistoryRelationList = class;
  TFhirFamilyHistoryRelationCondition = class;
  TFhirFamilyHistoryRelationConditionList = class;
  TFhirGroupCharacteristic = class;
  TFhirGroupCharacteristicList = class;
  TFhirImagingStudySeries = class;
  TFhirImagingStudySeriesList = class;
  TFhirImagingStudySeriesInstance = class;
  TFhirImagingStudySeriesInstanceList = class;
  TFhirImmunizationExplanation = class;
  TFhirImmunizationExplanationList = class;
  TFhirImmunizationReaction = class;
  TFhirImmunizationReactionList = class;
  TFhirImmunizationVaccinationProtocol = class;
  TFhirImmunizationVaccinationProtocolList = class;
  TFhirImmunizationRecommendationRecommendation = class;
  TFhirImmunizationRecommendationRecommendationList = class;
  TFhirImmunizationRecommendationRecommendationDateCriterion = class;
  TFhirImmunizationRecommendationRecommendationDateCriterionList = class;
  TFhirImmunizationRecommendationRecommendationProtocol = class;
  TFhirImmunizationRecommendationRecommendationProtocolList = class;
  TFhirListEntry = class;
  TFhirListEntryList = class;
  TFhirLocationPosition = class;
  TFhirLocationPositionList = class;
  TFhirMedicationProduct = class;
  TFhirMedicationProductList = class;
  TFhirMedicationProductIngredient = class;
  TFhirMedicationProductIngredientList = class;
  TFhirMedicationPackage = class;
  TFhirMedicationPackageList = class;
  TFhirMedicationPackageContent = class;
  TFhirMedicationPackageContentList = class;
  TFhirMedicationAdministrationDosage = class;
  TFhirMedicationAdministrationDosageList = class;
  TFhirMedicationDispenseDispense = class;
  TFhirMedicationDispenseDispenseList = class;
  TFhirMedicationDispenseDispenseDosage = class;
  TFhirMedicationDispenseDispenseDosageList = class;
  TFhirMedicationDispenseSubstitution = class;
  TFhirMedicationDispenseSubstitutionList = class;
  TFhirMedicationPrescriptionDosageInstruction = class;
  TFhirMedicationPrescriptionDosageInstructionList = class;
  TFhirMedicationPrescriptionDispense = class;
  TFhirMedicationPrescriptionDispenseList = class;
  TFhirMedicationPrescriptionSubstitution = class;
  TFhirMedicationPrescriptionSubstitutionList = class;
  TFhirMedicationStatementDosage = class;
  TFhirMedicationStatementDosageList = class;
  TFhirMessageHeaderResponse = class;
  TFhirMessageHeaderResponseList = class;
  TFhirMessageHeaderSource = class;
  TFhirMessageHeaderSourceList = class;
  TFhirMessageHeaderDestination = class;
  TFhirMessageHeaderDestinationList = class;
  TFhirObservationReferenceRange = class;
  TFhirObservationReferenceRangeList = class;
  TFhirObservationRelated = class;
  TFhirObservationRelatedList = class;
  TFhirOperationOutcomeIssue = class;
  TFhirOperationOutcomeIssueList = class;
  TFhirOrderWhen = class;
  TFhirOrderWhenList = class;
  TFhirOrganizationContact = class;
  TFhirOrganizationContactList = class;
  TFhirPatientContact = class;
  TFhirPatientContactList = class;
  TFhirPatientAnimal = class;
  TFhirPatientAnimalList = class;
  TFhirPatientLink = class;
  TFhirPatientLinkList = class;
  TFhirPractitionerQualification = class;
  TFhirPractitionerQualificationList = class;
  TFhirProcedurePerformer = class;
  TFhirProcedurePerformerList = class;
  TFhirProcedureRelatedItem = class;
  TFhirProcedureRelatedItemList = class;
  TFhirProfileMapping = class;
  TFhirProfileMappingList = class;
  TFhirProfileStructure = class;
  TFhirProfileStructureList = class;
  TFhirProfileStructureElement = class;
  TFhirProfileStructureElementList = class;
  TFhirProfileStructureElementSlicing = class;
  TFhirProfileStructureElementSlicingList = class;
  TFhirProfileStructureElementDefinition = class;
  TFhirProfileStructureElementDefinitionList = class;
  TFhirProfileStructureElementDefinitionType = class;
  TFhirProfileStructureElementDefinitionTypeList = class;
  TFhirProfileStructureElementDefinitionConstraint = class;
  TFhirProfileStructureElementDefinitionConstraintList = class;
  TFhirProfileStructureElementDefinitionBinding = class;
  TFhirProfileStructureElementDefinitionBindingList = class;
  TFhirProfileStructureElementDefinitionMapping = class;
  TFhirProfileStructureElementDefinitionMappingList = class;
  TFhirProfileStructureSearchParam = class;
  TFhirProfileStructureSearchParamList = class;
  TFhirProfileExtensionDefn = class;
  TFhirProfileExtensionDefnList = class;
  TFhirProfileQuery = class;
  TFhirProfileQueryList = class;
  TFhirProvenanceAgent = class;
  TFhirProvenanceAgentList = class;
  TFhirProvenanceEntity = class;
  TFhirProvenanceEntityList = class;
  TFhirQueryResponse = class;
  TFhirQueryResponseList = class;
  TFhirQuestionnaireGroup = class;
  TFhirQuestionnaireGroupList = class;
  TFhirQuestionnaireGroupQuestion = class;
  TFhirQuestionnaireGroupQuestionList = class;
  TFhirSecurityEventEvent = class;
  TFhirSecurityEventEventList = class;
  TFhirSecurityEventParticipant = class;
  TFhirSecurityEventParticipantList = class;
  TFhirSecurityEventParticipantNetwork = class;
  TFhirSecurityEventParticipantNetworkList = class;
  TFhirSecurityEventSource = class;
  TFhirSecurityEventSourceList = class;
  TFhirSecurityEventObject = class;
  TFhirSecurityEventObjectList = class;
  TFhirSecurityEventObjectDetail = class;
  TFhirSecurityEventObjectDetailList = class;
  TFhirSpecimenSource = class;
  TFhirSpecimenSourceList = class;
  TFhirSpecimenCollection = class;
  TFhirSpecimenCollectionList = class;
  TFhirSpecimenTreatment = class;
  TFhirSpecimenTreatmentList = class;
  TFhirSpecimenContainer = class;
  TFhirSpecimenContainerList = class;
  TFhirSubstanceInstance = class;
  TFhirSubstanceInstanceList = class;
  TFhirSubstanceIngredient = class;
  TFhirSubstanceIngredientList = class;
  TFhirSupplyDispense = class;
  TFhirSupplyDispenseList = class;
  TFhirValueSetDefine = class;
  TFhirValueSetDefineList = class;
  TFhirValueSetDefineConcept = class;
  TFhirValueSetDefineConceptList = class;
  TFhirValueSetCompose = class;
  TFhirValueSetComposeList = class;
  TFhirValueSetComposeInclude = class;
  TFhirValueSetComposeIncludeList = class;
  TFhirValueSetComposeIncludeFilter = class;
  TFhirValueSetComposeIncludeFilterList = class;
  TFhirValueSetExpansion = class;
  TFhirValueSetExpansionList = class;
  TFhirValueSetExpansionContains = class;
  TFhirValueSetExpansionContainsList = class;

  {@Class TFhirAdverseReactionSymptom : TFhirElement
    The signs and symptoms that were observed as part of the reaction.
  }
  {!.Net HL7Connect.Fhir.AdverseReactionSymptom}
  TFhirAdverseReactionSymptom = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FSeverity : TFhirEnum;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirReactionSeverity;
    Procedure SetSeverityST(value : TFhirReactionSeverity);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirAdverseReactionSymptom; overload;
    function Clone : TFhirAdverseReactionSymptom; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      Indicates the specific sign or symptom that was observed.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;
    property codeObject : TFhirCodeableConcept read FCode write SetCode;

    {@member severity
      The severity of the sign or symptom.
    }
    property severity : TFhirReactionSeverity read GetSeverityST write SetSeverityST;
    property severityObject : TFhirEnum read FSeverity write SetSeverity;

  end;


  TFhirAdverseReactionSymptomListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirAdverseReactionSymptomList;
    function GetCurrent : TFhirAdverseReactionSymptom;
  public
    Constructor Create(list : TFhirAdverseReactionSymptomList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseReactionSymptom read GetCurrent;
  end;


  {@Class TFhirAdverseReactionSymptomList
    A list of FhirAdverseReactionSymptom
  }
  {!.Net HL7Connect.Fhir.AdverseReactionSymptomList}
  TFhirAdverseReactionSymptomList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseReactionSymptom;
    procedure SetItemN(index : Integer; value : TFhirAdverseReactionSymptom);
  public
    {!script hide}
    function Link : TFhirAdverseReactionSymptomList; Overload;
    function Clone : TFhirAdverseReactionSymptomList; Overload;
    function GetEnumerator : TFhirAdverseReactionSymptomListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirAdverseReactionSymptom to the end of the list.
    }
    function Append : TFhirAdverseReactionSymptom;

    
    {@member AddItem
      Add an already existing FhirAdverseReactionSymptom to the end of the list.
    }
    procedure AddItem(value : TFhirAdverseReactionSymptom); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirAdverseReactionSymptom) : Integer;
    

    {@member Insert
      Insert FhirAdverseReactionSymptom before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirAdverseReactionSymptom;
    

    {@member InsertItem
       Insert an existing FhirAdverseReactionSymptom before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirAdverseReactionSymptom);
    
    {@member Item
       Get the iIndexth FhirAdverseReactionSymptom. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirAdverseReactionSymptom. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseReactionSymptom);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirAdverseReactionSymptom;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirAdverseReactionSymptoms[index : Integer] : TFhirAdverseReactionSymptom read GetItemN write SetItemN; default;
  End;


  {@Class TFhirAdverseReactionExposure : TFhirElement
    An exposure to a substance that preceded a reaction occurrence.
  }
  {!.Net HL7Connect.Fhir.AdverseReactionExposure}
  TFhirAdverseReactionExposure = class (TFhirBackboneElement)
  private
    FDate : TFhirDateTime;
    FType_ : TFhirEnum;
    FCausalityExpectation : TFhirEnum;
    FSubstance : TFhirResourceReference{TFhirSubstance};
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TDateTimeEx;
    Procedure SetDateST(value : TDateTimeEx);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirExposureType;
    Procedure SetType_ST(value : TFhirExposureType);
    Procedure SetCausalityExpectation(value : TFhirEnum);
    Function GetCausalityExpectationST : TFhirCausalityExpectation;
    Procedure SetCausalityExpectationST(value : TFhirCausalityExpectation);
    Procedure SetSubstance(value : TFhirResourceReference{TFhirSubstance});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirAdverseReactionExposure; overload;
    function Clone : TFhirAdverseReactionExposure; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member date
      Identifies the initial date of the exposure that is suspected to be related to the reaction.
    }
    {@member date
      Typed access to Identifies the initial date of the exposure that is suspected to be related to the reaction.
    }
    property date : TDateTimeEx read GetDateST write SetDateST;
    property dateObject : TFhirDateTime read FDate write SetDate;

    {@member type_
      The type of exposure: Drug Administration, Immunization, Coincidental.
    }
    property type_ : TFhirExposureType read GetType_ST write SetType_ST;
    property type_Object : TFhirEnum read FType_ write SetType_;

    {@member causalityExpectation
      A statement of how confident that the recorder was that this exposure caused the reaction.
    }
    property causalityExpectation : TFhirCausalityExpectation read GetCausalityExpectationST write SetCausalityExpectationST;
    property causalityExpectationObject : TFhirEnum read FCausalityExpectation write SetCausalityExpectation;

    {@member substance
      Substance that is presumed to have caused the adverse reaction.
    }
    property substance : TFhirResourceReference{TFhirSubstance} read FSubstance write SetSubstance;
    property substanceObject : TFhirResourceReference{TFhirSubstance} read FSubstance write SetSubstance;

  end;


  TFhirAdverseReactionExposureListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirAdverseReactionExposureList;
    function GetCurrent : TFhirAdverseReactionExposure;
  public
    Constructor Create(list : TFhirAdverseReactionExposureList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseReactionExposure read GetCurrent;
  end;


  {@Class TFhirAdverseReactionExposureList
    A list of FhirAdverseReactionExposure
  }
  {!.Net HL7Connect.Fhir.AdverseReactionExposureList}
  TFhirAdverseReactionExposureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseReactionExposure;
    procedure SetItemN(index : Integer; value : TFhirAdverseReactionExposure);
  public
    {!script hide}
    function Link : TFhirAdverseReactionExposureList; Overload;
    function Clone : TFhirAdverseReactionExposureList; Overload;
    function GetEnumerator : TFhirAdverseReactionExposureListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirAdverseReactionExposure to the end of the list.
    }
    function Append : TFhirAdverseReactionExposure;

    
    {@member AddItem
      Add an already existing FhirAdverseReactionExposure to the end of the list.
    }
    procedure AddItem(value : TFhirAdverseReactionExposure); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirAdverseReactionExposure) : Integer;
    

    {@member Insert
      Insert FhirAdverseReactionExposure before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirAdverseReactionExposure;
    

    {@member InsertItem
       Insert an existing FhirAdverseReactionExposure before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirAdverseReactionExposure);
    
    {@member Item
       Get the iIndexth FhirAdverseReactionExposure. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirAdverseReactionExposure. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseReactionExposure);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirAdverseReactionExposure;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirAdverseReactionExposures[index : Integer] : TFhirAdverseReactionExposure read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCarePlanParticipant : TFhirElement
    Identifies all people and organizations who are expected to be involved in the care envisioned by this plan.
  }
  {!.Net HL7Connect.Fhir.CarePlanParticipant}
  TFhirCarePlanParticipant = class (TFhirBackboneElement)
  private
    FRole : TFhirCodeableConcept;
    FMember : TFhirResourceReference{Resource};
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetMember(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCarePlanParticipant; overload;
    function Clone : TFhirCarePlanParticipant; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member role
      Indicates specific responsibility of an individual within the care plan.  E.g. "Primary physician", "Team coordinator", "Caregiver", etc.
    }
    property role : TFhirCodeableConcept read FRole write SetRole;
    property roleObject : TFhirCodeableConcept read FRole write SetRole;

    {@member member
      The specific person or organization who is participating/expected to participate in the care plan.
    }
    property member : TFhirResourceReference{Resource} read FMember write SetMember;
    property memberObject : TFhirResourceReference{Resource} read FMember write SetMember;

  end;


  TFhirCarePlanParticipantListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanParticipantList;
    function GetCurrent : TFhirCarePlanParticipant;
  public
    Constructor Create(list : TFhirCarePlanParticipantList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlanParticipant read GetCurrent;
  end;


  {@Class TFhirCarePlanParticipantList
    A list of FhirCarePlanParticipant
  }
  {!.Net HL7Connect.Fhir.CarePlanParticipantList}
  TFhirCarePlanParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanParticipant;
    procedure SetItemN(index : Integer; value : TFhirCarePlanParticipant);
  public
    {!script hide}
    function Link : TFhirCarePlanParticipantList; Overload;
    function Clone : TFhirCarePlanParticipantList; Overload;
    function GetEnumerator : TFhirCarePlanParticipantListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirCarePlanParticipant to the end of the list.
    }
    function Append : TFhirCarePlanParticipant;

    
    {@member AddItem
      Add an already existing FhirCarePlanParticipant to the end of the list.
    }
    procedure AddItem(value : TFhirCarePlanParticipant); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCarePlanParticipant) : Integer;
    

    {@member Insert
      Insert FhirCarePlanParticipant before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCarePlanParticipant;
    

    {@member InsertItem
       Insert an existing FhirCarePlanParticipant before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCarePlanParticipant);
    
    {@member Item
       Get the iIndexth FhirCarePlanParticipant. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCarePlanParticipant. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanParticipant);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCarePlanParticipant;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCarePlanParticipants[index : Integer] : TFhirCarePlanParticipant read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCarePlanGoal : TFhirElement
    Describes the intended objective(s) of carrying out the Care Plan.
  }
  {!.Net HL7Connect.Fhir.CarePlanGoal}
  TFhirCarePlanGoal = class (TFhirBackboneElement)
  private
    FDescription : TFhirString;
    FStatus : TFhirEnum;
    FNotes : TFhirString;
    FconcernList : TFhirResourceReferenceList{TFhirCondition};
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCarePlanGoalStatus;
    Procedure SetStatusST(value : TFhirCarePlanGoalStatus);
    Procedure SetNotes(value : TFhirString);
    Function GetNotesST : String;
    Procedure SetNotesST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCarePlanGoal; overload;
    function Clone : TFhirCarePlanGoal; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member description
      Human-readable description of a specific desired objective of the care plan.
    }
    {@member description
      Typed access to Human-readable description of a specific desired objective of the care plan.
    }
    property description : String read GetDescriptionST write SetDescriptionST;
    property descriptionObject : TFhirString read FDescription write SetDescription;

    {@member status
      Indicates whether the goal has been reached and is still considered relevant.
    }
    property status : TFhirCarePlanGoalStatus read GetStatusST write SetStatusST;
    property statusObject : TFhirEnum read FStatus write SetStatus;

    {@member notes
      Any comments related to the goal.
    }
    {@member notes
      Typed access to Any comments related to the goal.
    }
    property notes : String read GetNotesST write SetNotesST;
    property notesObject : TFhirString read FNotes write SetNotes;

    {@member concernList
      The identified conditions that this goal relates to - the condition that caused it to be created, or that it is intended to address.
    }
    property concernList : TFhirResourceReferenceList{TFhirCondition} read FConcernList;

  end;


  TFhirCarePlanGoalListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanGoalList;
    function GetCurrent : TFhirCarePlanGoal;
  public
    Constructor Create(list : TFhirCarePlanGoalList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlanGoal read GetCurrent;
  end;


  {@Class TFhirCarePlanGoalList
    A list of FhirCarePlanGoal
  }
  {!.Net HL7Connect.Fhir.CarePlanGoalList}
  TFhirCarePlanGoalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanGoal;
    procedure SetItemN(index : Integer; value : TFhirCarePlanGoal);
  public
    {!script hide}
    function Link : TFhirCarePlanGoalList; Overload;
    function Clone : TFhirCarePlanGoalList; Overload;
    function GetEnumerator : TFhirCarePlanGoalListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirCarePlanGoal to the end of the list.
    }
    function Append : TFhirCarePlanGoal;

    
    {@member AddItem
      Add an already existing FhirCarePlanGoal to the end of the list.
    }
    procedure AddItem(value : TFhirCarePlanGoal); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCarePlanGoal) : Integer;
    

    {@member Insert
      Insert FhirCarePlanGoal before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCarePlanGoal;
    

    {@member InsertItem
       Insert an existing FhirCarePlanGoal before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCarePlanGoal);
    
    {@member Item
       Get the iIndexth FhirCarePlanGoal. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCarePlanGoal. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanGoal);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCarePlanGoal;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCarePlanGoals[index : Integer] : TFhirCarePlanGoal read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCarePlanActivity : TFhirElement
    Identifies a planned action to occur as part of the plan.  For example, a medication to be used, lab tests to perform, self-monitoring, education, etc.
  }
  {!.Net HL7Connect.Fhir.CarePlanActivity}
  TFhirCarePlanActivity = class (TFhirBackboneElement)
  private
    FgoalList : TFhirStringList;
    FStatus : TFhirEnum;
    FProhibited : TFhirBoolean;
    FactionResultingList : TFhirResourceReferenceList{Resource};
    FNotes : TFhirString;
    FDetail : TFhirResourceReference{Resource};
    FSimple : TFhirCarePlanActivitySimple;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCarePlanActivityStatus;
    Procedure SetStatusST(value : TFhirCarePlanActivityStatus);
    Procedure SetProhibited(value : TFhirBoolean);
    Function GetProhibitedST : Boolean;
    Procedure SetProhibitedST(value : Boolean);
    Procedure SetNotes(value : TFhirString);
    Function GetNotesST : String;
    Procedure SetNotesST(value : String);
    Procedure SetDetail(value : TFhirResourceReference{Resource});
    Procedure SetSimple(value : TFhirCarePlanActivitySimple);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCarePlanActivity; overload;
    function Clone : TFhirCarePlanActivity; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member goalList
      Internal reference that identifies the goals that this activity is intended to contribute towards meeting.
    }
    property goalList : TFhirStringList read FGoalList;

    {@member status
      Identifies what progress is being made for the specific activity.
    }
    property status : TFhirCarePlanActivityStatus read GetStatusST write SetStatusST;
    property statusObject : TFhirEnum read FStatus write SetStatus;

    {@member prohibited
      If true, indicates that the described activity is one that must NOT be engaged in when following the plan.
    }
    {@member prohibited
      Typed access to If true, indicates that the described activity is one that must NOT be engaged in when following the plan.
    }
    property prohibited : Boolean read GetProhibitedST write SetProhibitedST;
    property prohibitedObject : TFhirBoolean read FProhibited write SetProhibited;

    {@member actionResultingList
      Resources that describe follow-on actions resulting from the plan, such as drug prescriptions, encounter records, appointments, etc.
    }
    property actionResultingList : TFhirResourceReferenceList{Resource} read FActionResultingList;

    {@member notes
      Notes about the execution of the activity.
    }
    {@member notes
      Typed access to Notes about the execution of the activity.
    }
    property notes : String read GetNotesST write SetNotesST;
    property notesObject : TFhirString read FNotes write SetNotes;

    {@member detail
      The details of the proposed activity represented in a specific resource.
    }
    property detail : TFhirResourceReference{Resource} read FDetail write SetDetail;
    property detailObject : TFhirResourceReference{Resource} read FDetail write SetDetail;

    {@member simple
      A simple summary of details suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc.
    }
    property simple : TFhirCarePlanActivitySimple read FSimple write SetSimple;
    property simpleObject : TFhirCarePlanActivitySimple read FSimple write SetSimple;

  end;


  TFhirCarePlanActivityListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanActivityList;
    function GetCurrent : TFhirCarePlanActivity;
  public
    Constructor Create(list : TFhirCarePlanActivityList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlanActivity read GetCurrent;
  end;


  {@Class TFhirCarePlanActivityList
    A list of FhirCarePlanActivity
  }
  {!.Net HL7Connect.Fhir.CarePlanActivityList}
  TFhirCarePlanActivityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanActivity;
    procedure SetItemN(index : Integer; value : TFhirCarePlanActivity);
  public
    {!script hide}
    function Link : TFhirCarePlanActivityList; Overload;
    function Clone : TFhirCarePlanActivityList; Overload;
    function GetEnumerator : TFhirCarePlanActivityListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirCarePlanActivity to the end of the list.
    }
    function Append : TFhirCarePlanActivity;

    
    {@member AddItem
      Add an already existing FhirCarePlanActivity to the end of the list.
    }
    procedure AddItem(value : TFhirCarePlanActivity); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCarePlanActivity) : Integer;
    

    {@member Insert
      Insert FhirCarePlanActivity before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCarePlanActivity;
    

    {@member InsertItem
       Insert an existing FhirCarePlanActivity before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCarePlanActivity);
    
    {@member Item
       Get the iIndexth FhirCarePlanActivity. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCarePlanActivity. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanActivity);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCarePlanActivity;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCarePlanActivities[index : Integer] : TFhirCarePlanActivity read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCarePlanActivitySimple : TFhirElement
    A simple summary of details suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc.
  }
  {!.Net HL7Connect.Fhir.CarePlanActivitySimple}
  TFhirCarePlanActivitySimple = class (TFhirBackboneElement)
  private
    FCategory : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FTiming : TFhirType;
    FLocation : TFhirResourceReference{TFhirLocation};
    FperformerList : TFhirResourceReferenceList{Resource};
    FProduct : TFhirResourceReference{Resource};
    FDailyAmount : TFhirQuantity;
    FQuantity : TFhirQuantity;
    FDetails : TFhirString;
    Procedure SetCategory(value : TFhirEnum);
    Function GetCategoryST : TFhirCarePlanActivityCategory;
    Procedure SetCategoryST(value : TFhirCarePlanActivityCategory);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetTiming(value : TFhirType);
    Procedure SetLocation(value : TFhirResourceReference{TFhirLocation});
    Procedure SetProduct(value : TFhirResourceReference{Resource});
    Procedure SetDailyAmount(value : TFhirQuantity);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetDetails(value : TFhirString);
    Function GetDetailsST : String;
    Procedure SetDetailsST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCarePlanActivitySimple; overload;
    function Clone : TFhirCarePlanActivitySimple; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member category
      High-level categorization of the type of activity in a care plan.
    }
    property category : TFhirCarePlanActivityCategory read GetCategoryST write SetCategoryST;
    property categoryObject : TFhirEnum read FCategory write SetCategory;

    {@member code
      Detailed description of the type of activity.  E.g. What lab test, what procedure, what kind of encounter.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;
    property codeObject : TFhirCodeableConcept read FCode write SetCode;

    {@member timing
      The period, timing or frequency upon which the described activity is to occur.
    }
    property timing : TFhirType read FTiming write SetTiming;
    property timingObject : TFhirType read FTiming write SetTiming;

    {@member location
      Identifies the facility where the activity will occur.  E.g. home, hospital, specific clinic, etc.
    }
    property location : TFhirResourceReference{TFhirLocation} read FLocation write SetLocation;
    property locationObject : TFhirResourceReference{TFhirLocation} read FLocation write SetLocation;

    {@member performerList
      Identifies who's expected to be involved in the activity.
    }
    property performerList : TFhirResourceReferenceList{Resource} read FPerformerList;

    {@member product
      Identifies the food, drug or other product being consumed or supplied in the activity.
    }
    property product : TFhirResourceReference{Resource} read FProduct write SetProduct;
    property productObject : TFhirResourceReference{Resource} read FProduct write SetProduct;

    {@member dailyAmount
      Identifies the quantity expected to be consumed in a given day.
    }
    property dailyAmount : TFhirQuantity read FDailyAmount write SetDailyAmount;
    property dailyAmountObject : TFhirQuantity read FDailyAmount write SetDailyAmount;

    {@member quantity
      Identifies the quantity expected to be supplied.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    property quantityObject : TFhirQuantity read FQuantity write SetQuantity;

    {@member details
      This provides a textual description of constraints on the activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    }
    {@member details
      Typed access to This provides a textual description of constraints on the activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    }
    property details : String read GetDetailsST write SetDetailsST;
    property detailsObject : TFhirString read FDetails write SetDetails;

  end;


  TFhirCarePlanActivitySimpleListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanActivitySimpleList;
    function GetCurrent : TFhirCarePlanActivitySimple;
  public
    Constructor Create(list : TFhirCarePlanActivitySimpleList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlanActivitySimple read GetCurrent;
  end;


  {@Class TFhirCarePlanActivitySimpleList
    A list of FhirCarePlanActivitySimple
  }
  {!.Net HL7Connect.Fhir.CarePlanActivitySimpleList}
  TFhirCarePlanActivitySimpleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanActivitySimple;
    procedure SetItemN(index : Integer; value : TFhirCarePlanActivitySimple);
  public
    {!script hide}
    function Link : TFhirCarePlanActivitySimpleList; Overload;
    function Clone : TFhirCarePlanActivitySimpleList; Overload;
    function GetEnumerator : TFhirCarePlanActivitySimpleListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirCarePlanActivitySimple to the end of the list.
    }
    function Append : TFhirCarePlanActivitySimple;

    
    {@member AddItem
      Add an already existing FhirCarePlanActivitySimple to the end of the list.
    }
    procedure AddItem(value : TFhirCarePlanActivitySimple); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCarePlanActivitySimple) : Integer;
    

    {@member Insert
      Insert FhirCarePlanActivitySimple before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCarePlanActivitySimple;
    

    {@member InsertItem
       Insert an existing FhirCarePlanActivitySimple before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCarePlanActivitySimple);
    
    {@member Item
       Get the iIndexth FhirCarePlanActivitySimple. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCarePlanActivitySimple. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanActivitySimple);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCarePlanActivitySimple;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCarePlanActivitySimples[index : Integer] : TFhirCarePlanActivitySimple read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCompositionAttester : TFhirElement
    A participant who has attested to the accuracy of the composition/document.
  }
  {!.Net HL7Connect.Fhir.CompositionAttester}
  TFhirCompositionAttester = class (TFhirBackboneElement)
  private
    FMode : TFhirEnumList;
    FTime : TFhirDateTime;
    FParty : TFhirResourceReference{Resource};
    Function GetModeST : TFhirCompositionAttestationModeList;
    Procedure SetModeST(value : TFhirCompositionAttestationModeList);
    Procedure SetTime(value : TFhirDateTime);
    Function GetTimeST : TDateTimeEx;
    Procedure SetTimeST(value : TDateTimeEx);
    Procedure SetParty(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCompositionAttester; overload;
    function Clone : TFhirCompositionAttester; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member mode
      The type of attestation the authenticator offers.
    }
    property mode : TFhirCompositionAttestationModeList read GetModeST write SetModeST;
    property modeObject : TFhirEnumList read FMode;
    {@member time
      When composition was attested by the party.
    }
    {@member time
      Typed access to When composition was attested by the party.
    }
    property time : TDateTimeEx read GetTimeST write SetTimeST;
    property timeObject : TFhirDateTime read FTime write SetTime;

    {@member party
      Who attested the composition in the specified way.
    }
    property party : TFhirResourceReference{Resource} read FParty write SetParty;
    property partyObject : TFhirResourceReference{Resource} read FParty write SetParty;

  end;


  TFhirCompositionAttesterListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirCompositionAttesterList;
    function GetCurrent : TFhirCompositionAttester;
  public
    Constructor Create(list : TFhirCompositionAttesterList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionAttester read GetCurrent;
  end;


  {@Class TFhirCompositionAttesterList
    A list of FhirCompositionAttester
  }
  {!.Net HL7Connect.Fhir.CompositionAttesterList}
  TFhirCompositionAttesterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompositionAttester;
    procedure SetItemN(index : Integer; value : TFhirCompositionAttester);
  public
    {!script hide}
    function Link : TFhirCompositionAttesterList; Overload;
    function Clone : TFhirCompositionAttesterList; Overload;
    function GetEnumerator : TFhirCompositionAttesterListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirCompositionAttester to the end of the list.
    }
    function Append : TFhirCompositionAttester;

    
    {@member AddItem
      Add an already existing FhirCompositionAttester to the end of the list.
    }
    procedure AddItem(value : TFhirCompositionAttester); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCompositionAttester) : Integer;
    

    {@member Insert
      Insert FhirCompositionAttester before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCompositionAttester;
    

    {@member InsertItem
       Insert an existing FhirCompositionAttester before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCompositionAttester);
    
    {@member Item
       Get the iIndexth FhirCompositionAttester. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCompositionAttester. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionAttester);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCompositionAttester;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCompositionAttesters[index : Integer] : TFhirCompositionAttester read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCompositionEvent : TFhirElement
    The main event/act/item, such as a colonoscopy or an appendectomy, being documented.
  }
  {!.Net HL7Connect.Fhir.CompositionEvent}
  TFhirCompositionEvent = class (TFhirBackboneElement)
  private
    FcodeList : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FdetailList : TFhirResourceReferenceList{Resource};
    Procedure SetPeriod(value : TFhirPeriod);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCompositionEvent; overload;
    function Clone : TFhirCompositionEvent; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member codeList
      This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    }
    property codeList : TFhirCodeableConceptList read FCodeList;

    {@member period
      The period of time covered by the documentation. There is no assertion that the documentation is a complete representation for this period, only that it documents events during this time.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;
    property periodObject : TFhirPeriod read FPeriod write SetPeriod;

    {@member detailList
      Full details for the event(s) the composition/documentation consents.
    }
    property detailList : TFhirResourceReferenceList{Resource} read FDetailList;

  end;


  TFhirCompositionEventListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirCompositionEventList;
    function GetCurrent : TFhirCompositionEvent;
  public
    Constructor Create(list : TFhirCompositionEventList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionEvent read GetCurrent;
  end;


  {@Class TFhirCompositionEventList
    A list of FhirCompositionEvent
  }
  {!.Net HL7Connect.Fhir.CompositionEventList}
  TFhirCompositionEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompositionEvent;
    procedure SetItemN(index : Integer; value : TFhirCompositionEvent);
  public
    {!script hide}
    function Link : TFhirCompositionEventList; Overload;
    function Clone : TFhirCompositionEventList; Overload;
    function GetEnumerator : TFhirCompositionEventListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirCompositionEvent to the end of the list.
    }
    function Append : TFhirCompositionEvent;

    
    {@member AddItem
      Add an already existing FhirCompositionEvent to the end of the list.
    }
    procedure AddItem(value : TFhirCompositionEvent); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCompositionEvent) : Integer;
    

    {@member Insert
      Insert FhirCompositionEvent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCompositionEvent;
    

    {@member InsertItem
       Insert an existing FhirCompositionEvent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCompositionEvent);
    
    {@member Item
       Get the iIndexth FhirCompositionEvent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCompositionEvent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionEvent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCompositionEvent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCompositionEvents[index : Integer] : TFhirCompositionEvent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirCompositionSection : TFhirElement
    The root of the sections that make up the composition.
  }
  {!.Net HL7Connect.Fhir.CompositionSection}
  TFhirCompositionSection = class (TFhirBackboneElement)
  private
    FTitle : TFhirString;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirResourceReference{Resource};
    FContent : TFhirResourceReference{Resource};
    FsectionList : TFhirCompositionSectionList;
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirResourceReference{Resource});
    Procedure SetContent(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirCompositionSection; overload;
    function Clone : TFhirCompositionSection; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member title
      The heading for this particular section.  This will be part of the rendered content for the document.
    }
    {@member title
      Typed access to The heading for this particular section.  This will be part of the rendered content for the document.
    }
    property title : String read GetTitleST write SetTitleST;
    property titleObject : TFhirString read FTitle write SetTitle;

    {@member code
      A code identifying the kind of content contained within the section.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;
    property codeObject : TFhirCodeableConcept read FCode write SetCode;

    {@member subject
      Identifies the primary subject of the section.
    }
    property subject : TFhirResourceReference{Resource} read FSubject write SetSubject;
    property subjectObject : TFhirResourceReference{Resource} read FSubject write SetSubject;

    {@member content
      Identifies the discrete data that provides the content for the section.
    }
    property content : TFhirResourceReference{Resource} read FContent write SetContent;
    property contentObject : TFhirResourceReference{Resource} read FContent write SetContent;

    {@member sectionList
      A nested sub-section within this section.
    }
    property sectionList : TFhirCompositionSectionList read FSectionList;

  end;


  TFhirCompositionSectionListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirCompositionSectionList;
    function GetCurrent : TFhirCompositionSection;
  public
    Constructor Create(list : TFhirCompositionSectionList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionSection read GetCurrent;
  end;


  {@Class TFhirCompositionSectionList
    A list of FhirCompositionSection
  }
  {!.Net HL7Connect.Fhir.CompositionSectionList}
  TFhirCompositionSectionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompositionSection;
    procedure SetItemN(index : Integer; value : TFhirCompositionSection);
  public
    {!script hide}
    function Link : TFhirCompositionSectionList; Overload;
    function Clone : TFhirCompositionSectionList; Overload;
    function GetEnumerator : TFhirCompositionSectionListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirCompositionSection to the end of the list.
    }
    function Append : TFhirCompositionSection;

    
    {@member AddItem
      Add an already existing FhirCompositionSection to the end of the list.
    }
    procedure AddItem(value : TFhirCompositionSection); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirCompositionSection) : Integer;
    

    {@member Insert
      Insert FhirCompositionSection before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirCompositionSection;
    

    {@member InsertItem
       Insert an existing FhirCompositionSection before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirCompositionSection);
    
    {@member Item
       Get the iIndexth FhirCompositionSection. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirCompositionSection. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionSection);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirCompositionSection;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirCompositionSections[index : Integer] : TFhirCompositionSection read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConceptMapConcept : TFhirElement
    Mappings for a concept from the source valueset.
  }
  {!.Net HL7Connect.Fhir.ConceptMapConcept}
  TFhirConceptMapConcept = class (TFhirBackboneElement)
  private
    FSystem : TFhirUri;
    FCode : TFhirCode;
    FdependsOnList : TFhirConceptMapConceptDependsOnList;
    FmapList : TFhirConceptMapConceptMapList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConceptMapConcept; overload;
    function Clone : TFhirConceptMapConcept; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member system
      System that defines the concept being mapped.
    }
    {@member system
      Typed access to System that defines the concept being mapped.
    }
    property system : String read GetSystemST write SetSystemST;
    property systemObject : TFhirUri read FSystem write SetSystem;

    {@member code
      Identifies concept being mapped.
    }
    {@member code
      Typed access to Identifies concept being mapped.
    }
    property code : String read GetCodeST write SetCodeST;
    property codeObject : TFhirCode read FCode write SetCode;

    {@member dependsOnList
      A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified concept can be resolved, and it has the specified value.
    }
    property dependsOnList : TFhirConceptMapConceptDependsOnList read FDependsOnList;

    {@member mapList
      A concept from the target value set that this concept maps to.
    }
    property mapList : TFhirConceptMapConceptMapList read FMapList;

  end;


  TFhirConceptMapConceptListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapConceptList;
    function GetCurrent : TFhirConceptMapConcept;
  public
    Constructor Create(list : TFhirConceptMapConceptList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapConcept read GetCurrent;
  end;


  {@Class TFhirConceptMapConceptList
    A list of FhirConceptMapConcept
  }
  {!.Net HL7Connect.Fhir.ConceptMapConceptList}
  TFhirConceptMapConceptList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConceptMapConcept;
    procedure SetItemN(index : Integer; value : TFhirConceptMapConcept);
  public
    {!script hide}
    function Link : TFhirConceptMapConceptList; Overload;
    function Clone : TFhirConceptMapConceptList; Overload;
    function GetEnumerator : TFhirConceptMapConceptListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConceptMapConcept to the end of the list.
    }
    function Append : TFhirConceptMapConcept;

    
    {@member AddItem
      Add an already existing FhirConceptMapConcept to the end of the list.
    }
    procedure AddItem(value : TFhirConceptMapConcept); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConceptMapConcept) : Integer;
    

    {@member Insert
      Insert FhirConceptMapConcept before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConceptMapConcept;
    

    {@member InsertItem
       Insert an existing FhirConceptMapConcept before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConceptMapConcept);
    
    {@member Item
       Get the iIndexth FhirConceptMapConcept. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConceptMapConcept. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapConcept);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConceptMapConcept;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConceptMapConcepts[index : Integer] : TFhirConceptMapConcept read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConceptMapConceptDependsOn : TFhirElement
    A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified concept can be resolved, and it has the specified value.
  }
  {!.Net HL7Connect.Fhir.ConceptMapConceptDependsOn}
  TFhirConceptMapConceptDependsOn = class (TFhirBackboneElement)
  private
    FConcept : TFhirUri;
    FSystem : TFhirUri;
    FCode : TFhirCode;
    Procedure SetConcept(value : TFhirUri);
    Function GetConceptST : String;
    Procedure SetConceptST(value : String);
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConceptMapConceptDependsOn; overload;
    function Clone : TFhirConceptMapConceptDependsOn; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member concept
      A reference to a specific concept that holds a coded value. This can be an element in a FHIR resource, or a specific reference to a data element in a different specification (e.g. v2) or a general reference to a kind of data field, or a reference to a value set with an appropriately narrow definition.
    }
    {@member concept
      Typed access to A reference to a specific concept that holds a coded value. This can be an element in a FHIR resource, or a specific reference to a data element in a different specification (e.g. v2) or a general reference to a kind of data field, or a reference to a value set with an appropriately narrow definition.
    }
    property concept : String read GetConceptST write SetConceptST;
    property conceptObject : TFhirUri read FConcept write SetConcept;

    {@member system
      System for a concept in the referenced concept.
    }
    {@member system
      Typed access to System for a concept in the referenced concept.
    }
    property system : String read GetSystemST write SetSystemST;
    property systemObject : TFhirUri read FSystem write SetSystem;

    {@member code
      Code for a concept in the referenced concept.
    }
    {@member code
      Typed access to Code for a concept in the referenced concept.
    }
    property code : String read GetCodeST write SetCodeST;
    property codeObject : TFhirCode read FCode write SetCode;

  end;


  TFhirConceptMapConceptDependsOnListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapConceptDependsOnList;
    function GetCurrent : TFhirConceptMapConceptDependsOn;
  public
    Constructor Create(list : TFhirConceptMapConceptDependsOnList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapConceptDependsOn read GetCurrent;
  end;


  {@Class TFhirConceptMapConceptDependsOnList
    A list of FhirConceptMapConceptDependsOn
  }
  {!.Net HL7Connect.Fhir.ConceptMapConceptDependsOnList}
  TFhirConceptMapConceptDependsOnList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConceptMapConceptDependsOn;
    procedure SetItemN(index : Integer; value : TFhirConceptMapConceptDependsOn);
  public
    {!script hide}
    function Link : TFhirConceptMapConceptDependsOnList; Overload;
    function Clone : TFhirConceptMapConceptDependsOnList; Overload;
    function GetEnumerator : TFhirConceptMapConceptDependsOnListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConceptMapConceptDependsOn to the end of the list.
    }
    function Append : TFhirConceptMapConceptDependsOn;

    
    {@member AddItem
      Add an already existing FhirConceptMapConceptDependsOn to the end of the list.
    }
    procedure AddItem(value : TFhirConceptMapConceptDependsOn); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConceptMapConceptDependsOn) : Integer;
    

    {@member Insert
      Insert FhirConceptMapConceptDependsOn before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConceptMapConceptDependsOn;
    

    {@member InsertItem
       Insert an existing FhirConceptMapConceptDependsOn before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConceptMapConceptDependsOn);
    
    {@member Item
       Get the iIndexth FhirConceptMapConceptDependsOn. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConceptMapConceptDependsOn. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapConceptDependsOn);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConceptMapConceptDependsOn;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConceptMapConceptDependsOns[index : Integer] : TFhirConceptMapConceptDependsOn read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConceptMapConceptMap : TFhirElement
    A concept from the target value set that this concept maps to.
  }
  {!.Net HL7Connect.Fhir.ConceptMapConceptMap}
  TFhirConceptMapConceptMap = class (TFhirBackboneElement)
  private
    FSystem : TFhirUri;
    FCode : TFhirCode;
    FEquivalence : TFhirEnum;
    FComments : TFhirString;
    FproductList : TFhirConceptMapConceptDependsOnList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetEquivalence(value : TFhirEnum);
    Function GetEquivalenceST : TFhirConceptEquivalence;
    Procedure SetEquivalenceST(value : TFhirConceptEquivalence);
    Procedure SetComments(value : TFhirString);
    Function GetCommentsST : String;
    Procedure SetCommentsST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConceptMapConceptMap; overload;
    function Clone : TFhirConceptMapConceptMap; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member system
      System of the target.
    }
    {@member system
      Typed access to System of the target.
    }
    property system : String read GetSystemST write SetSystemST;
    property systemObject : TFhirUri read FSystem write SetSystem;

    {@member code
      Code that identifies the target concept.
    }
    {@member code
      Typed access to Code that identifies the target concept.
    }
    property code : String read GetCodeST write SetCodeST;
    property codeObject : TFhirCode read FCode write SetCode;

    {@member equivalence
      equal | equivalent | wider | subsumes | narrower | specialises | inexact | unmatched | disjoint.
    }
    property equivalence : TFhirConceptEquivalence read GetEquivalenceST write SetEquivalenceST;
    property equivalenceObject : TFhirEnum read FEquivalence write SetEquivalence;

    {@member comments
      Description of status/issues in mapping.
    }
    {@member comments
      Typed access to Description of status/issues in mapping.
    }
    property comments : String read GetCommentsST write SetCommentsST;
    property commentsObject : TFhirString read FComments write SetComments;

    {@member productList
      A set of additional outcomes from this mapping to other value sets. To properly execute this mapping, the specified value set must be mapped to some data element or source that is in context. The mapping may still be useful without a place for the additional data elements, but the equivalence cannot be relied on.
    }
    property productList : TFhirConceptMapConceptDependsOnList read FProductList;

  end;


  TFhirConceptMapConceptMapListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapConceptMapList;
    function GetCurrent : TFhirConceptMapConceptMap;
  public
    Constructor Create(list : TFhirConceptMapConceptMapList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapConceptMap read GetCurrent;
  end;


  {@Class TFhirConceptMapConceptMapList
    A list of FhirConceptMapConceptMap
  }
  {!.Net HL7Connect.Fhir.ConceptMapConceptMapList}
  TFhirConceptMapConceptMapList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConceptMapConceptMap;
    procedure SetItemN(index : Integer; value : TFhirConceptMapConceptMap);
  public
    {!script hide}
    function Link : TFhirConceptMapConceptMapList; Overload;
    function Clone : TFhirConceptMapConceptMapList; Overload;
    function GetEnumerator : TFhirConceptMapConceptMapListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConceptMapConceptMap to the end of the list.
    }
    function Append : TFhirConceptMapConceptMap;

    
    {@member AddItem
      Add an already existing FhirConceptMapConceptMap to the end of the list.
    }
    procedure AddItem(value : TFhirConceptMapConceptMap); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConceptMapConceptMap) : Integer;
    

    {@member Insert
      Insert FhirConceptMapConceptMap before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConceptMapConceptMap;
    

    {@member InsertItem
       Insert an existing FhirConceptMapConceptMap before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConceptMapConceptMap);
    
    {@member Item
       Get the iIndexth FhirConceptMapConceptMap. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConceptMapConceptMap. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapConceptMap);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConceptMapConceptMap;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConceptMapConceptMaps[index : Integer] : TFhirConceptMapConceptMap read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConditionStage : TFhirElement
    Clinical stage or grade of a condition. May include formal severity assessments.
  }
  {!.Net HL7Connect.Fhir.ConditionStage}
  TFhirConditionStage = class (TFhirBackboneElement)
  private
    FSummary : TFhirCodeableConcept;
    FassessmentList : TFhirResourceReferenceList{Resource};
    Procedure SetSummary(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConditionStage; overload;
    function Clone : TFhirConditionStage; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member summary
      A simple summary of the stage such as "Stage 3". The determination of the stage is disease-specific.
    }
    property summary : TFhirCodeableConcept read FSummary write SetSummary;
    property summaryObject : TFhirCodeableConcept read FSummary write SetSummary;

    {@member assessmentList
      Reference to a formal record of the evidence on which the staging assessment is based.
    }
    property assessmentList : TFhirResourceReferenceList{Resource} read FAssessmentList;

  end;


  TFhirConditionStageListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConditionStageList;
    function GetCurrent : TFhirConditionStage;
  public
    Constructor Create(list : TFhirConditionStageList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConditionStage read GetCurrent;
  end;


  {@Class TFhirConditionStageList
    A list of FhirConditionStage
  }
  {!.Net HL7Connect.Fhir.ConditionStageList}
  TFhirConditionStageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionStage;
    procedure SetItemN(index : Integer; value : TFhirConditionStage);
  public
    {!script hide}
    function Link : TFhirConditionStageList; Overload;
    function Clone : TFhirConditionStageList; Overload;
    function GetEnumerator : TFhirConditionStageListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConditionStage to the end of the list.
    }
    function Append : TFhirConditionStage;

    
    {@member AddItem
      Add an already existing FhirConditionStage to the end of the list.
    }
    procedure AddItem(value : TFhirConditionStage); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConditionStage) : Integer;
    

    {@member Insert
      Insert FhirConditionStage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConditionStage;
    

    {@member InsertItem
       Insert an existing FhirConditionStage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConditionStage);
    
    {@member Item
       Get the iIndexth FhirConditionStage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConditionStage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConditionStage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConditionStage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConditionStages[index : Integer] : TFhirConditionStage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConditionEvidence : TFhirElement
    Supporting Evidence / manifestations that are the basis on which this condition is suspected or confirmed.
  }
  {!.Net HL7Connect.Fhir.ConditionEvidence}
  TFhirConditionEvidence = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FdetailList : TFhirResourceReferenceList{Resource};
    Procedure SetCode(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConditionEvidence; overload;
    function Clone : TFhirConditionEvidence; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      A manifestation or symptom that led to the recording of this condition.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;
    property codeObject : TFhirCodeableConcept read FCode write SetCode;

    {@member detailList
      Links to other relevant information, including pathology reports.
    }
    property detailList : TFhirResourceReferenceList{Resource} read FDetailList;

  end;


  TFhirConditionEvidenceListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConditionEvidenceList;
    function GetCurrent : TFhirConditionEvidence;
  public
    Constructor Create(list : TFhirConditionEvidenceList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConditionEvidence read GetCurrent;
  end;


  {@Class TFhirConditionEvidenceList
    A list of FhirConditionEvidence
  }
  {!.Net HL7Connect.Fhir.ConditionEvidenceList}
  TFhirConditionEvidenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionEvidence;
    procedure SetItemN(index : Integer; value : TFhirConditionEvidence);
  public
    {!script hide}
    function Link : TFhirConditionEvidenceList; Overload;
    function Clone : TFhirConditionEvidenceList; Overload;
    function GetEnumerator : TFhirConditionEvidenceListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConditionEvidence to the end of the list.
    }
    function Append : TFhirConditionEvidence;

    
    {@member AddItem
      Add an already existing FhirConditionEvidence to the end of the list.
    }
    procedure AddItem(value : TFhirConditionEvidence); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConditionEvidence) : Integer;
    

    {@member Insert
      Insert FhirConditionEvidence before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConditionEvidence;
    

    {@member InsertItem
       Insert an existing FhirConditionEvidence before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConditionEvidence);
    
    {@member Item
       Get the iIndexth FhirConditionEvidence. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConditionEvidence. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConditionEvidence);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConditionEvidence;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConditionEvidences[index : Integer] : TFhirConditionEvidence read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConditionLocation : TFhirElement
    The anatomical location where this condition manifests itself.
  }
  {!.Net HL7Connect.Fhir.ConditionLocation}
  TFhirConditionLocation = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FDetail : TFhirString;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetDetail(value : TFhirString);
    Function GetDetailST : String;
    Procedure SetDetailST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConditionLocation; overload;
    function Clone : TFhirConditionLocation; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      Code that identifies the structural location.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;
    property codeObject : TFhirCodeableConcept read FCode write SetCode;

    {@member detail
      Detailed anatomical location information.
    }
    {@member detail
      Typed access to Detailed anatomical location information.
    }
    property detail : String read GetDetailST write SetDetailST;
    property detailObject : TFhirString read FDetail write SetDetail;

  end;


  TFhirConditionLocationListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConditionLocationList;
    function GetCurrent : TFhirConditionLocation;
  public
    Constructor Create(list : TFhirConditionLocationList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConditionLocation read GetCurrent;
  end;


  {@Class TFhirConditionLocationList
    A list of FhirConditionLocation
  }
  {!.Net HL7Connect.Fhir.ConditionLocationList}
  TFhirConditionLocationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionLocation;
    procedure SetItemN(index : Integer; value : TFhirConditionLocation);
  public
    {!script hide}
    function Link : TFhirConditionLocationList; Overload;
    function Clone : TFhirConditionLocationList; Overload;
    function GetEnumerator : TFhirConditionLocationListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConditionLocation to the end of the list.
    }
    function Append : TFhirConditionLocation;

    
    {@member AddItem
      Add an already existing FhirConditionLocation to the end of the list.
    }
    procedure AddItem(value : TFhirConditionLocation); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConditionLocation) : Integer;
    

    {@member Insert
      Insert FhirConditionLocation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConditionLocation;
    

    {@member InsertItem
       Insert an existing FhirConditionLocation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConditionLocation);
    
    {@member Item
       Get the iIndexth FhirConditionLocation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConditionLocation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConditionLocation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConditionLocation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConditionLocations[index : Integer] : TFhirConditionLocation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConditionRelatedItem : TFhirElement
    Further conditions, problems, diagnoses, procedures or events that are related in some way to this condition, or the substance that caused/triggered this Condition.
  }
  {!.Net HL7Connect.Fhir.ConditionRelatedItem}
  TFhirConditionRelatedItem = class (TFhirBackboneElement)
  private
    FType_ : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FTarget : TFhirResourceReference{Resource};
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirConditionRelationshipType;
    Procedure SetType_ST(value : TFhirConditionRelationshipType);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetTarget(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConditionRelatedItem; overload;
    function Clone : TFhirConditionRelatedItem; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member type_
      The type of relationship that this condition has to the related item.
    }
    property type_ : TFhirConditionRelationshipType read GetType_ST write SetType_ST;
    property type_Object : TFhirEnum read FType_ write SetType_;

    {@member code
      Code that identifies the target of this relationship. The code takes the place of a detailed instance target.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;
    property codeObject : TFhirCodeableConcept read FCode write SetCode;

    {@member target
      Target of the relationship.
    }
    property target : TFhirResourceReference{Resource} read FTarget write SetTarget;
    property targetObject : TFhirResourceReference{Resource} read FTarget write SetTarget;

  end;


  TFhirConditionRelatedItemListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConditionRelatedItemList;
    function GetCurrent : TFhirConditionRelatedItem;
  public
    Constructor Create(list : TFhirConditionRelatedItemList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConditionRelatedItem read GetCurrent;
  end;


  {@Class TFhirConditionRelatedItemList
    A list of FhirConditionRelatedItem
  }
  {!.Net HL7Connect.Fhir.ConditionRelatedItemList}
  TFhirConditionRelatedItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionRelatedItem;
    procedure SetItemN(index : Integer; value : TFhirConditionRelatedItem);
  public
    {!script hide}
    function Link : TFhirConditionRelatedItemList; Overload;
    function Clone : TFhirConditionRelatedItemList; Overload;
    function GetEnumerator : TFhirConditionRelatedItemListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConditionRelatedItem to the end of the list.
    }
    function Append : TFhirConditionRelatedItem;

    
    {@member AddItem
      Add an already existing FhirConditionRelatedItem to the end of the list.
    }
    procedure AddItem(value : TFhirConditionRelatedItem); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConditionRelatedItem) : Integer;
    

    {@member Insert
      Insert FhirConditionRelatedItem before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConditionRelatedItem;
    

    {@member InsertItem
       Insert an existing FhirConditionRelatedItem before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConditionRelatedItem);
    
    {@member Item
       Get the iIndexth FhirConditionRelatedItem. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConditionRelatedItem. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConditionRelatedItem);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConditionRelatedItem;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConditionRelatedItems[index : Integer] : TFhirConditionRelatedItem read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceSoftware : TFhirElement
    Software that is covered by this conformance statement.  It is used when the profile describes the capabilities of a particular software version, independent of an installation.
  }
  {!.Net HL7Connect.Fhir.ConformanceSoftware}
  TFhirConformanceSoftware = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FVersion : TFhirString;
    FReleaseDate : TFhirDateTime;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetReleaseDate(value : TFhirDateTime);
    Function GetReleaseDateST : TDateTimeEx;
    Procedure SetReleaseDateST(value : TDateTimeEx);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceSoftware; overload;
    function Clone : TFhirConformanceSoftware; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member name
      Name software is known by.
    }
    {@member name
      Typed access to Name software is known by.
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member version
      The version identifier for the software covered by this statement.
    }
    {@member version
      Typed access to The version identifier for the software covered by this statement.
    }
    property version : String read GetVersionST write SetVersionST;
    property versionObject : TFhirString read FVersion write SetVersion;

    {@member releaseDate
      Date this version of the software released.
    }
    {@member releaseDate
      Typed access to Date this version of the software released.
    }
    property releaseDate : TDateTimeEx read GetReleaseDateST write SetReleaseDateST;
    property releaseDateObject : TFhirDateTime read FReleaseDate write SetReleaseDate;

  end;


  TFhirConformanceSoftwareListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConformanceSoftwareList;
    function GetCurrent : TFhirConformanceSoftware;
  public
    Constructor Create(list : TFhirConformanceSoftwareList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceSoftware read GetCurrent;
  end;


  {@Class TFhirConformanceSoftwareList
    A list of FhirConformanceSoftware
  }
  {!.Net HL7Connect.Fhir.ConformanceSoftwareList}
  TFhirConformanceSoftwareList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceSoftware;
    procedure SetItemN(index : Integer; value : TFhirConformanceSoftware);
  public
    {!script hide}
    function Link : TFhirConformanceSoftwareList; Overload;
    function Clone : TFhirConformanceSoftwareList; Overload;
    function GetEnumerator : TFhirConformanceSoftwareListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConformanceSoftware to the end of the list.
    }
    function Append : TFhirConformanceSoftware;

    
    {@member AddItem
      Add an already existing FhirConformanceSoftware to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceSoftware); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceSoftware) : Integer;
    

    {@member Insert
      Insert FhirConformanceSoftware before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceSoftware;
    

    {@member InsertItem
       Insert an existing FhirConformanceSoftware before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceSoftware);
    
    {@member Item
       Get the iIndexth FhirConformanceSoftware. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceSoftware. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceSoftware);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceSoftware;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceSoftwares[index : Integer] : TFhirConformanceSoftware read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceImplementation : TFhirElement
    Identifies a specific implementation instance that is described by the conformance statement - i.e. a particular installation, rather than the capabilities of a software program.
  }
  {!.Net HL7Connect.Fhir.ConformanceImplementation}
  TFhirConformanceImplementation = class (TFhirBackboneElement)
  private
    FDescription : TFhirString;
    FUrl : TFhirUri;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceImplementation; overload;
    function Clone : TFhirConformanceImplementation; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member description
      Information about the specific installation that this conformance statement relates to.
    }
    {@member description
      Typed access to Information about the specific installation that this conformance statement relates to.
    }
    property description : String read GetDescriptionST write SetDescriptionST;
    property descriptionObject : TFhirString read FDescription write SetDescription;

    {@member url
      A base URL for the implementation.  This forms the base for REST interfaces as well as the mailbox and document interfaces.
    }
    {@member url
      Typed access to A base URL for the implementation.  This forms the base for REST interfaces as well as the mailbox and document interfaces.
    }
    property url : String read GetUrlST write SetUrlST;
    property urlObject : TFhirUri read FUrl write SetUrl;

  end;


  TFhirConformanceImplementationListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConformanceImplementationList;
    function GetCurrent : TFhirConformanceImplementation;
  public
    Constructor Create(list : TFhirConformanceImplementationList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceImplementation read GetCurrent;
  end;


  {@Class TFhirConformanceImplementationList
    A list of FhirConformanceImplementation
  }
  {!.Net HL7Connect.Fhir.ConformanceImplementationList}
  TFhirConformanceImplementationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceImplementation;
    procedure SetItemN(index : Integer; value : TFhirConformanceImplementation);
  public
    {!script hide}
    function Link : TFhirConformanceImplementationList; Overload;
    function Clone : TFhirConformanceImplementationList; Overload;
    function GetEnumerator : TFhirConformanceImplementationListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConformanceImplementation to the end of the list.
    }
    function Append : TFhirConformanceImplementation;

    
    {@member AddItem
      Add an already existing FhirConformanceImplementation to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceImplementation); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceImplementation) : Integer;
    

    {@member Insert
      Insert FhirConformanceImplementation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceImplementation;
    

    {@member InsertItem
       Insert an existing FhirConformanceImplementation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceImplementation);
    
    {@member Item
       Get the iIndexth FhirConformanceImplementation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceImplementation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceImplementation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceImplementation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceImplementations[index : Integer] : TFhirConformanceImplementation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRest : TFhirElement
    A definition of the restful capabilities of the solution, if any.
  }
  {!.Net HL7Connect.Fhir.ConformanceRest}
  TFhirConformanceRest = class (TFhirBackboneElement)
  private
    FMode : TFhirEnum;
    FDocumentation : TFhirString;
    FSecurity : TFhirConformanceRestSecurity;
    FresourceList : TFhirConformanceRestResourceList;
    FoperationList : TFhirConformanceRestOperationList;
    FqueryList : TFhirConformanceRestQueryList;
    FdocumentMailboxList : TFhirUriList;
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirRestfulConformanceMode;
    Procedure SetModeST(value : TFhirRestfulConformanceMode);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetSecurity(value : TFhirConformanceRestSecurity);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRest; overload;
    function Clone : TFhirConformanceRest; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member mode
      Identifies whether this portion of the statement is describing ability to initiate or receive restful operations.
    }
    property mode : TFhirRestfulConformanceMode read GetModeST write SetModeST;
    property modeObject : TFhirEnum read FMode write SetMode;

    {@member documentation
      Information about the system's restful capabilities that apply across all applications, such as security.
    }
    {@member documentation
      Typed access to Information about the system's restful capabilities that apply across all applications, such as security.
    }
    property documentation : String read GetDocumentationST write SetDocumentationST;
    property documentationObject : TFhirString read FDocumentation write SetDocumentation;

    {@member security
      Information about security of implementation.
    }
    property security : TFhirConformanceRestSecurity read FSecurity write SetSecurity;
    property securityObject : TFhirConformanceRestSecurity read FSecurity write SetSecurity;

    {@member resourceList
      A specification of the restful capabilities of the solution for a specific resource type.
    }
    property resourceList : TFhirConformanceRestResourceList read FResourceList;

    {@member operationList
      A specification of restful operations supported by the system.
    }
    property operationList : TFhirConformanceRestOperationList read FOperationList;

    {@member queryList
      Definition of a named query and its parameters and their meaning.
    }
    property queryList : TFhirConformanceRestQueryList read FQueryList;

    {@member documentMailboxList
      A list of profiles that this server implements for accepting documents in the mailbox. If this list is empty, then documents are not accepted. The base specification has the profile identifier "http://hl7.org/fhir/documents/mailbox". Other specifications can declare their own identifier for this purpose.
    }
    property documentMailboxList : TFhirUriList read FDocumentMailboxList;

  end;


  TFhirConformanceRestListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestList;
    function GetCurrent : TFhirConformanceRest;
  public
    Constructor Create(list : TFhirConformanceRestList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRest read GetCurrent;
  end;


  {@Class TFhirConformanceRestList
    A list of FhirConformanceRest
  }
  {!.Net HL7Connect.Fhir.ConformanceRestList}
  TFhirConformanceRestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRest;
    procedure SetItemN(index : Integer; value : TFhirConformanceRest);
  public
    {!script hide}
    function Link : TFhirConformanceRestList; Overload;
    function Clone : TFhirConformanceRestList; Overload;
    function GetEnumerator : TFhirConformanceRestListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRest to the end of the list.
    }
    function Append : TFhirConformanceRest;

    
    {@member AddItem
      Add an already existing FhirConformanceRest to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRest); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRest) : Integer;
    

    {@member Insert
      Insert FhirConformanceRest before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRest;
    

    {@member InsertItem
       Insert an existing FhirConformanceRest before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRest);
    
    {@member Item
       Get the iIndexth FhirConformanceRest. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRest. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRest);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRest;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRests[index : Integer] : TFhirConformanceRest read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestSecurity : TFhirElement
    Information about security of implementation.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestSecurity}
  TFhirConformanceRestSecurity = class (TFhirBackboneElement)
  private
    FCors : TFhirBoolean;
    FserviceList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FcertificateList : TFhirConformanceRestSecurityCertificateList;
    Procedure SetCors(value : TFhirBoolean);
    Function GetCorsST : Boolean;
    Procedure SetCorsST(value : Boolean);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestSecurity; overload;
    function Clone : TFhirConformanceRestSecurity; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member cors
      Server adds CORS headers when responding to requests - this enables javascript applications to yuse the server.
    }
    {@member cors
      Typed access to Server adds CORS headers when responding to requests - this enables javascript applications to yuse the server.
    }
    property cors : Boolean read GetCorsST write SetCorsST;
    property corsObject : TFhirBoolean read FCors write SetCors;

    {@member serviceList
      Types of security services are supported/required by the system.
    }
    property serviceList : TFhirCodeableConceptList read FServiceList;

    {@member description
      General description of how security works.
    }
    {@member description
      Typed access to General description of how security works.
    }
    property description : String read GetDescriptionST write SetDescriptionST;
    property descriptionObject : TFhirString read FDescription write SetDescription;

    {@member certificateList
      Certificates associated with security profiles.
    }
    property certificateList : TFhirConformanceRestSecurityCertificateList read FCertificateList;

  end;


  TFhirConformanceRestSecurityListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestSecurityList;
    function GetCurrent : TFhirConformanceRestSecurity;
  public
    Constructor Create(list : TFhirConformanceRestSecurityList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRestSecurity read GetCurrent;
  end;


  {@Class TFhirConformanceRestSecurityList
    A list of FhirConformanceRestSecurity
  }
  {!.Net HL7Connect.Fhir.ConformanceRestSecurityList}
  TFhirConformanceRestSecurityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestSecurity;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestSecurity);
  public
    {!script hide}
    function Link : TFhirConformanceRestSecurityList; Overload;
    function Clone : TFhirConformanceRestSecurityList; Overload;
    function GetEnumerator : TFhirConformanceRestSecurityListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestSecurity to the end of the list.
    }
    function Append : TFhirConformanceRestSecurity;

    
    {@member AddItem
      Add an already existing FhirConformanceRestSecurity to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestSecurity); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestSecurity) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestSecurity before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestSecurity;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestSecurity before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestSecurity);
    
    {@member Item
       Get the iIndexth FhirConformanceRestSecurity. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestSecurity. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestSecurity);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestSecurity;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestSecurities[index : Integer] : TFhirConformanceRestSecurity read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestSecurityCertificate : TFhirElement
    Certificates associated with security profiles.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestSecurityCertificate}
  TFhirConformanceRestSecurityCertificate = class (TFhirBackboneElement)
  private
    FType_ : TFhirCode;
    FBlob : TFhirBase64Binary;
    Procedure SetType_(value : TFhirCode);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetBlob(value : TFhirBase64Binary);
    Function GetBlobST : String;
    Procedure SetBlobST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestSecurityCertificate; overload;
    function Clone : TFhirConformanceRestSecurityCertificate; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member type_
      Mime type for certificate.
    }
    {@member type_
      Typed access to Mime type for certificate.
    }
    property type_ : String read GetType_ST write SetType_ST;
    property type_Object : TFhirCode read FType_ write SetType_;

    {@member blob
      Actual certificate.
    }
    {@member blob
      Typed access to Actual certificate.
    }
    property blob : String read GetBlobST write SetBlobST;
    property blobObject : TFhirBase64Binary read FBlob write SetBlob;

  end;


  TFhirConformanceRestSecurityCertificateListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestSecurityCertificateList;
    function GetCurrent : TFhirConformanceRestSecurityCertificate;
  public
    Constructor Create(list : TFhirConformanceRestSecurityCertificateList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRestSecurityCertificate read GetCurrent;
  end;


  {@Class TFhirConformanceRestSecurityCertificateList
    A list of FhirConformanceRestSecurityCertificate
  }
  {!.Net HL7Connect.Fhir.ConformanceRestSecurityCertificateList}
  TFhirConformanceRestSecurityCertificateList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestSecurityCertificate;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestSecurityCertificate);
  public
    {!script hide}
    function Link : TFhirConformanceRestSecurityCertificateList; Overload;
    function Clone : TFhirConformanceRestSecurityCertificateList; Overload;
    function GetEnumerator : TFhirConformanceRestSecurityCertificateListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestSecurityCertificate to the end of the list.
    }
    function Append : TFhirConformanceRestSecurityCertificate;

    
    {@member AddItem
      Add an already existing FhirConformanceRestSecurityCertificate to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestSecurityCertificate); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestSecurityCertificate) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestSecurityCertificate before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestSecurityCertificate;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestSecurityCertificate before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestSecurityCertificate);
    
    {@member Item
       Get the iIndexth FhirConformanceRestSecurityCertificate. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestSecurityCertificate. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestSecurityCertificate);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestSecurityCertificate;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestSecurityCertificates[index : Integer] : TFhirConformanceRestSecurityCertificate read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestResource : TFhirElement
    A specification of the restful capabilities of the solution for a specific resource type.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResource}
  TFhirConformanceRestResource = class (TFhirBackboneElement)
  private
    FType_ : TFhirCode;
    FProfile : TFhirResourceReference{TFhirProfile};
    FoperationList : TFhirConformanceRestResourceOperationList;
    FReadHistory : TFhirBoolean;
    FUpdateCreate : TFhirBoolean;
    FsearchIncludeList : TFhirStringList;
    FsearchParamList : TFhirConformanceRestResourceSearchParamList;
    Procedure SetType_(value : TFhirCode);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetProfile(value : TFhirResourceReference{TFhirProfile});
    Procedure SetReadHistory(value : TFhirBoolean);
    Function GetReadHistoryST : Boolean;
    Procedure SetReadHistoryST(value : Boolean);
    Procedure SetUpdateCreate(value : TFhirBoolean);
    Function GetUpdateCreateST : Boolean;
    Procedure SetUpdateCreateST(value : Boolean);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestResource; overload;
    function Clone : TFhirConformanceRestResource; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member type_
      A type of resource exposed via the restful interface.
    }
    {@member type_
      Typed access to A type of resource exposed via the restful interface.
    }
    property type_ : String read GetType_ST write SetType_ST;
    property type_Object : TFhirCode read FType_ write SetType_;

    {@member profile
      A specification of the profile that describes the solution's support for the resource, including any constraints on cardinality, bindings, lengths or other limitations.
    }
    property profile : TFhirResourceReference{TFhirProfile} read FProfile write SetProfile;
    property profileObject : TFhirResourceReference{TFhirProfile} read FProfile write SetProfile;

    {@member operationList
      Identifies a restful operation supported by the solution.
    }
    property operationList : TFhirConformanceRestResourceOperationList read FOperationList;

    {@member readHistory
      A flag for whether the server is able to return past versions as part of the vRead operation.
    }
    {@member readHistory
      Typed access to A flag for whether the server is able to return past versions as part of the vRead operation.
    }
    property readHistory : Boolean read GetReadHistoryST write SetReadHistoryST;
    property readHistoryObject : TFhirBoolean read FReadHistory write SetReadHistory;

    {@member updateCreate
      A flag to indicate that the server allows the client to create new identities on the server. If the update operation is used (client) or allowed (server) to a new location where a resource doesn't already exist. This means that the server allows the client to create new identities on the server.
    }
    {@member updateCreate
      Typed access to A flag to indicate that the server allows the client to create new identities on the server. If the update operation is used (client) or allowed (server) to a new location where a resource doesn't already exist. This means that the server allows the client to create new identities on the server.
    }
    property updateCreate : Boolean read GetUpdateCreateST write SetUpdateCreateST;
    property updateCreateObject : TFhirBoolean read FUpdateCreate write SetUpdateCreate;

    {@member searchIncludeList
      A list of _include values supported by the server.
    }
    property searchIncludeList : TFhirStringList read FSearchIncludeList;

    {@member searchParamList
      Additional search parameters for implementations to support and/or make use of.
    }
    property searchParamList : TFhirConformanceRestResourceSearchParamList read FSearchParamList;

  end;


  TFhirConformanceRestResourceListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestResourceList;
    function GetCurrent : TFhirConformanceRestResource;
  public
    Constructor Create(list : TFhirConformanceRestResourceList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRestResource read GetCurrent;
  end;


  {@Class TFhirConformanceRestResourceList
    A list of FhirConformanceRestResource
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceList}
  TFhirConformanceRestResourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestResource;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestResource);
  public
    {!script hide}
    function Link : TFhirConformanceRestResourceList; Overload;
    function Clone : TFhirConformanceRestResourceList; Overload;
    function GetEnumerator : TFhirConformanceRestResourceListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestResource to the end of the list.
    }
    function Append : TFhirConformanceRestResource;

    
    {@member AddItem
      Add an already existing FhirConformanceRestResource to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestResource); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestResource) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestResource before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestResource;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestResource before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestResource);
    
    {@member Item
       Get the iIndexth FhirConformanceRestResource. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestResource. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestResource);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestResource;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestResources[index : Integer] : TFhirConformanceRestResource read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestResourceOperation : TFhirElement
    Identifies a restful operation supported by the solution.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceOperation}
  TFhirConformanceRestResourceOperation = class (TFhirBackboneElement)
  private
    FCode : TFhirEnum;
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirTypeRestfulOperation;
    Procedure SetCodeST(value : TFhirTypeRestfulOperation);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestResourceOperation; overload;
    function Clone : TFhirConformanceRestResourceOperation; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      Coded identifier of the operation, supported by the system resource.
    }
    property code : TFhirTypeRestfulOperation read GetCodeST write SetCodeST;
    property codeObject : TFhirEnum read FCode write SetCode;

    {@member documentation
      Guidance specific to the implementation of this operation, such as 'delete is a logical delete' or 'updates are only allowed with version id' or 'creates permitted from pre-authorized certificates only'.
    }
    {@member documentation
      Typed access to Guidance specific to the implementation of this operation, such as 'delete is a logical delete' or 'updates are only allowed with version id' or 'creates permitted from pre-authorized certificates only'.
    }
    property documentation : String read GetDocumentationST write SetDocumentationST;
    property documentationObject : TFhirString read FDocumentation write SetDocumentation;

  end;


  TFhirConformanceRestResourceOperationListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestResourceOperationList;
    function GetCurrent : TFhirConformanceRestResourceOperation;
  public
    Constructor Create(list : TFhirConformanceRestResourceOperationList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRestResourceOperation read GetCurrent;
  end;


  {@Class TFhirConformanceRestResourceOperationList
    A list of FhirConformanceRestResourceOperation
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceOperationList}
  TFhirConformanceRestResourceOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestResourceOperation;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestResourceOperation);
  public
    {!script hide}
    function Link : TFhirConformanceRestResourceOperationList; Overload;
    function Clone : TFhirConformanceRestResourceOperationList; Overload;
    function GetEnumerator : TFhirConformanceRestResourceOperationListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestResourceOperation to the end of the list.
    }
    function Append : TFhirConformanceRestResourceOperation;

    
    {@member AddItem
      Add an already existing FhirConformanceRestResourceOperation to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestResourceOperation); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestResourceOperation) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestResourceOperation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestResourceOperation;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestResourceOperation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestResourceOperation);
    
    {@member Item
       Get the iIndexth FhirConformanceRestResourceOperation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestResourceOperation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestResourceOperation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestResourceOperation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestResourceOperations[index : Integer] : TFhirConformanceRestResourceOperation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestResourceSearchParam : TFhirElement
    Additional search parameters for implementations to support and/or make use of.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceSearchParam}
  TFhirConformanceRestResourceSearchParam = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FDefinition : TFhirUri;
    FType_ : TFhirEnum;
    FDocumentation : TFhirString;
    FtargetList : TFhirCodeList;
    FchainList : TFhirStringList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDefinition(value : TFhirUri);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirSearchParamType;
    Procedure SetType_ST(value : TFhirSearchParamType);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestResourceSearchParam; overload;
    function Clone : TFhirConformanceRestResourceSearchParam; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member name
      The name of the search parameter used in the interface.
    }
    {@member name
      Typed access to The name of the search parameter used in the interface.
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member definition
      A formal reference to where this parameter was first defined, so that a client can be confident of the meaning of the search parameter.
    }
    {@member definition
      Typed access to A formal reference to where this parameter was first defined, so that a client can be confident of the meaning of the search parameter.
    }
    property definition : String read GetDefinitionST write SetDefinitionST;
    property definitionObject : TFhirUri read FDefinition write SetDefinition;

    {@member type_
      The type of value a search parameter refers to, and how the content is interpreted.
    }
    property type_ : TFhirSearchParamType read GetType_ST write SetType_ST;
    property type_Object : TFhirEnum read FType_ write SetType_;

    {@member documentation
      This allows documentation of any distinct behaviors about how the search parameter is used.  For example, text matching algorithms.
    }
    {@member documentation
      Typed access to This allows documentation of any distinct behaviors about how the search parameter is used.  For example, text matching algorithms.
    }
    property documentation : String read GetDocumentationST write SetDocumentationST;
    property documentationObject : TFhirString read FDocumentation write SetDocumentation;

    {@member targetList
      Types of resource (if a resource is referenced).
    }
    property targetList : TFhirCodeList read FTargetList;

    {@member chainList
      Chained names supported.
    }
    property chainList : TFhirStringList read FChainList;

  end;


  TFhirConformanceRestResourceSearchParamListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestResourceSearchParamList;
    function GetCurrent : TFhirConformanceRestResourceSearchParam;
  public
    Constructor Create(list : TFhirConformanceRestResourceSearchParamList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRestResourceSearchParam read GetCurrent;
  end;


  {@Class TFhirConformanceRestResourceSearchParamList
    A list of FhirConformanceRestResourceSearchParam
  }
  {!.Net HL7Connect.Fhir.ConformanceRestResourceSearchParamList}
  TFhirConformanceRestResourceSearchParamList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestResourceSearchParam;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestResourceSearchParam);
  public
    {!script hide}
    function Link : TFhirConformanceRestResourceSearchParamList; Overload;
    function Clone : TFhirConformanceRestResourceSearchParamList; Overload;
    function GetEnumerator : TFhirConformanceRestResourceSearchParamListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestResourceSearchParam to the end of the list.
    }
    function Append : TFhirConformanceRestResourceSearchParam;

    
    {@member AddItem
      Add an already existing FhirConformanceRestResourceSearchParam to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestResourceSearchParam); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestResourceSearchParam) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestResourceSearchParam before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestResourceSearchParam;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestResourceSearchParam before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestResourceSearchParam);
    
    {@member Item
       Get the iIndexth FhirConformanceRestResourceSearchParam. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestResourceSearchParam. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestResourceSearchParam);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestResourceSearchParam;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestResourceSearchParams[index : Integer] : TFhirConformanceRestResourceSearchParam read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestOperation : TFhirElement
    A specification of restful operations supported by the system.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestOperation}
  TFhirConformanceRestOperation = class (TFhirBackboneElement)
  private
    FCode : TFhirEnum;
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirSystemRestfulOperation;
    Procedure SetCodeST(value : TFhirSystemRestfulOperation);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestOperation; overload;
    function Clone : TFhirConformanceRestOperation; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      A coded identifier of the operation, supported by the system.
    }
    property code : TFhirSystemRestfulOperation read GetCodeST write SetCodeST;
    property codeObject : TFhirEnum read FCode write SetCode;

    {@member documentation
      Guidance specific to the implementation of this operation, such as limitations on the kind of transactions allowed, or information about system wide search is implemented.
    }
    {@member documentation
      Typed access to Guidance specific to the implementation of this operation, such as limitations on the kind of transactions allowed, or information about system wide search is implemented.
    }
    property documentation : String read GetDocumentationST write SetDocumentationST;
    property documentationObject : TFhirString read FDocumentation write SetDocumentation;

  end;


  TFhirConformanceRestOperationListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestOperationList;
    function GetCurrent : TFhirConformanceRestOperation;
  public
    Constructor Create(list : TFhirConformanceRestOperationList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRestOperation read GetCurrent;
  end;


  {@Class TFhirConformanceRestOperationList
    A list of FhirConformanceRestOperation
  }
  {!.Net HL7Connect.Fhir.ConformanceRestOperationList}
  TFhirConformanceRestOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestOperation;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestOperation);
  public
    {!script hide}
    function Link : TFhirConformanceRestOperationList; Overload;
    function Clone : TFhirConformanceRestOperationList; Overload;
    function GetEnumerator : TFhirConformanceRestOperationListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestOperation to the end of the list.
    }
    function Append : TFhirConformanceRestOperation;

    
    {@member AddItem
      Add an already existing FhirConformanceRestOperation to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestOperation); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestOperation) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestOperation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestOperation;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestOperation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestOperation);
    
    {@member Item
       Get the iIndexth FhirConformanceRestOperation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestOperation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestOperation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestOperation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestOperations[index : Integer] : TFhirConformanceRestOperation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceRestQuery : TFhirElement
    Definition of a named query and its parameters and their meaning.
  }
  {!.Net HL7Connect.Fhir.ConformanceRestQuery}
  TFhirConformanceRestQuery = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FDefinition : TFhirUri;
    FDocumentation : TFhirString;
    FparameterList : TFhirConformanceRestResourceSearchParamList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDefinition(value : TFhirUri);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceRestQuery; overload;
    function Clone : TFhirConformanceRestQuery; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member name
      The name of a query, which is used in the _query parameter when the query is called.
    }
    {@member name
      Typed access to The name of a query, which is used in the _query parameter when the query is called.
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member definition
      Identifies the custom query, defined either in FHIR core or another profile.
    }
    {@member definition
      Typed access to Identifies the custom query, defined either in FHIR core or another profile.
    }
    property definition : String read GetDefinitionST write SetDefinitionST;
    property definitionObject : TFhirUri read FDefinition write SetDefinition;

    {@member documentation
      Additional information about how the query functions in this particular implementation.
    }
    {@member documentation
      Typed access to Additional information about how the query functions in this particular implementation.
    }
    property documentation : String read GetDocumentationST write SetDocumentationST;
    property documentationObject : TFhirString read FDocumentation write SetDocumentation;

    {@member parameterList
      Identifies which of the parameters for the named query are supported.
    }
    property parameterList : TFhirConformanceRestResourceSearchParamList read FParameterList;

  end;


  TFhirConformanceRestQueryListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestQueryList;
    function GetCurrent : TFhirConformanceRestQuery;
  public
    Constructor Create(list : TFhirConformanceRestQueryList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRestQuery read GetCurrent;
  end;


  {@Class TFhirConformanceRestQueryList
    A list of FhirConformanceRestQuery
  }
  {!.Net HL7Connect.Fhir.ConformanceRestQueryList}
  TFhirConformanceRestQueryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceRestQuery;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestQuery);
  public
    {!script hide}
    function Link : TFhirConformanceRestQueryList; Overload;
    function Clone : TFhirConformanceRestQueryList; Overload;
    function GetEnumerator : TFhirConformanceRestQueryListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConformanceRestQuery to the end of the list.
    }
    function Append : TFhirConformanceRestQuery;

    
    {@member AddItem
      Add an already existing FhirConformanceRestQuery to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceRestQuery); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceRestQuery) : Integer;
    

    {@member Insert
      Insert FhirConformanceRestQuery before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceRestQuery;
    

    {@member InsertItem
       Insert an existing FhirConformanceRestQuery before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceRestQuery);
    
    {@member Item
       Get the iIndexth FhirConformanceRestQuery. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceRestQuery. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestQuery);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceRestQuery;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceRestQueries[index : Integer] : TFhirConformanceRestQuery read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceMessaging : TFhirElement
    A description of the messaging capabilities of the solution.
  }
  {!.Net HL7Connect.Fhir.ConformanceMessaging}
  TFhirConformanceMessaging = class (TFhirBackboneElement)
  private
    FEndpoint : TFhirUri;
    FReliableCache : TFhirInteger;
    FDocumentation : TFhirString;
    FeventList : TFhirConformanceMessagingEventList;
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);
    Procedure SetReliableCache(value : TFhirInteger);
    Function GetReliableCacheST : String;
    Procedure SetReliableCacheST(value : String);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceMessaging; overload;
    function Clone : TFhirConformanceMessaging; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member endpoint
      An address to which messages and/or replies are to be sent.
    }
    {@member endpoint
      Typed access to An address to which messages and/or replies are to be sent.
    }
    property endpoint : String read GetEndpointST write SetEndpointST;
    property endpointObject : TFhirUri read FEndpoint write SetEndpoint;

    {@member reliableCache
      Length if the receiver's reliable messaging cache (if a receiver) or how long the cache length on the receiver should be (if a sender).
    }
    {@member reliableCache
      Typed access to Length if the receiver's reliable messaging cache (if a receiver) or how long the cache length on the receiver should be (if a sender).
    }
    property reliableCache : String read GetReliableCacheST write SetReliableCacheST;
    property reliableCacheObject : TFhirInteger read FReliableCache write SetReliableCache;

    {@member documentation
      Documentation about the system's messaging capabilities for this endpoint not otherwise documented by the conformance statement.  For example, process for becoming an authorized messaging exchange partner.
    }
    {@member documentation
      Typed access to Documentation about the system's messaging capabilities for this endpoint not otherwise documented by the conformance statement.  For example, process for becoming an authorized messaging exchange partner.
    }
    property documentation : String read GetDocumentationST write SetDocumentationST;
    property documentationObject : TFhirString read FDocumentation write SetDocumentation;

    {@member eventList
      A description of the solution's support for an event at this end point.
    }
    property eventList : TFhirConformanceMessagingEventList read FEventList;

  end;


  TFhirConformanceMessagingListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConformanceMessagingList;
    function GetCurrent : TFhirConformanceMessaging;
  public
    Constructor Create(list : TFhirConformanceMessagingList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceMessaging read GetCurrent;
  end;


  {@Class TFhirConformanceMessagingList
    A list of FhirConformanceMessaging
  }
  {!.Net HL7Connect.Fhir.ConformanceMessagingList}
  TFhirConformanceMessagingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceMessaging;
    procedure SetItemN(index : Integer; value : TFhirConformanceMessaging);
  public
    {!script hide}
    function Link : TFhirConformanceMessagingList; Overload;
    function Clone : TFhirConformanceMessagingList; Overload;
    function GetEnumerator : TFhirConformanceMessagingListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConformanceMessaging to the end of the list.
    }
    function Append : TFhirConformanceMessaging;

    
    {@member AddItem
      Add an already existing FhirConformanceMessaging to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceMessaging); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceMessaging) : Integer;
    

    {@member Insert
      Insert FhirConformanceMessaging before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceMessaging;
    

    {@member InsertItem
       Insert an existing FhirConformanceMessaging before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceMessaging);
    
    {@member Item
       Get the iIndexth FhirConformanceMessaging. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceMessaging. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceMessaging);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceMessaging;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceMessagings[index : Integer] : TFhirConformanceMessaging read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceMessagingEvent : TFhirElement
    A description of the solution's support for an event at this end point.
  }
  {!.Net HL7Connect.Fhir.ConformanceMessagingEvent}
  TFhirConformanceMessagingEvent = class (TFhirBackboneElement)
  private
    FCode : TFhirCoding;
    FCategory : TFhirEnum;
    FMode : TFhirEnum;
    FprotocolList : TFhirCodingList;
    FFocus : TFhirCode;
    FRequest : TFhirResourceReference{TFhirProfile};
    FResponse : TFhirResourceReference{TFhirProfile};
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirCoding);
    Procedure SetCategory(value : TFhirEnum);
    Function GetCategoryST : TFhirMessageSignificanceCategory;
    Procedure SetCategoryST(value : TFhirMessageSignificanceCategory);
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirMessageConformanceEventMode;
    Procedure SetModeST(value : TFhirMessageConformanceEventMode);
    Procedure SetFocus(value : TFhirCode);
    Function GetFocusST : String;
    Procedure SetFocusST(value : String);
    Procedure SetRequest(value : TFhirResourceReference{TFhirProfile});
    Procedure SetResponse(value : TFhirResourceReference{TFhirProfile});
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceMessagingEvent; overload;
    function Clone : TFhirConformanceMessagingEvent; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      A coded identifier of a supported messaging event.
    }
    property code : TFhirCoding read FCode write SetCode;
    property codeObject : TFhirCoding read FCode write SetCode;

    {@member category
      The impact of the content of the message.
    }
    property category : TFhirMessageSignificanceCategory read GetCategoryST write SetCategoryST;
    property categoryObject : TFhirEnum read FCategory write SetCategory;

    {@member mode
      The mode of this event declaration - whether application is sender or receiver.
    }
    property mode : TFhirMessageConformanceEventMode read GetModeST write SetModeST;
    property modeObject : TFhirEnum read FMode write SetMode;

    {@member protocolList
      A list of the messaging transport protocol(s) identifiers, supported by this endpoint.
    }
    property protocolList : TFhirCodingList read FProtocolList;

    {@member focus
      A resource associated with the event.  This is the resource that defines the event.
    }
    {@member focus
      Typed access to A resource associated with the event.  This is the resource that defines the event.
    }
    property focus : String read GetFocusST write SetFocusST;
    property focusObject : TFhirCode read FFocus write SetFocus;

    {@member request
      Information about the request for this event.
    }
    property request : TFhirResourceReference{TFhirProfile} read FRequest write SetRequest;
    property requestObject : TFhirResourceReference{TFhirProfile} read FRequest write SetRequest;

    {@member response
      Information about the response for this event.
    }
    property response : TFhirResourceReference{TFhirProfile} read FResponse write SetResponse;
    property responseObject : TFhirResourceReference{TFhirProfile} read FResponse write SetResponse;

    {@member documentation
      Guidance on how this event is handled, such as internal system trigger points, business rules, etc.
    }
    {@member documentation
      Typed access to Guidance on how this event is handled, such as internal system trigger points, business rules, etc.
    }
    property documentation : String read GetDocumentationST write SetDocumentationST;
    property documentationObject : TFhirString read FDocumentation write SetDocumentation;

  end;


  TFhirConformanceMessagingEventListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConformanceMessagingEventList;
    function GetCurrent : TFhirConformanceMessagingEvent;
  public
    Constructor Create(list : TFhirConformanceMessagingEventList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceMessagingEvent read GetCurrent;
  end;


  {@Class TFhirConformanceMessagingEventList
    A list of FhirConformanceMessagingEvent
  }
  {!.Net HL7Connect.Fhir.ConformanceMessagingEventList}
  TFhirConformanceMessagingEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceMessagingEvent;
    procedure SetItemN(index : Integer; value : TFhirConformanceMessagingEvent);
  public
    {!script hide}
    function Link : TFhirConformanceMessagingEventList; Overload;
    function Clone : TFhirConformanceMessagingEventList; Overload;
    function GetEnumerator : TFhirConformanceMessagingEventListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConformanceMessagingEvent to the end of the list.
    }
    function Append : TFhirConformanceMessagingEvent;

    
    {@member AddItem
      Add an already existing FhirConformanceMessagingEvent to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceMessagingEvent); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceMessagingEvent) : Integer;
    

    {@member Insert
      Insert FhirConformanceMessagingEvent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceMessagingEvent;
    

    {@member InsertItem
       Insert an existing FhirConformanceMessagingEvent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceMessagingEvent);
    
    {@member Item
       Get the iIndexth FhirConformanceMessagingEvent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceMessagingEvent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceMessagingEvent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceMessagingEvent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceMessagingEvents[index : Integer] : TFhirConformanceMessagingEvent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirConformanceDocument : TFhirElement
    A document definition.
  }
  {!.Net HL7Connect.Fhir.ConformanceDocument}
  TFhirConformanceDocument = class (TFhirBackboneElement)
  private
    FMode : TFhirEnum;
    FDocumentation : TFhirString;
    FProfile : TFhirResourceReference{TFhirProfile};
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirDocumentMode;
    Procedure SetModeST(value : TFhirDocumentMode);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetProfile(value : TFhirResourceReference{TFhirProfile});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirConformanceDocument; overload;
    function Clone : TFhirConformanceDocument; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member mode
      Mode of this document declaration - whether application is producer or consumer.
    }
    property mode : TFhirDocumentMode read GetModeST write SetModeST;
    property modeObject : TFhirEnum read FMode write SetMode;

    {@member documentation
      A description of how the application supports or uses the specified document profile.  For example, when are documents created, what action is taken with consumed documents, etc.
    }
    {@member documentation
      Typed access to A description of how the application supports or uses the specified document profile.  For example, when are documents created, what action is taken with consumed documents, etc.
    }
    property documentation : String read GetDocumentationST write SetDocumentationST;
    property documentationObject : TFhirString read FDocumentation write SetDocumentation;

    {@member profile
      A constraint on a resource used in the document.
    }
    property profile : TFhirResourceReference{TFhirProfile} read FProfile write SetProfile;
    property profileObject : TFhirResourceReference{TFhirProfile} read FProfile write SetProfile;

  end;


  TFhirConformanceDocumentListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirConformanceDocumentList;
    function GetCurrent : TFhirConformanceDocument;
  public
    Constructor Create(list : TFhirConformanceDocumentList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceDocument read GetCurrent;
  end;


  {@Class TFhirConformanceDocumentList
    A list of FhirConformanceDocument
  }
  {!.Net HL7Connect.Fhir.ConformanceDocumentList}
  TFhirConformanceDocumentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConformanceDocument;
    procedure SetItemN(index : Integer; value : TFhirConformanceDocument);
  public
    {!script hide}
    function Link : TFhirConformanceDocumentList; Overload;
    function Clone : TFhirConformanceDocumentList; Overload;
    function GetEnumerator : TFhirConformanceDocumentListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirConformanceDocument to the end of the list.
    }
    function Append : TFhirConformanceDocument;

    
    {@member AddItem
      Add an already existing FhirConformanceDocument to the end of the list.
    }
    procedure AddItem(value : TFhirConformanceDocument); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirConformanceDocument) : Integer;
    

    {@member Insert
      Insert FhirConformanceDocument before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirConformanceDocument;
    

    {@member InsertItem
       Insert an existing FhirConformanceDocument before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirConformanceDocument);
    
    {@member Item
       Get the iIndexth FhirConformanceDocument. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirConformanceDocument. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceDocument);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirConformanceDocument;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirConformanceDocuments[index : Integer] : TFhirConformanceDocument read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDeviceObservationReportVirtualDevice : TFhirElement
    A medical-related subsystem of a medical device.
  }
  {!.Net HL7Connect.Fhir.DeviceObservationReportVirtualDevice}
  TFhirDeviceObservationReportVirtualDevice = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FchannelList : TFhirDeviceObservationReportVirtualDeviceChannelList;
    Procedure SetCode(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDeviceObservationReportVirtualDevice; overload;
    function Clone : TFhirDeviceObservationReportVirtualDevice; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      Describes the compartment.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;
    property codeObject : TFhirCodeableConcept read FCode write SetCode;

    {@member channelList
      Groups together physiological measurement data and derived data.
    }
    property channelList : TFhirDeviceObservationReportVirtualDeviceChannelList read FChannelList;

  end;


  TFhirDeviceObservationReportVirtualDeviceListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirDeviceObservationReportVirtualDeviceList;
    function GetCurrent : TFhirDeviceObservationReportVirtualDevice;
  public
    Constructor Create(list : TFhirDeviceObservationReportVirtualDeviceList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceObservationReportVirtualDevice read GetCurrent;
  end;


  {@Class TFhirDeviceObservationReportVirtualDeviceList
    A list of FhirDeviceObservationReportVirtualDevice
  }
  {!.Net HL7Connect.Fhir.DeviceObservationReportVirtualDeviceList}
  TFhirDeviceObservationReportVirtualDeviceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceObservationReportVirtualDevice;
    procedure SetItemN(index : Integer; value : TFhirDeviceObservationReportVirtualDevice);
  public
    {!script hide}
    function Link : TFhirDeviceObservationReportVirtualDeviceList; Overload;
    function Clone : TFhirDeviceObservationReportVirtualDeviceList; Overload;
    function GetEnumerator : TFhirDeviceObservationReportVirtualDeviceListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirDeviceObservationReportVirtualDevice to the end of the list.
    }
    function Append : TFhirDeviceObservationReportVirtualDevice;

    
    {@member AddItem
      Add an already existing FhirDeviceObservationReportVirtualDevice to the end of the list.
    }
    procedure AddItem(value : TFhirDeviceObservationReportVirtualDevice); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDeviceObservationReportVirtualDevice) : Integer;
    

    {@member Insert
      Insert FhirDeviceObservationReportVirtualDevice before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDeviceObservationReportVirtualDevice;
    

    {@member InsertItem
       Insert an existing FhirDeviceObservationReportVirtualDevice before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDeviceObservationReportVirtualDevice);
    
    {@member Item
       Get the iIndexth FhirDeviceObservationReportVirtualDevice. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDeviceObservationReportVirtualDevice. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceObservationReportVirtualDevice);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDeviceObservationReportVirtualDevice;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDeviceObservationReportVirtualDevices[index : Integer] : TFhirDeviceObservationReportVirtualDevice read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDeviceObservationReportVirtualDeviceChannel : TFhirElement
    Groups together physiological measurement data and derived data.
  }
  {!.Net HL7Connect.Fhir.DeviceObservationReportVirtualDeviceChannel}
  TFhirDeviceObservationReportVirtualDeviceChannel = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FmetricList : TFhirDeviceObservationReportVirtualDeviceChannelMetricList;
    Procedure SetCode(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDeviceObservationReportVirtualDeviceChannel; overload;
    function Clone : TFhirDeviceObservationReportVirtualDeviceChannel; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      Describes the channel.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;
    property codeObject : TFhirCodeableConcept read FCode write SetCode;

    {@member metricList
      A piece of measured or derived data that is reported by the machine.
    }
    property metricList : TFhirDeviceObservationReportVirtualDeviceChannelMetricList read FMetricList;

  end;


  TFhirDeviceObservationReportVirtualDeviceChannelListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirDeviceObservationReportVirtualDeviceChannelList;
    function GetCurrent : TFhirDeviceObservationReportVirtualDeviceChannel;
  public
    Constructor Create(list : TFhirDeviceObservationReportVirtualDeviceChannelList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceObservationReportVirtualDeviceChannel read GetCurrent;
  end;


  {@Class TFhirDeviceObservationReportVirtualDeviceChannelList
    A list of FhirDeviceObservationReportVirtualDeviceChannel
  }
  {!.Net HL7Connect.Fhir.DeviceObservationReportVirtualDeviceChannelList}
  TFhirDeviceObservationReportVirtualDeviceChannelList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceObservationReportVirtualDeviceChannel;
    procedure SetItemN(index : Integer; value : TFhirDeviceObservationReportVirtualDeviceChannel);
  public
    {!script hide}
    function Link : TFhirDeviceObservationReportVirtualDeviceChannelList; Overload;
    function Clone : TFhirDeviceObservationReportVirtualDeviceChannelList; Overload;
    function GetEnumerator : TFhirDeviceObservationReportVirtualDeviceChannelListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirDeviceObservationReportVirtualDeviceChannel to the end of the list.
    }
    function Append : TFhirDeviceObservationReportVirtualDeviceChannel;

    
    {@member AddItem
      Add an already existing FhirDeviceObservationReportVirtualDeviceChannel to the end of the list.
    }
    procedure AddItem(value : TFhirDeviceObservationReportVirtualDeviceChannel); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDeviceObservationReportVirtualDeviceChannel) : Integer;
    

    {@member Insert
      Insert FhirDeviceObservationReportVirtualDeviceChannel before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDeviceObservationReportVirtualDeviceChannel;
    

    {@member InsertItem
       Insert an existing FhirDeviceObservationReportVirtualDeviceChannel before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDeviceObservationReportVirtualDeviceChannel);
    
    {@member Item
       Get the iIndexth FhirDeviceObservationReportVirtualDeviceChannel. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDeviceObservationReportVirtualDeviceChannel. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceObservationReportVirtualDeviceChannel);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDeviceObservationReportVirtualDeviceChannel;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDeviceObservationReportVirtualDeviceChannels[index : Integer] : TFhirDeviceObservationReportVirtualDeviceChannel read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDeviceObservationReportVirtualDeviceChannelMetric : TFhirElement
    A piece of measured or derived data that is reported by the machine.
  }
  {!.Net HL7Connect.Fhir.DeviceObservationReportVirtualDeviceChannelMetric}
  TFhirDeviceObservationReportVirtualDeviceChannelMetric = class (TFhirBackboneElement)
  private
    FObservation : TFhirResourceReference{TFhirObservation};
    Procedure SetObservation(value : TFhirResourceReference{TFhirObservation});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDeviceObservationReportVirtualDeviceChannelMetric; overload;
    function Clone : TFhirDeviceObservationReportVirtualDeviceChannelMetric; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member observation
      The data for the metric.
    }
    property observation : TFhirResourceReference{TFhirObservation} read FObservation write SetObservation;
    property observationObject : TFhirResourceReference{TFhirObservation} read FObservation write SetObservation;

  end;


  TFhirDeviceObservationReportVirtualDeviceChannelMetricListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirDeviceObservationReportVirtualDeviceChannelMetricList;
    function GetCurrent : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
  public
    Constructor Create(list : TFhirDeviceObservationReportVirtualDeviceChannelMetricList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceObservationReportVirtualDeviceChannelMetric read GetCurrent;
  end;


  {@Class TFhirDeviceObservationReportVirtualDeviceChannelMetricList
    A list of FhirDeviceObservationReportVirtualDeviceChannelMetric
  }
  {!.Net HL7Connect.Fhir.DeviceObservationReportVirtualDeviceChannelMetricList}
  TFhirDeviceObservationReportVirtualDeviceChannelMetricList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
    procedure SetItemN(index : Integer; value : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
  public
    {!script hide}
    function Link : TFhirDeviceObservationReportVirtualDeviceChannelMetricList; Overload;
    function Clone : TFhirDeviceObservationReportVirtualDeviceChannelMetricList; Overload;
    function GetEnumerator : TFhirDeviceObservationReportVirtualDeviceChannelMetricListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirDeviceObservationReportVirtualDeviceChannelMetric to the end of the list.
    }
    function Append : TFhirDeviceObservationReportVirtualDeviceChannelMetric;

    
    {@member AddItem
      Add an already existing FhirDeviceObservationReportVirtualDeviceChannelMetric to the end of the list.
    }
    procedure AddItem(value : TFhirDeviceObservationReportVirtualDeviceChannelMetric); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDeviceObservationReportVirtualDeviceChannelMetric) : Integer;
    

    {@member Insert
      Insert FhirDeviceObservationReportVirtualDeviceChannelMetric before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
    

    {@member InsertItem
       Insert an existing FhirDeviceObservationReportVirtualDeviceChannelMetric before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
    
    {@member Item
       Get the iIndexth FhirDeviceObservationReportVirtualDeviceChannelMetric. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDeviceObservationReportVirtualDeviceChannelMetric. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceObservationReportVirtualDeviceChannelMetric);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDeviceObservationReportVirtualDeviceChannelMetrics[index : Integer] : TFhirDeviceObservationReportVirtualDeviceChannelMetric read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDiagnosticOrderEvent : TFhirElement
    A summary of the events of interest that have occurred as the request is processed. E.g. when the order was made, various processing steps (specimens received), when it was completed.
  }
  {!.Net HL7Connect.Fhir.DiagnosticOrderEvent}
  TFhirDiagnosticOrderEvent = class (TFhirBackboneElement)
  private
    FStatus : TFhirEnum;
    FDescription : TFhirCodeableConcept;
    FDateTime : TFhirDateTime;
    FActor : TFhirResourceReference{Resource};
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDiagnosticOrderStatus;
    Procedure SetStatusST(value : TFhirDiagnosticOrderStatus);
    Procedure SetDescription(value : TFhirCodeableConcept);
    Procedure SetDateTime(value : TFhirDateTime);
    Function GetDateTimeST : TDateTimeEx;
    Procedure SetDateTimeST(value : TDateTimeEx);
    Procedure SetActor(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDiagnosticOrderEvent; overload;
    function Clone : TFhirDiagnosticOrderEvent; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member status
      The status for the event.
    }
    property status : TFhirDiagnosticOrderStatus read GetStatusST write SetStatusST;
    property statusObject : TFhirEnum read FStatus write SetStatus;

    {@member description
      Additional information about the event that occurred - e.g. if the status remained unchanged.
    }
    property description : TFhirCodeableConcept read FDescription write SetDescription;
    property descriptionObject : TFhirCodeableConcept read FDescription write SetDescription;

    {@member dateTime
      The date/time at which the event occurred.
    }
    {@member dateTime
      Typed access to The date/time at which the event occurred.
    }
    property dateTime : TDateTimeEx read GetDateTimeST write SetDateTimeST;
    property dateTimeObject : TFhirDateTime read FDateTime write SetDateTime;

    {@member actor
      The person who was responsible for performing or recording the action.
    }
    property actor : TFhirResourceReference{Resource} read FActor write SetActor;
    property actorObject : TFhirResourceReference{Resource} read FActor write SetActor;

  end;


  TFhirDiagnosticOrderEventListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticOrderEventList;
    function GetCurrent : TFhirDiagnosticOrderEvent;
  public
    Constructor Create(list : TFhirDiagnosticOrderEventList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticOrderEvent read GetCurrent;
  end;


  {@Class TFhirDiagnosticOrderEventList
    A list of FhirDiagnosticOrderEvent
  }
  {!.Net HL7Connect.Fhir.DiagnosticOrderEventList}
  TFhirDiagnosticOrderEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDiagnosticOrderEvent;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticOrderEvent);
  public
    {!script hide}
    function Link : TFhirDiagnosticOrderEventList; Overload;
    function Clone : TFhirDiagnosticOrderEventList; Overload;
    function GetEnumerator : TFhirDiagnosticOrderEventListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirDiagnosticOrderEvent to the end of the list.
    }
    function Append : TFhirDiagnosticOrderEvent;

    
    {@member AddItem
      Add an already existing FhirDiagnosticOrderEvent to the end of the list.
    }
    procedure AddItem(value : TFhirDiagnosticOrderEvent); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDiagnosticOrderEvent) : Integer;
    

    {@member Insert
      Insert FhirDiagnosticOrderEvent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDiagnosticOrderEvent;
    

    {@member InsertItem
       Insert an existing FhirDiagnosticOrderEvent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDiagnosticOrderEvent);
    
    {@member Item
       Get the iIndexth FhirDiagnosticOrderEvent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDiagnosticOrderEvent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticOrderEvent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDiagnosticOrderEvent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDiagnosticOrderEvents[index : Integer] : TFhirDiagnosticOrderEvent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDiagnosticOrderItem : TFhirElement
    The specific diagnostic investigations that are requested as part of this request. Sometimes, there can only be one item per request, but in most contexts, more than one investigation can be requested.
  }
  {!.Net HL7Connect.Fhir.DiagnosticOrderItem}
  TFhirDiagnosticOrderItem = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FspecimenList : TFhirResourceReferenceList{TFhirSpecimen};
    FBodySite : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FeventList : TFhirDiagnosticOrderEventList;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetBodySite(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDiagnosticOrderStatus;
    Procedure SetStatusST(value : TFhirDiagnosticOrderStatus);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDiagnosticOrderItem; overload;
    function Clone : TFhirDiagnosticOrderItem; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      A code that identifies a particular diagnostic investigation, or panel of investigations, that have been requested.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;
    property codeObject : TFhirCodeableConcept read FCode write SetCode;

    {@member specimenList
      If the item is related to a specific speciment.
    }
    property specimenList : TFhirResourceReferenceList{TFhirSpecimen} read FSpecimenList;

    {@member bodySite
      Anatomical location where the request test should be performed.
    }
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    property bodySiteObject : TFhirCodeableConcept read FBodySite write SetBodySite;

    {@member status
      The status of this individual item within the order.
    }
    property status : TFhirDiagnosticOrderStatus read GetStatusST write SetStatusST;
    property statusObject : TFhirEnum read FStatus write SetStatus;

    {@member eventList
      A summary of the events of interest that have occurred as this item of the request is processed.
    }
    property eventList : TFhirDiagnosticOrderEventList read FEventList;

  end;


  TFhirDiagnosticOrderItemListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticOrderItemList;
    function GetCurrent : TFhirDiagnosticOrderItem;
  public
    Constructor Create(list : TFhirDiagnosticOrderItemList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticOrderItem read GetCurrent;
  end;


  {@Class TFhirDiagnosticOrderItemList
    A list of FhirDiagnosticOrderItem
  }
  {!.Net HL7Connect.Fhir.DiagnosticOrderItemList}
  TFhirDiagnosticOrderItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDiagnosticOrderItem;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticOrderItem);
  public
    {!script hide}
    function Link : TFhirDiagnosticOrderItemList; Overload;
    function Clone : TFhirDiagnosticOrderItemList; Overload;
    function GetEnumerator : TFhirDiagnosticOrderItemListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirDiagnosticOrderItem to the end of the list.
    }
    function Append : TFhirDiagnosticOrderItem;

    
    {@member AddItem
      Add an already existing FhirDiagnosticOrderItem to the end of the list.
    }
    procedure AddItem(value : TFhirDiagnosticOrderItem); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDiagnosticOrderItem) : Integer;
    

    {@member Insert
      Insert FhirDiagnosticOrderItem before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDiagnosticOrderItem;
    

    {@member InsertItem
       Insert an existing FhirDiagnosticOrderItem before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDiagnosticOrderItem);
    
    {@member Item
       Get the iIndexth FhirDiagnosticOrderItem. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDiagnosticOrderItem. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticOrderItem);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDiagnosticOrderItem;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDiagnosticOrderItems[index : Integer] : TFhirDiagnosticOrderItem read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDiagnosticReportImage : TFhirElement
    A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
  }
  {!.Net HL7Connect.Fhir.DiagnosticReportImage}
  TFhirDiagnosticReportImage = class (TFhirBackboneElement)
  private
    FComment : TFhirString;
    FLink_ : TFhirResourceReference{TFhirMedia};
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    Procedure SetLink_(value : TFhirResourceReference{TFhirMedia});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDiagnosticReportImage; overload;
    function Clone : TFhirDiagnosticReportImage; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member comment
      A comment about the image. Typically, this is used to provide an explanation for why the image is included, or to draw the viewer's attention to important features.
    }
    {@member comment
      Typed access to A comment about the image. Typically, this is used to provide an explanation for why the image is included, or to draw the viewer's attention to important features.
    }
    property comment : String read GetCommentST write SetCommentST;
    property commentObject : TFhirString read FComment write SetComment;

    {@member link_
      Reference to the image source.
    }
    property link_ : TFhirResourceReference{TFhirMedia} read FLink_ write SetLink_;
    property link_Object : TFhirResourceReference{TFhirMedia} read FLink_ write SetLink_;

  end;


  TFhirDiagnosticReportImageListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticReportImageList;
    function GetCurrent : TFhirDiagnosticReportImage;
  public
    Constructor Create(list : TFhirDiagnosticReportImageList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticReportImage read GetCurrent;
  end;


  {@Class TFhirDiagnosticReportImageList
    A list of FhirDiagnosticReportImage
  }
  {!.Net HL7Connect.Fhir.DiagnosticReportImageList}
  TFhirDiagnosticReportImageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDiagnosticReportImage;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticReportImage);
  public
    {!script hide}
    function Link : TFhirDiagnosticReportImageList; Overload;
    function Clone : TFhirDiagnosticReportImageList; Overload;
    function GetEnumerator : TFhirDiagnosticReportImageListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirDiagnosticReportImage to the end of the list.
    }
    function Append : TFhirDiagnosticReportImage;

    
    {@member AddItem
      Add an already existing FhirDiagnosticReportImage to the end of the list.
    }
    procedure AddItem(value : TFhirDiagnosticReportImage); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDiagnosticReportImage) : Integer;
    

    {@member Insert
      Insert FhirDiagnosticReportImage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDiagnosticReportImage;
    

    {@member InsertItem
       Insert an existing FhirDiagnosticReportImage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDiagnosticReportImage);
    
    {@member Item
       Get the iIndexth FhirDiagnosticReportImage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDiagnosticReportImage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticReportImage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDiagnosticReportImage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDiagnosticReportImages[index : Integer] : TFhirDiagnosticReportImage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDocumentReferenceRelatesTo : TFhirElement
    Relationships that this document has with other document references that already exist.
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceRelatesTo}
  TFhirDocumentReferenceRelatesTo = class (TFhirBackboneElement)
  private
    FCode : TFhirEnum;
    FTarget : TFhirResourceReference{TFhirDocumentReference};
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirDocumentRelationshipType;
    Procedure SetCodeST(value : TFhirDocumentRelationshipType);
    Procedure SetTarget(value : TFhirResourceReference{TFhirDocumentReference});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDocumentReferenceRelatesTo; overload;
    function Clone : TFhirDocumentReferenceRelatesTo; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      The type of relationship that this document has with anther document.
    }
    property code : TFhirDocumentRelationshipType read GetCodeST write SetCodeST;
    property codeObject : TFhirEnum read FCode write SetCode;

    {@member target
      The target document of this relationship.
    }
    property target : TFhirResourceReference{TFhirDocumentReference} read FTarget write SetTarget;
    property targetObject : TFhirResourceReference{TFhirDocumentReference} read FTarget write SetTarget;

  end;


  TFhirDocumentReferenceRelatesToListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceRelatesToList;
    function GetCurrent : TFhirDocumentReferenceRelatesTo;
  public
    Constructor Create(list : TFhirDocumentReferenceRelatesToList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceRelatesTo read GetCurrent;
  end;


  {@Class TFhirDocumentReferenceRelatesToList
    A list of FhirDocumentReferenceRelatesTo
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceRelatesToList}
  TFhirDocumentReferenceRelatesToList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceRelatesTo;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceRelatesTo);
  public
    {!script hide}
    function Link : TFhirDocumentReferenceRelatesToList; Overload;
    function Clone : TFhirDocumentReferenceRelatesToList; Overload;
    function GetEnumerator : TFhirDocumentReferenceRelatesToListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirDocumentReferenceRelatesTo to the end of the list.
    }
    function Append : TFhirDocumentReferenceRelatesTo;

    
    {@member AddItem
      Add an already existing FhirDocumentReferenceRelatesTo to the end of the list.
    }
    procedure AddItem(value : TFhirDocumentReferenceRelatesTo); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDocumentReferenceRelatesTo) : Integer;
    

    {@member Insert
      Insert FhirDocumentReferenceRelatesTo before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDocumentReferenceRelatesTo;
    

    {@member InsertItem
       Insert an existing FhirDocumentReferenceRelatesTo before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceRelatesTo);
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceRelatesTo. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceRelatesTo. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceRelatesTo);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDocumentReferenceRelatesTo;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDocumentReferenceRelatesTos[index : Integer] : TFhirDocumentReferenceRelatesTo read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDocumentReferenceService : TFhirElement
    A description of a service call that can be used to retrieve the document.
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceService}
  TFhirDocumentReferenceService = class (TFhirBackboneElement)
  private
    FType_ : TFhirCodeableConcept;
    FAddress : TFhirString;
    FparameterList : TFhirDocumentReferenceServiceParameterList;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAddress(value : TFhirString);
    Function GetAddressST : String;
    Procedure SetAddressST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDocumentReferenceService; overload;
    function Clone : TFhirDocumentReferenceService; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member type_
      The type of the service that can be used to access the documents.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    property type_Object : TFhirCodeableConcept read FType_ write SetType_;

    {@member address
      Where the service end-point is located.
    }
    {@member address
      Typed access to Where the service end-point is located.
    }
    property address : String read GetAddressST write SetAddressST;
    property addressObject : TFhirString read FAddress write SetAddress;

    {@member parameterList
      A list of named parameters that is used in the service call.
    }
    property parameterList : TFhirDocumentReferenceServiceParameterList read FParameterList;

  end;


  TFhirDocumentReferenceServiceListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceServiceList;
    function GetCurrent : TFhirDocumentReferenceService;
  public
    Constructor Create(list : TFhirDocumentReferenceServiceList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceService read GetCurrent;
  end;


  {@Class TFhirDocumentReferenceServiceList
    A list of FhirDocumentReferenceService
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceServiceList}
  TFhirDocumentReferenceServiceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceService;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceService);
  public
    {!script hide}
    function Link : TFhirDocumentReferenceServiceList; Overload;
    function Clone : TFhirDocumentReferenceServiceList; Overload;
    function GetEnumerator : TFhirDocumentReferenceServiceListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirDocumentReferenceService to the end of the list.
    }
    function Append : TFhirDocumentReferenceService;

    
    {@member AddItem
      Add an already existing FhirDocumentReferenceService to the end of the list.
    }
    procedure AddItem(value : TFhirDocumentReferenceService); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDocumentReferenceService) : Integer;
    

    {@member Insert
      Insert FhirDocumentReferenceService before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDocumentReferenceService;
    

    {@member InsertItem
       Insert an existing FhirDocumentReferenceService before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceService);
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceService. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceService. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceService);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDocumentReferenceService;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDocumentReferenceServices[index : Integer] : TFhirDocumentReferenceService read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDocumentReferenceServiceParameter : TFhirElement
    A list of named parameters that is used in the service call.
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceServiceParameter}
  TFhirDocumentReferenceServiceParameter = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FValue : TFhirString;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDocumentReferenceServiceParameter; overload;
    function Clone : TFhirDocumentReferenceServiceParameter; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member name
      The name of a parameter.
    }
    {@member name
      Typed access to The name of a parameter.
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member value
      The value of the named parameter.
    }
    {@member value
      Typed access to The value of the named parameter.
    }
    property value : String read GetValueST write SetValueST;
    property valueObject : TFhirString read FValue write SetValue;

  end;


  TFhirDocumentReferenceServiceParameterListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceServiceParameterList;
    function GetCurrent : TFhirDocumentReferenceServiceParameter;
  public
    Constructor Create(list : TFhirDocumentReferenceServiceParameterList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceServiceParameter read GetCurrent;
  end;


  {@Class TFhirDocumentReferenceServiceParameterList
    A list of FhirDocumentReferenceServiceParameter
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceServiceParameterList}
  TFhirDocumentReferenceServiceParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceServiceParameter;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceServiceParameter);
  public
    {!script hide}
    function Link : TFhirDocumentReferenceServiceParameterList; Overload;
    function Clone : TFhirDocumentReferenceServiceParameterList; Overload;
    function GetEnumerator : TFhirDocumentReferenceServiceParameterListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirDocumentReferenceServiceParameter to the end of the list.
    }
    function Append : TFhirDocumentReferenceServiceParameter;

    
    {@member AddItem
      Add an already existing FhirDocumentReferenceServiceParameter to the end of the list.
    }
    procedure AddItem(value : TFhirDocumentReferenceServiceParameter); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDocumentReferenceServiceParameter) : Integer;
    

    {@member Insert
      Insert FhirDocumentReferenceServiceParameter before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDocumentReferenceServiceParameter;
    

    {@member InsertItem
       Insert an existing FhirDocumentReferenceServiceParameter before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceServiceParameter);
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceServiceParameter. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceServiceParameter. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceServiceParameter);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDocumentReferenceServiceParameter;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDocumentReferenceServiceParameters[index : Integer] : TFhirDocumentReferenceServiceParameter read GetItemN write SetItemN; default;
  End;


  {@Class TFhirDocumentReferenceContext : TFhirElement
    The clinical context in which the document was prepared.
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceContext}
  TFhirDocumentReferenceContext = class (TFhirBackboneElement)
  private
    FeventList : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FFacilityType : TFhirCodeableConcept;
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetFacilityType(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirDocumentReferenceContext; overload;
    function Clone : TFhirDocumentReferenceContext; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member eventList
      This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    }
    property eventList : TFhirCodeableConceptList read FEventList;

    {@member period
      The time period over which the service that is described by the document was provided.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;
    property periodObject : TFhirPeriod read FPeriod write SetPeriod;

    {@member facilityType
      The kind of facility where the patient was seen.
    }
    property facilityType : TFhirCodeableConcept read FFacilityType write SetFacilityType;
    property facilityTypeObject : TFhirCodeableConcept read FFacilityType write SetFacilityType;

  end;


  TFhirDocumentReferenceContextListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceContextList;
    function GetCurrent : TFhirDocumentReferenceContext;
  public
    Constructor Create(list : TFhirDocumentReferenceContextList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceContext read GetCurrent;
  end;


  {@Class TFhirDocumentReferenceContextList
    A list of FhirDocumentReferenceContext
  }
  {!.Net HL7Connect.Fhir.DocumentReferenceContextList}
  TFhirDocumentReferenceContextList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceContext;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceContext);
  public
    {!script hide}
    function Link : TFhirDocumentReferenceContextList; Overload;
    function Clone : TFhirDocumentReferenceContextList; Overload;
    function GetEnumerator : TFhirDocumentReferenceContextListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirDocumentReferenceContext to the end of the list.
    }
    function Append : TFhirDocumentReferenceContext;

    
    {@member AddItem
      Add an already existing FhirDocumentReferenceContext to the end of the list.
    }
    procedure AddItem(value : TFhirDocumentReferenceContext); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirDocumentReferenceContext) : Integer;
    

    {@member Insert
      Insert FhirDocumentReferenceContext before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirDocumentReferenceContext;
    

    {@member InsertItem
       Insert an existing FhirDocumentReferenceContext before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceContext);
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceContext. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirDocumentReferenceContext. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceContext);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirDocumentReferenceContext;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirDocumentReferenceContexts[index : Integer] : TFhirDocumentReferenceContext read GetItemN write SetItemN; default;
  End;


  {@Class TFhirEncounterParticipant : TFhirElement
    The main practitioner responsible for providing the service.
  }
  {!.Net HL7Connect.Fhir.EncounterParticipant}
  TFhirEncounterParticipant = class (TFhirBackboneElement)
  private
    Ftype_List : TFhirCodeableConceptList;
    FIndividual : TFhirResourceReference{Resource};
    Procedure SetIndividual(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirEncounterParticipant; overload;
    function Clone : TFhirEncounterParticipant; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member type_List
      Role of participant in encounter.
    }
    property type_List : TFhirCodeableConceptList read FType_List;

    {@member individual
      Persons involved in the encounter other than the patient.
    }
    property individual : TFhirResourceReference{Resource} read FIndividual write SetIndividual;
    property individualObject : TFhirResourceReference{Resource} read FIndividual write SetIndividual;

  end;


  TFhirEncounterParticipantListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirEncounterParticipantList;
    function GetCurrent : TFhirEncounterParticipant;
  public
    Constructor Create(list : TFhirEncounterParticipantList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterParticipant read GetCurrent;
  end;


  {@Class TFhirEncounterParticipantList
    A list of FhirEncounterParticipant
  }
  {!.Net HL7Connect.Fhir.EncounterParticipantList}
  TFhirEncounterParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterParticipant;
    procedure SetItemN(index : Integer; value : TFhirEncounterParticipant);
  public
    {!script hide}
    function Link : TFhirEncounterParticipantList; Overload;
    function Clone : TFhirEncounterParticipantList; Overload;
    function GetEnumerator : TFhirEncounterParticipantListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirEncounterParticipant to the end of the list.
    }
    function Append : TFhirEncounterParticipant;

    
    {@member AddItem
      Add an already existing FhirEncounterParticipant to the end of the list.
    }
    procedure AddItem(value : TFhirEncounterParticipant); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirEncounterParticipant) : Integer;
    

    {@member Insert
      Insert FhirEncounterParticipant before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirEncounterParticipant;
    

    {@member InsertItem
       Insert an existing FhirEncounterParticipant before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirEncounterParticipant);
    
    {@member Item
       Get the iIndexth FhirEncounterParticipant. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirEncounterParticipant. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterParticipant);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirEncounterParticipant;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirEncounterParticipants[index : Integer] : TFhirEncounterParticipant read GetItemN write SetItemN; default;
  End;


  {@Class TFhirEncounterHospitalization : TFhirElement
    Details about an admission to a clinic.
  }
  {!.Net HL7Connect.Fhir.EncounterHospitalization}
  TFhirEncounterHospitalization = class (TFhirBackboneElement)
  private
    FPreAdmissionIdentifier : TFhirIdentifier;
    FOrigin : TFhirResourceReference{TFhirLocation};
    FAdmitSource : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FaccomodationList : TFhirEncounterHospitalizationAccomodationList;
    FDiet : TFhirCodeableConcept;
    FspecialCourtesyList : TFhirCodeableConceptList;
    FspecialArrangementList : TFhirCodeableConceptList;
    FDestination : TFhirResourceReference{TFhirLocation};
    FDischargeDisposition : TFhirCodeableConcept;
    FDischargeDiagnosis : TFhirResourceReference{Resource};
    FReAdmission : TFhirBoolean;
    Procedure SetPreAdmissionIdentifier(value : TFhirIdentifier);
    Procedure SetOrigin(value : TFhirResourceReference{TFhirLocation});
    Procedure SetAdmitSource(value : TFhirCodeableConcept);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetDiet(value : TFhirCodeableConcept);
    Procedure SetDestination(value : TFhirResourceReference{TFhirLocation});
    Procedure SetDischargeDisposition(value : TFhirCodeableConcept);
    Procedure SetDischargeDiagnosis(value : TFhirResourceReference{Resource});
    Procedure SetReAdmission(value : TFhirBoolean);
    Function GetReAdmissionST : Boolean;
    Procedure SetReAdmissionST(value : Boolean);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirEncounterHospitalization; overload;
    function Clone : TFhirEncounterHospitalization; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member preAdmissionIdentifier
      Pre-admission identifier.
    }
    property preAdmissionIdentifier : TFhirIdentifier read FPreAdmissionIdentifier write SetPreAdmissionIdentifier;
    property preAdmissionIdentifierObject : TFhirIdentifier read FPreAdmissionIdentifier write SetPreAdmissionIdentifier;

    {@member origin
      The location from which the patient came before admission.
    }
    property origin : TFhirResourceReference{TFhirLocation} read FOrigin write SetOrigin;
    property originObject : TFhirResourceReference{TFhirLocation} read FOrigin write SetOrigin;

    {@member admitSource
      From where patient was admitted (physician referral, transfer).
    }
    property admitSource : TFhirCodeableConcept read FAdmitSource write SetAdmitSource;
    property admitSourceObject : TFhirCodeableConcept read FAdmitSource write SetAdmitSource;

    {@member period
      Period during which the patient was admitted.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;
    property periodObject : TFhirPeriod read FPeriod write SetPeriod;

    {@member accomodationList
      Where the patient stays during this encounter.
    }
    property accomodationList : TFhirEncounterHospitalizationAccomodationList read FAccomodationList;

    {@member diet
      Dietary restrictions for the patient.
    }
    property diet : TFhirCodeableConcept read FDiet write SetDiet;
    property dietObject : TFhirCodeableConcept read FDiet write SetDiet;

    {@member specialCourtesyList
      Special courtesies (VIP, board member).
    }
    property specialCourtesyList : TFhirCodeableConceptList read FSpecialCourtesyList;

    {@member specialArrangementList
      Wheelchair, translator, stretcher, etc.
    }
    property specialArrangementList : TFhirCodeableConceptList read FSpecialArrangementList;

    {@member destination
      Location to which the patient is discharged.
    }
    property destination : TFhirResourceReference{TFhirLocation} read FDestination write SetDestination;
    property destinationObject : TFhirResourceReference{TFhirLocation} read FDestination write SetDestination;

    {@member dischargeDisposition
      Category or kind of location after discharge.
    }
    property dischargeDisposition : TFhirCodeableConcept read FDischargeDisposition write SetDischargeDisposition;
    property dischargeDispositionObject : TFhirCodeableConcept read FDischargeDisposition write SetDischargeDisposition;

    {@member dischargeDiagnosis
      The final diagnosis given a patient before release from the hospital after all testing, surgery, and workup are complete.
    }
    property dischargeDiagnosis : TFhirResourceReference{Resource} read FDischargeDiagnosis write SetDischargeDiagnosis;
    property dischargeDiagnosisObject : TFhirResourceReference{Resource} read FDischargeDiagnosis write SetDischargeDiagnosis;

    {@member reAdmission
      Whether this hospitalization is a readmission.
    }
    {@member reAdmission
      Typed access to Whether this hospitalization is a readmission.
    }
    property reAdmission : Boolean read GetReAdmissionST write SetReAdmissionST;
    property reAdmissionObject : TFhirBoolean read FReAdmission write SetReAdmission;

  end;


  TFhirEncounterHospitalizationListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirEncounterHospitalizationList;
    function GetCurrent : TFhirEncounterHospitalization;
  public
    Constructor Create(list : TFhirEncounterHospitalizationList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterHospitalization read GetCurrent;
  end;


  {@Class TFhirEncounterHospitalizationList
    A list of FhirEncounterHospitalization
  }
  {!.Net HL7Connect.Fhir.EncounterHospitalizationList}
  TFhirEncounterHospitalizationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterHospitalization;
    procedure SetItemN(index : Integer; value : TFhirEncounterHospitalization);
  public
    {!script hide}
    function Link : TFhirEncounterHospitalizationList; Overload;
    function Clone : TFhirEncounterHospitalizationList; Overload;
    function GetEnumerator : TFhirEncounterHospitalizationListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirEncounterHospitalization to the end of the list.
    }
    function Append : TFhirEncounterHospitalization;

    
    {@member AddItem
      Add an already existing FhirEncounterHospitalization to the end of the list.
    }
    procedure AddItem(value : TFhirEncounterHospitalization); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirEncounterHospitalization) : Integer;
    

    {@member Insert
      Insert FhirEncounterHospitalization before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirEncounterHospitalization;
    

    {@member InsertItem
       Insert an existing FhirEncounterHospitalization before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirEncounterHospitalization);
    
    {@member Item
       Get the iIndexth FhirEncounterHospitalization. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirEncounterHospitalization. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterHospitalization);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirEncounterHospitalization;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirEncounterHospitalizations[index : Integer] : TFhirEncounterHospitalization read GetItemN write SetItemN; default;
  End;


  {@Class TFhirEncounterHospitalizationAccomodation : TFhirElement
    Where the patient stays during this encounter.
  }
  {!.Net HL7Connect.Fhir.EncounterHospitalizationAccomodation}
  TFhirEncounterHospitalizationAccomodation = class (TFhirBackboneElement)
  private
    FBed : TFhirResourceReference{TFhirLocation};
    FPeriod : TFhirPeriod;
    Procedure SetBed(value : TFhirResourceReference{TFhirLocation});
    Procedure SetPeriod(value : TFhirPeriod);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirEncounterHospitalizationAccomodation; overload;
    function Clone : TFhirEncounterHospitalizationAccomodation; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member bed
      The bed that is assigned to the patient.
    }
    property bed : TFhirResourceReference{TFhirLocation} read FBed write SetBed;
    property bedObject : TFhirResourceReference{TFhirLocation} read FBed write SetBed;

    {@member period
      Period during which the patient was assigned the bed.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;
    property periodObject : TFhirPeriod read FPeriod write SetPeriod;

  end;


  TFhirEncounterHospitalizationAccomodationListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirEncounterHospitalizationAccomodationList;
    function GetCurrent : TFhirEncounterHospitalizationAccomodation;
  public
    Constructor Create(list : TFhirEncounterHospitalizationAccomodationList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterHospitalizationAccomodation read GetCurrent;
  end;


  {@Class TFhirEncounterHospitalizationAccomodationList
    A list of FhirEncounterHospitalizationAccomodation
  }
  {!.Net HL7Connect.Fhir.EncounterHospitalizationAccomodationList}
  TFhirEncounterHospitalizationAccomodationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterHospitalizationAccomodation;
    procedure SetItemN(index : Integer; value : TFhirEncounterHospitalizationAccomodation);
  public
    {!script hide}
    function Link : TFhirEncounterHospitalizationAccomodationList; Overload;
    function Clone : TFhirEncounterHospitalizationAccomodationList; Overload;
    function GetEnumerator : TFhirEncounterHospitalizationAccomodationListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirEncounterHospitalizationAccomodation to the end of the list.
    }
    function Append : TFhirEncounterHospitalizationAccomodation;

    
    {@member AddItem
      Add an already existing FhirEncounterHospitalizationAccomodation to the end of the list.
    }
    procedure AddItem(value : TFhirEncounterHospitalizationAccomodation); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirEncounterHospitalizationAccomodation) : Integer;
    

    {@member Insert
      Insert FhirEncounterHospitalizationAccomodation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirEncounterHospitalizationAccomodation;
    

    {@member InsertItem
       Insert an existing FhirEncounterHospitalizationAccomodation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirEncounterHospitalizationAccomodation);
    
    {@member Item
       Get the iIndexth FhirEncounterHospitalizationAccomodation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirEncounterHospitalizationAccomodation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterHospitalizationAccomodation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirEncounterHospitalizationAccomodation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirEncounterHospitalizationAccomodations[index : Integer] : TFhirEncounterHospitalizationAccomodation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirEncounterLocation : TFhirElement
    List of locations at which the patient has been.
  }
  {!.Net HL7Connect.Fhir.EncounterLocation}
  TFhirEncounterLocation = class (TFhirBackboneElement)
  private
    FLocation : TFhirResourceReference{TFhirLocation};
    FPeriod : TFhirPeriod;
    Procedure SetLocation(value : TFhirResourceReference{TFhirLocation});
    Procedure SetPeriod(value : TFhirPeriod);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirEncounterLocation; overload;
    function Clone : TFhirEncounterLocation; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member location
      The location where the encounter takes place.
    }
    property location : TFhirResourceReference{TFhirLocation} read FLocation write SetLocation;
    property locationObject : TFhirResourceReference{TFhirLocation} read FLocation write SetLocation;

    {@member period
      Time period during which the patient was present at the location.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;
    property periodObject : TFhirPeriod read FPeriod write SetPeriod;

  end;


  TFhirEncounterLocationListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirEncounterLocationList;
    function GetCurrent : TFhirEncounterLocation;
  public
    Constructor Create(list : TFhirEncounterLocationList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterLocation read GetCurrent;
  end;


  {@Class TFhirEncounterLocationList
    A list of FhirEncounterLocation
  }
  {!.Net HL7Connect.Fhir.EncounterLocationList}
  TFhirEncounterLocationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterLocation;
    procedure SetItemN(index : Integer; value : TFhirEncounterLocation);
  public
    {!script hide}
    function Link : TFhirEncounterLocationList; Overload;
    function Clone : TFhirEncounterLocationList; Overload;
    function GetEnumerator : TFhirEncounterLocationListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirEncounterLocation to the end of the list.
    }
    function Append : TFhirEncounterLocation;

    
    {@member AddItem
      Add an already existing FhirEncounterLocation to the end of the list.
    }
    procedure AddItem(value : TFhirEncounterLocation); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirEncounterLocation) : Integer;
    

    {@member Insert
      Insert FhirEncounterLocation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirEncounterLocation;
    

    {@member InsertItem
       Insert an existing FhirEncounterLocation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirEncounterLocation);
    
    {@member Item
       Get the iIndexth FhirEncounterLocation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirEncounterLocation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterLocation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirEncounterLocation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirEncounterLocations[index : Integer] : TFhirEncounterLocation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirFamilyHistoryRelation : TFhirElement
    The related person. Each FamilyHistory resource contains the entire family history for a single person.
  }
  {!.Net HL7Connect.Fhir.FamilyHistoryRelation}
  TFhirFamilyHistoryRelation = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FRelationship : TFhirCodeableConcept;
    FBorn : TFhirType;
    FDeceased : TFhirType;
    FNote : TFhirString;
    FconditionList : TFhirFamilyHistoryRelationConditionList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetRelationship(value : TFhirCodeableConcept);
    Procedure SetBorn(value : TFhirType);
    Procedure SetDeceased(value : TFhirType);
    Procedure SetNote(value : TFhirString);
    Function GetNoteST : String;
    Procedure SetNoteST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirFamilyHistoryRelation; overload;
    function Clone : TFhirFamilyHistoryRelation; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member name
      This will either be a name or a description.  E.g. "Aunt Susan", "my cousin with the red hair".
    }
    {@member name
      Typed access to This will either be a name or a description.  E.g. "Aunt Susan", "my cousin with the red hair".
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member relationship
      The type of relationship this person has to the patient (father, mother, brother etc.).
    }
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    property relationshipObject : TFhirCodeableConcept read FRelationship write SetRelationship;

    {@member born
      The actual or approximate date of birth of the relative.
    }
    property born : TFhirType read FBorn write SetBorn;
    property bornObject : TFhirType read FBorn write SetBorn;

    {@member deceased
      If this resource is indicating that the related person is deceased, then an indicator of whether the person is deceased (yes) or not (no) or the age or age range or description of age at death - can be indicated here. If the reason for death is known, then it can be indicated in the outcome code of the condition - in this case the deceased property should still be set.
    }
    property deceased : TFhirType read FDeceased write SetDeceased;
    property deceasedObject : TFhirType read FDeceased write SetDeceased;

    {@member note
      This property allows a non condition-specific note to the made about the related person. Ideally, the note would be in the condition property, but this is not always possible.
    }
    {@member note
      Typed access to This property allows a non condition-specific note to the made about the related person. Ideally, the note would be in the condition property, but this is not always possible.
    }
    property note : String read GetNoteST write SetNoteST;
    property noteObject : TFhirString read FNote write SetNote;

    {@member conditionList
      The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
    }
    property conditionList : TFhirFamilyHistoryRelationConditionList read FConditionList;

  end;


  TFhirFamilyHistoryRelationListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirFamilyHistoryRelationList;
    function GetCurrent : TFhirFamilyHistoryRelation;
  public
    Constructor Create(list : TFhirFamilyHistoryRelationList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFamilyHistoryRelation read GetCurrent;
  end;


  {@Class TFhirFamilyHistoryRelationList
    A list of FhirFamilyHistoryRelation
  }
  {!.Net HL7Connect.Fhir.FamilyHistoryRelationList}
  TFhirFamilyHistoryRelationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirFamilyHistoryRelation;
    procedure SetItemN(index : Integer; value : TFhirFamilyHistoryRelation);
  public
    {!script hide}
    function Link : TFhirFamilyHistoryRelationList; Overload;
    function Clone : TFhirFamilyHistoryRelationList; Overload;
    function GetEnumerator : TFhirFamilyHistoryRelationListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirFamilyHistoryRelation to the end of the list.
    }
    function Append : TFhirFamilyHistoryRelation;

    
    {@member AddItem
      Add an already existing FhirFamilyHistoryRelation to the end of the list.
    }
    procedure AddItem(value : TFhirFamilyHistoryRelation); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirFamilyHistoryRelation) : Integer;
    

    {@member Insert
      Insert FhirFamilyHistoryRelation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirFamilyHistoryRelation;
    

    {@member InsertItem
       Insert an existing FhirFamilyHistoryRelation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirFamilyHistoryRelation);
    
    {@member Item
       Get the iIndexth FhirFamilyHistoryRelation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirFamilyHistoryRelation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyHistoryRelation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirFamilyHistoryRelation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirFamilyHistoryRelations[index : Integer] : TFhirFamilyHistoryRelation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirFamilyHistoryRelationCondition : TFhirElement
    The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
  }
  {!.Net HL7Connect.Fhir.FamilyHistoryRelationCondition}
  TFhirFamilyHistoryRelationCondition = class (TFhirBackboneElement)
  private
    FType_ : TFhirCodeableConcept;
    FOutcome : TFhirCodeableConcept;
    FOnset : TFhirType;
    FNote : TFhirString;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetOutcome(value : TFhirCodeableConcept);
    Procedure SetOnset(value : TFhirType);
    Procedure SetNote(value : TFhirString);
    Function GetNoteST : String;
    Procedure SetNoteST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirFamilyHistoryRelationCondition; overload;
    function Clone : TFhirFamilyHistoryRelationCondition; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member type_
      The actual condition specified. Could be a coded condition (like MI or Diabetes) or a less specific string like 'cancer' depending on how much is known about the condition and the capabilities of the creating system.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    property type_Object : TFhirCodeableConcept read FType_ write SetType_;

    {@member outcome
      Indicates what happened as a result of this condition.  If the condition resulted in death, deceased date is captured on the relation.
    }
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    property outcomeObject : TFhirCodeableConcept read FOutcome write SetOutcome;

    {@member onset
      Either the age of onset, range of approximate age or descriptive string can be recorded.  For conditions with multiple occurrences, this describes the first known occurrence.
    }
    property onset : TFhirType read FOnset write SetOnset;
    property onsetObject : TFhirType read FOnset write SetOnset;

    {@member note
      An area where general notes can be placed about this specific condition.
    }
    {@member note
      Typed access to An area where general notes can be placed about this specific condition.
    }
    property note : String read GetNoteST write SetNoteST;
    property noteObject : TFhirString read FNote write SetNote;

  end;


  TFhirFamilyHistoryRelationConditionListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirFamilyHistoryRelationConditionList;
    function GetCurrent : TFhirFamilyHistoryRelationCondition;
  public
    Constructor Create(list : TFhirFamilyHistoryRelationConditionList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFamilyHistoryRelationCondition read GetCurrent;
  end;


  {@Class TFhirFamilyHistoryRelationConditionList
    A list of FhirFamilyHistoryRelationCondition
  }
  {!.Net HL7Connect.Fhir.FamilyHistoryRelationConditionList}
  TFhirFamilyHistoryRelationConditionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirFamilyHistoryRelationCondition;
    procedure SetItemN(index : Integer; value : TFhirFamilyHistoryRelationCondition);
  public
    {!script hide}
    function Link : TFhirFamilyHistoryRelationConditionList; Overload;
    function Clone : TFhirFamilyHistoryRelationConditionList; Overload;
    function GetEnumerator : TFhirFamilyHistoryRelationConditionListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirFamilyHistoryRelationCondition to the end of the list.
    }
    function Append : TFhirFamilyHistoryRelationCondition;

    
    {@member AddItem
      Add an already existing FhirFamilyHistoryRelationCondition to the end of the list.
    }
    procedure AddItem(value : TFhirFamilyHistoryRelationCondition); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirFamilyHistoryRelationCondition) : Integer;
    

    {@member Insert
      Insert FhirFamilyHistoryRelationCondition before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirFamilyHistoryRelationCondition;
    

    {@member InsertItem
       Insert an existing FhirFamilyHistoryRelationCondition before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirFamilyHistoryRelationCondition);
    
    {@member Item
       Get the iIndexth FhirFamilyHistoryRelationCondition. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirFamilyHistoryRelationCondition. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyHistoryRelationCondition);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirFamilyHistoryRelationCondition;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirFamilyHistoryRelationConditions[index : Integer] : TFhirFamilyHistoryRelationCondition read GetItemN write SetItemN; default;
  End;


  {@Class TFhirGroupCharacteristic : TFhirElement
    Identifies the traits shared by members of the group.
  }
  {!.Net HL7Connect.Fhir.GroupCharacteristic}
  TFhirGroupCharacteristic = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FValue : TFhirType;
    FExclude : TFhirBoolean;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirType);
    Procedure SetExclude(value : TFhirBoolean);
    Function GetExcludeST : Boolean;
    Procedure SetExcludeST(value : Boolean);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirGroupCharacteristic; overload;
    function Clone : TFhirGroupCharacteristic; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      A code that identifies the kind of trait being asserted.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;
    property codeObject : TFhirCodeableConcept read FCode write SetCode;

    {@member value
      The value of the trait that holds (or does not hold - see 'exclude') for members of the group.
    }
    property value : TFhirType read FValue write SetValue;
    property valueObject : TFhirType read FValue write SetValue;

    {@member exclude
      If true, indicates the characteristic is one that is NOT held by members of the group.
    }
    {@member exclude
      Typed access to If true, indicates the characteristic is one that is NOT held by members of the group.
    }
    property exclude : Boolean read GetExcludeST write SetExcludeST;
    property excludeObject : TFhirBoolean read FExclude write SetExclude;

  end;


  TFhirGroupCharacteristicListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirGroupCharacteristicList;
    function GetCurrent : TFhirGroupCharacteristic;
  public
    Constructor Create(list : TFhirGroupCharacteristicList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGroupCharacteristic read GetCurrent;
  end;


  {@Class TFhirGroupCharacteristicList
    A list of FhirGroupCharacteristic
  }
  {!.Net HL7Connect.Fhir.GroupCharacteristicList}
  TFhirGroupCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGroupCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirGroupCharacteristic);
  public
    {!script hide}
    function Link : TFhirGroupCharacteristicList; Overload;
    function Clone : TFhirGroupCharacteristicList; Overload;
    function GetEnumerator : TFhirGroupCharacteristicListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirGroupCharacteristic to the end of the list.
    }
    function Append : TFhirGroupCharacteristic;

    
    {@member AddItem
      Add an already existing FhirGroupCharacteristic to the end of the list.
    }
    procedure AddItem(value : TFhirGroupCharacteristic); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirGroupCharacteristic) : Integer;
    

    {@member Insert
      Insert FhirGroupCharacteristic before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirGroupCharacteristic;
    

    {@member InsertItem
       Insert an existing FhirGroupCharacteristic before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirGroupCharacteristic);
    
    {@member Item
       Get the iIndexth FhirGroupCharacteristic. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirGroupCharacteristic. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirGroupCharacteristic);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirGroupCharacteristic;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirGroupCharacteristics[index : Integer] : TFhirGroupCharacteristic read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImagingStudySeries : TFhirElement
    Each study has one or more series of image instances.
  }
  {!.Net HL7Connect.Fhir.ImagingStudySeries}
  TFhirImagingStudySeries = class (TFhirBackboneElement)
  private
    FNumber : TFhirInteger;
    FModality : TFhirEnum;
    FUid : TFhirOid;
    FDescription : TFhirString;
    FNumberOfInstances : TFhirInteger;
    FAvailability : TFhirEnum;
    FUrl : TFhirUri;
    FBodySite : TFhirCoding;
    FDateTime : TFhirDateTime;
    FinstanceList : TFhirImagingStudySeriesInstanceList;
    Procedure SetNumber(value : TFhirInteger);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetModality(value : TFhirEnum);
    Function GetModalityST : TFhirModality;
    Procedure SetModalityST(value : TFhirModality);
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetNumberOfInstances(value : TFhirInteger);
    Function GetNumberOfInstancesST : String;
    Procedure SetNumberOfInstancesST(value : String);
    Procedure SetAvailability(value : TFhirEnum);
    Function GetAvailabilityST : TFhirInstanceAvailability;
    Procedure SetAvailabilityST(value : TFhirInstanceAvailability);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetBodySite(value : TFhirCoding);
    Procedure SetDateTime(value : TFhirDateTime);
    Function GetDateTimeST : TDateTimeEx;
    Procedure SetDateTimeST(value : TDateTimeEx);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImagingStudySeries; overload;
    function Clone : TFhirImagingStudySeries; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member number
      The number of this series in the overall sequence.
    }
    {@member number
      Typed access to The number of this series in the overall sequence.
    }
    property number : String read GetNumberST write SetNumberST;
    property numberObject : TFhirInteger read FNumber write SetNumber;

    {@member modality
      The modality of this series sequence.
    }
    property modality : TFhirModality read GetModalityST write SetModalityST;
    property modalityObject : TFhirEnum read FModality write SetModality;

    {@member uid
      Formal identifier for this series.
    }
    {@member uid
      Typed access to Formal identifier for this series.
    }
    property uid : String read GetUidST write SetUidST;
    property uidObject : TFhirOid read FUid write SetUid;

    {@member description
      A description of the series.
    }
    {@member description
      Typed access to A description of the series.
    }
    property description : String read GetDescriptionST write SetDescriptionST;
    property descriptionObject : TFhirString read FDescription write SetDescription;

    {@member numberOfInstances
      Sequence that contains attributes from the.
    }
    {@member numberOfInstances
      Typed access to Sequence that contains attributes from the.
    }
    property numberOfInstances : String read GetNumberOfInstancesST write SetNumberOfInstancesST;
    property numberOfInstancesObject : TFhirInteger read FNumberOfInstances write SetNumberOfInstances;

    {@member availability
      Availability of series (online, offline or nearline).
    }
    property availability : TFhirInstanceAvailability read GetAvailabilityST write SetAvailabilityST;
    property availabilityObject : TFhirEnum read FAvailability write SetAvailability;

    {@member url
      WADO-RS URI where Series is available.
    }
    {@member url
      Typed access to WADO-RS URI where Series is available.
    }
    property url : String read GetUrlST write SetUrlST;
    property urlObject : TFhirUri read FUrl write SetUrl;

    {@member bodySite
      Body part examined. See  DICOM Part 16 Annex L for the mapping from DICOM to Snomed.
    }
    property bodySite : TFhirCoding read FBodySite write SetBodySite;
    property bodySiteObject : TFhirCoding read FBodySite write SetBodySite;

    {@member dateTime
      When the series started.
    }
    {@member dateTime
      Typed access to When the series started.
    }
    property dateTime : TDateTimeEx read GetDateTimeST write SetDateTimeST;
    property dateTimeObject : TFhirDateTime read FDateTime write SetDateTime;

    {@member instanceList
      A single image taken from a patient.
    }
    property instanceList : TFhirImagingStudySeriesInstanceList read FInstanceList;

  end;


  TFhirImagingStudySeriesListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudySeriesList;
    function GetCurrent : TFhirImagingStudySeries;
  public
    Constructor Create(list : TFhirImagingStudySeriesList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudySeries read GetCurrent;
  end;


  {@Class TFhirImagingStudySeriesList
    A list of FhirImagingStudySeries
  }
  {!.Net HL7Connect.Fhir.ImagingStudySeriesList}
  TFhirImagingStudySeriesList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudySeries;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeries);
  public
    {!script hide}
    function Link : TFhirImagingStudySeriesList; Overload;
    function Clone : TFhirImagingStudySeriesList; Overload;
    function GetEnumerator : TFhirImagingStudySeriesListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirImagingStudySeries to the end of the list.
    }
    function Append : TFhirImagingStudySeries;

    
    {@member AddItem
      Add an already existing FhirImagingStudySeries to the end of the list.
    }
    procedure AddItem(value : TFhirImagingStudySeries); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImagingStudySeries) : Integer;
    

    {@member Insert
      Insert FhirImagingStudySeries before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImagingStudySeries;
    

    {@member InsertItem
       Insert an existing FhirImagingStudySeries before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeries);
    
    {@member Item
       Get the iIndexth FhirImagingStudySeries. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImagingStudySeries. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeries);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImagingStudySeries;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImagingStudySeries[index : Integer] : TFhirImagingStudySeries read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImagingStudySeriesInstance : TFhirElement
    A single image taken from a patient.
  }
  {!.Net HL7Connect.Fhir.ImagingStudySeriesInstance}
  TFhirImagingStudySeriesInstance = class (TFhirBackboneElement)
  private
    FNumber : TFhirInteger;
    FUid : TFhirOid;
    FSopclass : TFhirOid;
    FType_ : TFhirString;
    FTitle : TFhirString;
    FUrl : TFhirUri;
    FAttachment : TFhirResourceReference{Resource};
    Procedure SetNumber(value : TFhirInteger);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetSopclass(value : TFhirOid);
    Function GetSopclassST : String;
    Procedure SetSopclassST(value : String);
    Procedure SetType_(value : TFhirString);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetAttachment(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImagingStudySeriesInstance; overload;
    function Clone : TFhirImagingStudySeriesInstance; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member number
      The number of this image in the series.
    }
    {@member number
      Typed access to The number of this image in the series.
    }
    property number : String read GetNumberST write SetNumberST;
    property numberObject : TFhirInteger read FNumber write SetNumber;

    {@member uid
      Formal identifier for this image.
    }
    {@member uid
      Typed access to Formal identifier for this image.
    }
    property uid : String read GetUidST write SetUidST;
    property uidObject : TFhirOid read FUid write SetUid;

    {@member sopclass
      DICOM Image type.
    }
    {@member sopclass
      Typed access to DICOM Image type.
    }
    property sopclass : String read GetSopclassST write SetSopclassST;
    property sopclassObject : TFhirOid read FSopclass write SetSopclass;

    {@member type_
      Type of instance (image etc) (0004,1430).
    }
    {@member type_
      Typed access to Type of instance (image etc) (0004,1430).
    }
    property type_ : String read GetType_ST write SetType_ST;
    property type_Object : TFhirString read FType_ write SetType_;

    {@member title
      Description (0070,0080 | 0040,A043 > 0008,0104 | 0042,0010 | 0008,0008).
    }
    {@member title
      Typed access to Description (0070,0080 | 0040,A043 > 0008,0104 | 0042,0010 | 0008,0008).
    }
    property title : String read GetTitleST write SetTitleST;
    property titleObject : TFhirString read FTitle write SetTitle;

    {@member url
      WADO-RS url where image is available.
    }
    {@member url
      Typed access to WADO-RS url where image is available.
    }
    property url : String read GetUrlST write SetUrlST;
    property urlObject : TFhirUri read FUrl write SetUrl;

    {@member attachment
      A FHIR resource with content for this instance.
    }
    property attachment : TFhirResourceReference{Resource} read FAttachment write SetAttachment;
    property attachmentObject : TFhirResourceReference{Resource} read FAttachment write SetAttachment;

  end;


  TFhirImagingStudySeriesInstanceListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudySeriesInstanceList;
    function GetCurrent : TFhirImagingStudySeriesInstance;
  public
    Constructor Create(list : TFhirImagingStudySeriesInstanceList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudySeriesInstance read GetCurrent;
  end;


  {@Class TFhirImagingStudySeriesInstanceList
    A list of FhirImagingStudySeriesInstance
  }
  {!.Net HL7Connect.Fhir.ImagingStudySeriesInstanceList}
  TFhirImagingStudySeriesInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudySeriesInstance;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeriesInstance);
  public
    {!script hide}
    function Link : TFhirImagingStudySeriesInstanceList; Overload;
    function Clone : TFhirImagingStudySeriesInstanceList; Overload;
    function GetEnumerator : TFhirImagingStudySeriesInstanceListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirImagingStudySeriesInstance to the end of the list.
    }
    function Append : TFhirImagingStudySeriesInstance;

    
    {@member AddItem
      Add an already existing FhirImagingStudySeriesInstance to the end of the list.
    }
    procedure AddItem(value : TFhirImagingStudySeriesInstance); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImagingStudySeriesInstance) : Integer;
    

    {@member Insert
      Insert FhirImagingStudySeriesInstance before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImagingStudySeriesInstance;
    

    {@member InsertItem
       Insert an existing FhirImagingStudySeriesInstance before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeriesInstance);
    
    {@member Item
       Get the iIndexth FhirImagingStudySeriesInstance. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImagingStudySeriesInstance. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeriesInstance);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImagingStudySeriesInstance;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImagingStudySeriesInstances[index : Integer] : TFhirImagingStudySeriesInstance read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationExplanation : TFhirElement
    Reasons why a vaccine was administered or refused.
  }
  {!.Net HL7Connect.Fhir.ImmunizationExplanation}
  TFhirImmunizationExplanation = class (TFhirBackboneElement)
  private
    FreasonList : TFhirCodeableConceptList;
    FrefusalReasonList : TFhirCodeableConceptList;
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationExplanation; overload;
    function Clone : TFhirImmunizationExplanation; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member reasonList
      Reasons why a vaccine was administered.
    }
    property reasonList : TFhirCodeableConceptList read FReasonList;

    {@member refusalReasonList
      Refusal or exemption reasons.
    }
    property refusalReasonList : TFhirCodeableConceptList read FRefusalReasonList;

  end;


  TFhirImmunizationExplanationListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationExplanationList;
    function GetCurrent : TFhirImmunizationExplanation;
  public
    Constructor Create(list : TFhirImmunizationExplanationList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationExplanation read GetCurrent;
  end;


  {@Class TFhirImmunizationExplanationList
    A list of FhirImmunizationExplanation
  }
  {!.Net HL7Connect.Fhir.ImmunizationExplanationList}
  TFhirImmunizationExplanationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationExplanation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationExplanation);
  public
    {!script hide}
    function Link : TFhirImmunizationExplanationList; Overload;
    function Clone : TFhirImmunizationExplanationList; Overload;
    function GetEnumerator : TFhirImmunizationExplanationListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationExplanation to the end of the list.
    }
    function Append : TFhirImmunizationExplanation;

    
    {@member AddItem
      Add an already existing FhirImmunizationExplanation to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationExplanation); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationExplanation) : Integer;
    

    {@member Insert
      Insert FhirImmunizationExplanation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationExplanation;
    

    {@member InsertItem
       Insert an existing FhirImmunizationExplanation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationExplanation);
    
    {@member Item
       Get the iIndexth FhirImmunizationExplanation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationExplanation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationExplanation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationExplanation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationExplanations[index : Integer] : TFhirImmunizationExplanation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationReaction : TFhirElement
    Categorical data indicating that an adverse event is associated in time to an immunization.
  }
  {!.Net HL7Connect.Fhir.ImmunizationReaction}
  TFhirImmunizationReaction = class (TFhirBackboneElement)
  private
    FDate : TFhirDateTime;
    FDetail : TFhirResourceReference{Resource};
    FReported : TFhirBoolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TDateTimeEx;
    Procedure SetDateST(value : TDateTimeEx);
    Procedure SetDetail(value : TFhirResourceReference{Resource});
    Procedure SetReported(value : TFhirBoolean);
    Function GetReportedST : Boolean;
    Procedure SetReportedST(value : Boolean);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationReaction; overload;
    function Clone : TFhirImmunizationReaction; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member date
      Date of reaction to the immunization.
    }
    {@member date
      Typed access to Date of reaction to the immunization.
    }
    property date : TDateTimeEx read GetDateST write SetDateST;
    property dateObject : TFhirDateTime read FDate write SetDate;

    {@member detail
      Details of the reaction.
    }
    property detail : TFhirResourceReference{Resource} read FDetail write SetDetail;
    property detailObject : TFhirResourceReference{Resource} read FDetail write SetDetail;

    {@member reported
      Self-reported indicator.
    }
    {@member reported
      Typed access to Self-reported indicator.
    }
    property reported : Boolean read GetReportedST write SetReportedST;
    property reportedObject : TFhirBoolean read FReported write SetReported;

  end;


  TFhirImmunizationReactionListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationReactionList;
    function GetCurrent : TFhirImmunizationReaction;
  public
    Constructor Create(list : TFhirImmunizationReactionList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationReaction read GetCurrent;
  end;


  {@Class TFhirImmunizationReactionList
    A list of FhirImmunizationReaction
  }
  {!.Net HL7Connect.Fhir.ImmunizationReactionList}
  TFhirImmunizationReactionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationReaction;
    procedure SetItemN(index : Integer; value : TFhirImmunizationReaction);
  public
    {!script hide}
    function Link : TFhirImmunizationReactionList; Overload;
    function Clone : TFhirImmunizationReactionList; Overload;
    function GetEnumerator : TFhirImmunizationReactionListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationReaction to the end of the list.
    }
    function Append : TFhirImmunizationReaction;

    
    {@member AddItem
      Add an already existing FhirImmunizationReaction to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationReaction); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationReaction) : Integer;
    

    {@member Insert
      Insert FhirImmunizationReaction before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationReaction;
    

    {@member InsertItem
       Insert an existing FhirImmunizationReaction before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationReaction);
    
    {@member Item
       Get the iIndexth FhirImmunizationReaction. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationReaction. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationReaction);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationReaction;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationReactions[index : Integer] : TFhirImmunizationReaction read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationVaccinationProtocol : TFhirElement
    Contains information about the protocol(s) under which the vaccine was administered.
  }
  {!.Net HL7Connect.Fhir.ImmunizationVaccinationProtocol}
  TFhirImmunizationVaccinationProtocol = class (TFhirBackboneElement)
  private
    FDoseSequence : TFhirInteger;
    FDescription : TFhirString;
    FAuthority : TFhirResourceReference{TFhirOrganization};
    FSeries : TFhirString;
    FSeriesDoses : TFhirInteger;
    FDoseTarget : TFhirCodeableConcept;
    FDoseStatus : TFhirCodeableConcept;
    FDoseStatusReason : TFhirCodeableConcept;
    Procedure SetDoseSequence(value : TFhirInteger);
    Function GetDoseSequenceST : String;
    Procedure SetDoseSequenceST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAuthority(value : TFhirResourceReference{TFhirOrganization});
    Procedure SetSeries(value : TFhirString);
    Function GetSeriesST : String;
    Procedure SetSeriesST(value : String);
    Procedure SetSeriesDoses(value : TFhirInteger);
    Function GetSeriesDosesST : String;
    Procedure SetSeriesDosesST(value : String);
    Procedure SetDoseTarget(value : TFhirCodeableConcept);
    Procedure SetDoseStatus(value : TFhirCodeableConcept);
    Procedure SetDoseStatusReason(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationVaccinationProtocol; overload;
    function Clone : TFhirImmunizationVaccinationProtocol; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member doseSequence
      Nominal position in a series.
    }
    {@member doseSequence
      Typed access to Nominal position in a series.
    }
    property doseSequence : String read GetDoseSequenceST write SetDoseSequenceST;
    property doseSequenceObject : TFhirInteger read FDoseSequence write SetDoseSequence;

    {@member description
      Contains the description about the protocol under which the vaccine was administered.
    }
    {@member description
      Typed access to Contains the description about the protocol under which the vaccine was administered.
    }
    property description : String read GetDescriptionST write SetDescriptionST;
    property descriptionObject : TFhirString read FDescription write SetDescription;

    {@member authority
      Indicates the authority who published the protocol?  E.g. ACIP.
    }
    property authority : TFhirResourceReference{TFhirOrganization} read FAuthority write SetAuthority;
    property authorityObject : TFhirResourceReference{TFhirOrganization} read FAuthority write SetAuthority;

    {@member series
      One possible path to achieve presumed immunity against a disease - within the context of an authority.
    }
    {@member series
      Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    }
    property series : String read GetSeriesST write SetSeriesST;
    property seriesObject : TFhirString read FSeries write SetSeries;

    {@member seriesDoses
      The recommended number of doses to achieve immunity.
    }
    {@member seriesDoses
      Typed access to The recommended number of doses to achieve immunity.
    }
    property seriesDoses : String read GetSeriesDosesST write SetSeriesDosesST;
    property seriesDosesObject : TFhirInteger read FSeriesDoses write SetSeriesDoses;

    {@member doseTarget
      The targeted disease.
    }
    property doseTarget : TFhirCodeableConcept read FDoseTarget write SetDoseTarget;
    property doseTargetObject : TFhirCodeableConcept read FDoseTarget write SetDoseTarget;

    {@member doseStatus
      Indicates if the immunization event should "count" against  the protocol.
    }
    property doseStatus : TFhirCodeableConcept read FDoseStatus write SetDoseStatus;
    property doseStatusObject : TFhirCodeableConcept read FDoseStatus write SetDoseStatus;

    {@member doseStatusReason
      Provides an explanation as to why a immunization event should or should not count against the protocol.
    }
    property doseStatusReason : TFhirCodeableConcept read FDoseStatusReason write SetDoseStatusReason;
    property doseStatusReasonObject : TFhirCodeableConcept read FDoseStatusReason write SetDoseStatusReason;

  end;


  TFhirImmunizationVaccinationProtocolListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationVaccinationProtocolList;
    function GetCurrent : TFhirImmunizationVaccinationProtocol;
  public
    Constructor Create(list : TFhirImmunizationVaccinationProtocolList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationVaccinationProtocol read GetCurrent;
  end;


  {@Class TFhirImmunizationVaccinationProtocolList
    A list of FhirImmunizationVaccinationProtocol
  }
  {!.Net HL7Connect.Fhir.ImmunizationVaccinationProtocolList}
  TFhirImmunizationVaccinationProtocolList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationVaccinationProtocol;
    procedure SetItemN(index : Integer; value : TFhirImmunizationVaccinationProtocol);
  public
    {!script hide}
    function Link : TFhirImmunizationVaccinationProtocolList; Overload;
    function Clone : TFhirImmunizationVaccinationProtocolList; Overload;
    function GetEnumerator : TFhirImmunizationVaccinationProtocolListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationVaccinationProtocol to the end of the list.
    }
    function Append : TFhirImmunizationVaccinationProtocol;

    
    {@member AddItem
      Add an already existing FhirImmunizationVaccinationProtocol to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationVaccinationProtocol); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationVaccinationProtocol) : Integer;
    

    {@member Insert
      Insert FhirImmunizationVaccinationProtocol before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationVaccinationProtocol;
    

    {@member InsertItem
       Insert an existing FhirImmunizationVaccinationProtocol before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationVaccinationProtocol);
    
    {@member Item
       Get the iIndexth FhirImmunizationVaccinationProtocol. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationVaccinationProtocol. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationVaccinationProtocol);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationVaccinationProtocol;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationVaccinationProtocols[index : Integer] : TFhirImmunizationVaccinationProtocol read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationRecommendationRecommendation : TFhirElement
    Vaccine administration recommendations.
  }
  {!.Net HL7Connect.Fhir.ImmunizationRecommendationRecommendation}
  TFhirImmunizationRecommendationRecommendation = class (TFhirBackboneElement)
  private
    FDate : TFhirDateTime;
    FVaccineType : TFhirCodeableConcept;
    FDoseNumber : TFhirInteger;
    FForecastStatus : TFhirCodeableConcept;
    FdateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    FProtocol : TFhirImmunizationRecommendationRecommendationProtocol;
    FsupportingImmunizationList : TFhirResourceReferenceList{TFhirImmunization};
    FsupportingPatientInformationList : TFhirResourceReferenceList{Resource};
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TDateTimeEx;
    Procedure SetDateST(value : TDateTimeEx);
    Procedure SetVaccineType(value : TFhirCodeableConcept);
    Procedure SetDoseNumber(value : TFhirInteger);
    Function GetDoseNumberST : String;
    Procedure SetDoseNumberST(value : String);
    Procedure SetForecastStatus(value : TFhirCodeableConcept);
    Procedure SetProtocol(value : TFhirImmunizationRecommendationRecommendationProtocol);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationRecommendationRecommendation; overload;
    function Clone : TFhirImmunizationRecommendationRecommendation; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member date
      The date the immunization recommendation was created.
    }
    {@member date
      Typed access to The date the immunization recommendation was created.
    }
    property date : TDateTimeEx read GetDateST write SetDateST;
    property dateObject : TFhirDateTime read FDate write SetDate;

    {@member vaccineType
      Vaccine that pertains to the recommendation.
    }
    property vaccineType : TFhirCodeableConcept read FVaccineType write SetVaccineType;
    property vaccineTypeObject : TFhirCodeableConcept read FVaccineType write SetVaccineType;

    {@member doseNumber
      This indicates the next recommended dose number (e.g. dose 2 is the next recommended dose).
    }
    {@member doseNumber
      Typed access to This indicates the next recommended dose number (e.g. dose 2 is the next recommended dose).
    }
    property doseNumber : String read GetDoseNumberST write SetDoseNumberST;
    property doseNumberObject : TFhirInteger read FDoseNumber write SetDoseNumber;

    {@member forecastStatus
      Vaccine administration status.
    }
    property forecastStatus : TFhirCodeableConcept read FForecastStatus write SetForecastStatus;
    property forecastStatusObject : TFhirCodeableConcept read FForecastStatus write SetForecastStatus;

    {@member dateCriterionList
      Vaccine date recommendations - e.g. earliest date to administer, latest date to administer, etc.
    }
    property dateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList read FDateCriterionList;

    {@member protocol
      Contains information about the protocol under which the vaccine was administered.
    }
    property protocol : TFhirImmunizationRecommendationRecommendationProtocol read FProtocol write SetProtocol;
    property protocolObject : TFhirImmunizationRecommendationRecommendationProtocol read FProtocol write SetProtocol;

    {@member supportingImmunizationList
      Immunization event history that supports the status and recommendation.
    }
    property supportingImmunizationList : TFhirResourceReferenceList{TFhirImmunization} read FSupportingImmunizationList;

    {@member supportingPatientInformationList
      Patient Information that supports the status and recommendation.  This includes patient observations, adverse reactions and allergy/intolerance information.
    }
    property supportingPatientInformationList : TFhirResourceReferenceList{Resource} read FSupportingPatientInformationList;

  end;


  TFhirImmunizationRecommendationRecommendationListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationRecommendationList;
    function GetCurrent : TFhirImmunizationRecommendationRecommendation;
  public
    Constructor Create(list : TFhirImmunizationRecommendationRecommendationList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendationRecommendation read GetCurrent;
  end;


  {@Class TFhirImmunizationRecommendationRecommendationList
    A list of FhirImmunizationRecommendationRecommendation
  }
  {!.Net HL7Connect.Fhir.ImmunizationRecommendationRecommendationList}
  TFhirImmunizationRecommendationRecommendationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendation);
  public
    {!script hide}
    function Link : TFhirImmunizationRecommendationRecommendationList; Overload;
    function Clone : TFhirImmunizationRecommendationRecommendationList; Overload;
    function GetEnumerator : TFhirImmunizationRecommendationRecommendationListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationRecommendationRecommendation to the end of the list.
    }
    function Append : TFhirImmunizationRecommendationRecommendation;

    
    {@member AddItem
      Add an already existing FhirImmunizationRecommendationRecommendation to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationRecommendationRecommendation); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationRecommendationRecommendation) : Integer;
    

    {@member Insert
      Insert FhirImmunizationRecommendationRecommendation before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendation;
    

    {@member InsertItem
       Insert an existing FhirImmunizationRecommendationRecommendation before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendation);
    
    {@member Item
       Get the iIndexth FhirImmunizationRecommendationRecommendation. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationRecommendationRecommendation. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendation);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendation;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationRecommendationRecommendations[index : Integer] : TFhirImmunizationRecommendationRecommendation read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationRecommendationRecommendationDateCriterion : TFhirElement
    Vaccine date recommendations - e.g. earliest date to administer, latest date to administer, etc.
  }
  {!.Net HL7Connect.Fhir.ImmunizationRecommendationRecommendationDateCriterion}
  TFhirImmunizationRecommendationRecommendationDateCriterion = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FValue : TFhirDateTime;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirDateTime);
    Function GetValueST : TDateTimeEx;
    Procedure SetValueST(value : TDateTimeEx);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationRecommendationRecommendationDateCriterion; overload;
    function Clone : TFhirImmunizationRecommendationRecommendationDateCriterion; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      Date classification of recommendation - e.g. earliest date to give, latest date to give, etc.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;
    property codeObject : TFhirCodeableConcept read FCode write SetCode;

    {@member value
      Date recommendation.
    }
    {@member value
      Typed access to Date recommendation.
    }
    property value : TDateTimeEx read GetValueST write SetValueST;
    property valueObject : TFhirDateTime read FValue write SetValue;

  end;


  TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    function GetCurrent : TFhirImmunizationRecommendationRecommendationDateCriterion;
  public
    Constructor Create(list : TFhirImmunizationRecommendationRecommendationDateCriterionList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendationRecommendationDateCriterion read GetCurrent;
  end;


  {@Class TFhirImmunizationRecommendationRecommendationDateCriterionList
    A list of FhirImmunizationRecommendationRecommendationDateCriterion
  }
  {!.Net HL7Connect.Fhir.ImmunizationRecommendationRecommendationDateCriterionList}
  TFhirImmunizationRecommendationRecommendationDateCriterionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
  public
    {!script hide}
    function Link : TFhirImmunizationRecommendationRecommendationDateCriterionList; Overload;
    function Clone : TFhirImmunizationRecommendationRecommendationDateCriterionList; Overload;
    function GetEnumerator : TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationRecommendationRecommendationDateCriterion to the end of the list.
    }
    function Append : TFhirImmunizationRecommendationRecommendationDateCriterion;

    
    {@member AddItem
      Add an already existing FhirImmunizationRecommendationRecommendationDateCriterion to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationRecommendationRecommendationDateCriterion); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationRecommendationRecommendationDateCriterion) : Integer;
    

    {@member Insert
      Insert FhirImmunizationRecommendationRecommendationDateCriterion before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    

    {@member InsertItem
       Insert an existing FhirImmunizationRecommendationRecommendationDateCriterion before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
    
    {@member Item
       Get the iIndexth FhirImmunizationRecommendationRecommendationDateCriterion. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationRecommendationRecommendationDateCriterion. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationRecommendationRecommendationDateCriterions[index : Integer] : TFhirImmunizationRecommendationRecommendationDateCriterion read GetItemN write SetItemN; default;
  End;


  {@Class TFhirImmunizationRecommendationRecommendationProtocol : TFhirElement
    Contains information about the protocol under which the vaccine was administered.
  }
  {!.Net HL7Connect.Fhir.ImmunizationRecommendationRecommendationProtocol}
  TFhirImmunizationRecommendationRecommendationProtocol = class (TFhirBackboneElement)
  private
    FDoseSequence : TFhirInteger;
    FDescription : TFhirString;
    FAuthority : TFhirResourceReference{TFhirOrganization};
    FSeries : TFhirString;
    Procedure SetDoseSequence(value : TFhirInteger);
    Function GetDoseSequenceST : String;
    Procedure SetDoseSequenceST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAuthority(value : TFhirResourceReference{TFhirOrganization});
    Procedure SetSeries(value : TFhirString);
    Function GetSeriesST : String;
    Procedure SetSeriesST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirImmunizationRecommendationRecommendationProtocol; overload;
    function Clone : TFhirImmunizationRecommendationRecommendationProtocol; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member doseSequence
      Indicates the nominal position in a series of the next dose.  This is the recommended dose number as per a specified protocol.
    }
    {@member doseSequence
      Typed access to Indicates the nominal position in a series of the next dose.  This is the recommended dose number as per a specified protocol.
    }
    property doseSequence : String read GetDoseSequenceST write SetDoseSequenceST;
    property doseSequenceObject : TFhirInteger read FDoseSequence write SetDoseSequence;

    {@member description
      Contains the description about the protocol under which the vaccine was administered.
    }
    {@member description
      Typed access to Contains the description about the protocol under which the vaccine was administered.
    }
    property description : String read GetDescriptionST write SetDescriptionST;
    property descriptionObject : TFhirString read FDescription write SetDescription;

    {@member authority
      Indicates the authority who published the protocol?  E.g. ACIP.
    }
    property authority : TFhirResourceReference{TFhirOrganization} read FAuthority write SetAuthority;
    property authorityObject : TFhirResourceReference{TFhirOrganization} read FAuthority write SetAuthority;

    {@member series
      One possible path to achieve presumed immunity against a disease - within the context of an authority.
    }
    {@member series
      Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    }
    property series : String read GetSeriesST write SetSeriesST;
    property seriesObject : TFhirString read FSeries write SetSeries;

  end;


  TFhirImmunizationRecommendationRecommendationProtocolListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationRecommendationProtocolList;
    function GetCurrent : TFhirImmunizationRecommendationRecommendationProtocol;
  public
    Constructor Create(list : TFhirImmunizationRecommendationRecommendationProtocolList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendationRecommendationProtocol read GetCurrent;
  end;


  {@Class TFhirImmunizationRecommendationRecommendationProtocolList
    A list of FhirImmunizationRecommendationRecommendationProtocol
  }
  {!.Net HL7Connect.Fhir.ImmunizationRecommendationRecommendationProtocolList}
  TFhirImmunizationRecommendationRecommendationProtocolList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendationProtocol;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendationProtocol);
  public
    {!script hide}
    function Link : TFhirImmunizationRecommendationRecommendationProtocolList; Overload;
    function Clone : TFhirImmunizationRecommendationRecommendationProtocolList; Overload;
    function GetEnumerator : TFhirImmunizationRecommendationRecommendationProtocolListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirImmunizationRecommendationRecommendationProtocol to the end of the list.
    }
    function Append : TFhirImmunizationRecommendationRecommendationProtocol;

    
    {@member AddItem
      Add an already existing FhirImmunizationRecommendationRecommendationProtocol to the end of the list.
    }
    procedure AddItem(value : TFhirImmunizationRecommendationRecommendationProtocol); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirImmunizationRecommendationRecommendationProtocol) : Integer;
    

    {@member Insert
      Insert FhirImmunizationRecommendationRecommendationProtocol before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendationProtocol;
    

    {@member InsertItem
       Insert an existing FhirImmunizationRecommendationRecommendationProtocol before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendationProtocol);
    
    {@member Item
       Get the iIndexth FhirImmunizationRecommendationRecommendationProtocol. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirImmunizationRecommendationRecommendationProtocol. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendationProtocol);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendationProtocol;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirImmunizationRecommendationRecommendationProtocols[index : Integer] : TFhirImmunizationRecommendationRecommendationProtocol read GetItemN write SetItemN; default;
  End;


  {@Class TFhirListEntry : TFhirElement
    Entries in this list.
  }
  {!.Net HL7Connect.Fhir.ListEntry}
  TFhirListEntry = class (TFhirBackboneElement)
  private
    FflagList : TFhirCodeableConceptList;
    FDeleted : TFhirBoolean;
    FDate : TFhirDateTime;
    FItem : TFhirResourceReference{Resource};
    Procedure SetDeleted(value : TFhirBoolean);
    Function GetDeletedST : Boolean;
    Procedure SetDeletedST(value : Boolean);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TDateTimeEx;
    Procedure SetDateST(value : TDateTimeEx);
    Procedure SetItem(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirListEntry; overload;
    function Clone : TFhirListEntry; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member flagList
      The flag allows the system constructing the list to make one or more statements about the role and significance of the item in the list.
    }
    property flagList : TFhirCodeableConceptList read FFlagList;

    {@member deleted
      True if this item is marked as deleted in the list.
    }
    {@member deleted
      Typed access to True if this item is marked as deleted in the list.
    }
    property deleted : Boolean read GetDeletedST write SetDeletedST;
    property deletedObject : TFhirBoolean read FDeleted write SetDeleted;

    {@member date
      When this item was added to the list.
    }
    {@member date
      Typed access to When this item was added to the list.
    }
    property date : TDateTimeEx read GetDateST write SetDateST;
    property dateObject : TFhirDateTime read FDate write SetDate;

    {@member item
      A reference to the actual resource from which data was derived.
    }
    property item : TFhirResourceReference{Resource} read FItem write SetItem;
    property itemObject : TFhirResourceReference{Resource} read FItem write SetItem;

  end;


  TFhirListEntryListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirListEntryList;
    function GetCurrent : TFhirListEntry;
  public
    Constructor Create(list : TFhirListEntryList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirListEntry read GetCurrent;
  end;


  {@Class TFhirListEntryList
    A list of FhirListEntry
  }
  {!.Net HL7Connect.Fhir.ListEntryList}
  TFhirListEntryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirListEntry;
    procedure SetItemN(index : Integer; value : TFhirListEntry);
  public
    {!script hide}
    function Link : TFhirListEntryList; Overload;
    function Clone : TFhirListEntryList; Overload;
    function GetEnumerator : TFhirListEntryListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirListEntry to the end of the list.
    }
    function Append : TFhirListEntry;

    
    {@member AddItem
      Add an already existing FhirListEntry to the end of the list.
    }
    procedure AddItem(value : TFhirListEntry); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirListEntry) : Integer;
    

    {@member Insert
      Insert FhirListEntry before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirListEntry;
    

    {@member InsertItem
       Insert an existing FhirListEntry before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirListEntry);
    
    {@member Item
       Get the iIndexth FhirListEntry. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirListEntry. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirListEntry);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirListEntry;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirListEntries[index : Integer] : TFhirListEntry read GetItemN write SetItemN; default;
  End;


  {@Class TFhirLocationPosition : TFhirElement
    The absolute geographic location of the Location, expressed in a KML compatible manner (see notes below for KML).
  }
  {!.Net HL7Connect.Fhir.LocationPosition}
  TFhirLocationPosition = class (TFhirBackboneElement)
  private
    FLongitude : TFhirDecimal;
    FLatitude : TFhirDecimal;
    FAltitude : TFhirDecimal;
    Procedure SetLongitude(value : TFhirDecimal);
    Function GetLongitudeST : String;
    Procedure SetLongitudeST(value : String);
    Procedure SetLatitude(value : TFhirDecimal);
    Function GetLatitudeST : String;
    Procedure SetLatitudeST(value : String);
    Procedure SetAltitude(value : TFhirDecimal);
    Function GetAltitudeST : String;
    Procedure SetAltitudeST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirLocationPosition; overload;
    function Clone : TFhirLocationPosition; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member longitude
      Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
    }
    {@member longitude
      Typed access to Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
    }
    property longitude : String read GetLongitudeST write SetLongitudeST;
    property longitudeObject : TFhirDecimal read FLongitude write SetLongitude;

    {@member latitude
      Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
    }
    {@member latitude
      Typed access to Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
    }
    property latitude : String read GetLatitudeST write SetLatitudeST;
    property latitudeObject : TFhirDecimal read FLatitude write SetLatitude;

    {@member altitude
      Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
    }
    {@member altitude
      Typed access to Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
    }
    property altitude : String read GetAltitudeST write SetAltitudeST;
    property altitudeObject : TFhirDecimal read FAltitude write SetAltitude;

  end;


  TFhirLocationPositionListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirLocationPositionList;
    function GetCurrent : TFhirLocationPosition;
  public
    Constructor Create(list : TFhirLocationPositionList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLocationPosition read GetCurrent;
  end;


  {@Class TFhirLocationPositionList
    A list of FhirLocationPosition
  }
  {!.Net HL7Connect.Fhir.LocationPositionList}
  TFhirLocationPositionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLocationPosition;
    procedure SetItemN(index : Integer; value : TFhirLocationPosition);
  public
    {!script hide}
    function Link : TFhirLocationPositionList; Overload;
    function Clone : TFhirLocationPositionList; Overload;
    function GetEnumerator : TFhirLocationPositionListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirLocationPosition to the end of the list.
    }
    function Append : TFhirLocationPosition;

    
    {@member AddItem
      Add an already existing FhirLocationPosition to the end of the list.
    }
    procedure AddItem(value : TFhirLocationPosition); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirLocationPosition) : Integer;
    

    {@member Insert
      Insert FhirLocationPosition before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirLocationPosition;
    

    {@member InsertItem
       Insert an existing FhirLocationPosition before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirLocationPosition);
    
    {@member Item
       Get the iIndexth FhirLocationPosition. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirLocationPosition. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirLocationPosition);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirLocationPosition;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirLocationPositions[index : Integer] : TFhirLocationPosition read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationProduct : TFhirElement
    Information that only applies to products (not packages).
  }
  {!.Net HL7Connect.Fhir.MedicationProduct}
  TFhirMedicationProduct = class (TFhirBackboneElement)
  private
    FForm : TFhirCodeableConcept;
    FingredientList : TFhirMedicationProductIngredientList;
    Procedure SetForm(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationProduct; overload;
    function Clone : TFhirMedicationProduct; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member form
      Describes the form of the item.  Powder; tables; carton.
    }
    property form : TFhirCodeableConcept read FForm write SetForm;
    property formObject : TFhirCodeableConcept read FForm write SetForm;

    {@member ingredientList
      Identifies a particular constituent of interest in the product.
    }
    property ingredientList : TFhirMedicationProductIngredientList read FIngredientList;

  end;


  TFhirMedicationProductListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMedicationProductList;
    function GetCurrent : TFhirMedicationProduct;
  public
    Constructor Create(list : TFhirMedicationProductList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationProduct read GetCurrent;
  end;


  {@Class TFhirMedicationProductList
    A list of FhirMedicationProduct
  }
  {!.Net HL7Connect.Fhir.MedicationProductList}
  TFhirMedicationProductList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationProduct;
    procedure SetItemN(index : Integer; value : TFhirMedicationProduct);
  public
    {!script hide}
    function Link : TFhirMedicationProductList; Overload;
    function Clone : TFhirMedicationProductList; Overload;
    function GetEnumerator : TFhirMedicationProductListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMedicationProduct to the end of the list.
    }
    function Append : TFhirMedicationProduct;

    
    {@member AddItem
      Add an already existing FhirMedicationProduct to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationProduct); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationProduct) : Integer;
    

    {@member Insert
      Insert FhirMedicationProduct before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationProduct;
    

    {@member InsertItem
       Insert an existing FhirMedicationProduct before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationProduct);
    
    {@member Item
       Get the iIndexth FhirMedicationProduct. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationProduct. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationProduct);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationProduct;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationProducts[index : Integer] : TFhirMedicationProduct read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationProductIngredient : TFhirElement
    Identifies a particular constituent of interest in the product.
  }
  {!.Net HL7Connect.Fhir.MedicationProductIngredient}
  TFhirMedicationProductIngredient = class (TFhirBackboneElement)
  private
    FItem : TFhirResourceReference{Resource};
    FAmount : TFhirRatio;
    Procedure SetItem(value : TFhirResourceReference{Resource});
    Procedure SetAmount(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationProductIngredient; overload;
    function Clone : TFhirMedicationProductIngredient; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member item
      The actual ingredient - either a substance (simple ingredient) or another medication.
    }
    property item : TFhirResourceReference{Resource} read FItem write SetItem;
    property itemObject : TFhirResourceReference{Resource} read FItem write SetItem;

    {@member amount
      Specifies how many (or how much) of the items there are in this Medication.  E.g. 250 mg per tablet.
    }
    property amount : TFhirRatio read FAmount write SetAmount;
    property amountObject : TFhirRatio read FAmount write SetAmount;

  end;


  TFhirMedicationProductIngredientListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMedicationProductIngredientList;
    function GetCurrent : TFhirMedicationProductIngredient;
  public
    Constructor Create(list : TFhirMedicationProductIngredientList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationProductIngredient read GetCurrent;
  end;


  {@Class TFhirMedicationProductIngredientList
    A list of FhirMedicationProductIngredient
  }
  {!.Net HL7Connect.Fhir.MedicationProductIngredientList}
  TFhirMedicationProductIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationProductIngredient;
    procedure SetItemN(index : Integer; value : TFhirMedicationProductIngredient);
  public
    {!script hide}
    function Link : TFhirMedicationProductIngredientList; Overload;
    function Clone : TFhirMedicationProductIngredientList; Overload;
    function GetEnumerator : TFhirMedicationProductIngredientListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMedicationProductIngredient to the end of the list.
    }
    function Append : TFhirMedicationProductIngredient;

    
    {@member AddItem
      Add an already existing FhirMedicationProductIngredient to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationProductIngredient); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationProductIngredient) : Integer;
    

    {@member Insert
      Insert FhirMedicationProductIngredient before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationProductIngredient;
    

    {@member InsertItem
       Insert an existing FhirMedicationProductIngredient before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationProductIngredient);
    
    {@member Item
       Get the iIndexth FhirMedicationProductIngredient. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationProductIngredient. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationProductIngredient);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationProductIngredient;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationProductIngredients[index : Integer] : TFhirMedicationProductIngredient read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPackage : TFhirElement
    Information that only applies to packages (not products).
  }
  {!.Net HL7Connect.Fhir.MedicationPackage}
  TFhirMedicationPackage = class (TFhirBackboneElement)
  private
    FContainer : TFhirCodeableConcept;
    FcontentList : TFhirMedicationPackageContentList;
    Procedure SetContainer(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPackage; overload;
    function Clone : TFhirMedicationPackage; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member container
      The kind of container that this package comes as.
    }
    property container : TFhirCodeableConcept read FContainer write SetContainer;
    property containerObject : TFhirCodeableConcept read FContainer write SetContainer;

    {@member contentList
      A set of components that go to make up the described item.
    }
    property contentList : TFhirMedicationPackageContentList read FContentList;

  end;


  TFhirMedicationPackageListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMedicationPackageList;
    function GetCurrent : TFhirMedicationPackage;
  public
    Constructor Create(list : TFhirMedicationPackageList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationPackage read GetCurrent;
  end;


  {@Class TFhirMedicationPackageList
    A list of FhirMedicationPackage
  }
  {!.Net HL7Connect.Fhir.MedicationPackageList}
  TFhirMedicationPackageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPackage;
    procedure SetItemN(index : Integer; value : TFhirMedicationPackage);
  public
    {!script hide}
    function Link : TFhirMedicationPackageList; Overload;
    function Clone : TFhirMedicationPackageList; Overload;
    function GetEnumerator : TFhirMedicationPackageListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPackage to the end of the list.
    }
    function Append : TFhirMedicationPackage;

    
    {@member AddItem
      Add an already existing FhirMedicationPackage to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPackage); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPackage) : Integer;
    

    {@member Insert
      Insert FhirMedicationPackage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPackage;
    

    {@member InsertItem
       Insert an existing FhirMedicationPackage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPackage);
    
    {@member Item
       Get the iIndexth FhirMedicationPackage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPackage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPackage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPackage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPackages[index : Integer] : TFhirMedicationPackage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPackageContent : TFhirElement
    A set of components that go to make up the described item.
  }
  {!.Net HL7Connect.Fhir.MedicationPackageContent}
  TFhirMedicationPackageContent = class (TFhirBackboneElement)
  private
    FItem : TFhirResourceReference{TFhirMedication};
    FAmount : TFhirQuantity;
    Procedure SetItem(value : TFhirResourceReference{TFhirMedication});
    Procedure SetAmount(value : TFhirQuantity);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPackageContent; overload;
    function Clone : TFhirMedicationPackageContent; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member item
      Identifies one of the items in the package.
    }
    property item : TFhirResourceReference{TFhirMedication} read FItem write SetItem;
    property itemObject : TFhirResourceReference{TFhirMedication} read FItem write SetItem;

    {@member amount
      The amount of the product that is in the package.
    }
    property amount : TFhirQuantity read FAmount write SetAmount;
    property amountObject : TFhirQuantity read FAmount write SetAmount;

  end;


  TFhirMedicationPackageContentListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMedicationPackageContentList;
    function GetCurrent : TFhirMedicationPackageContent;
  public
    Constructor Create(list : TFhirMedicationPackageContentList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationPackageContent read GetCurrent;
  end;


  {@Class TFhirMedicationPackageContentList
    A list of FhirMedicationPackageContent
  }
  {!.Net HL7Connect.Fhir.MedicationPackageContentList}
  TFhirMedicationPackageContentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPackageContent;
    procedure SetItemN(index : Integer; value : TFhirMedicationPackageContent);
  public
    {!script hide}
    function Link : TFhirMedicationPackageContentList; Overload;
    function Clone : TFhirMedicationPackageContentList; Overload;
    function GetEnumerator : TFhirMedicationPackageContentListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPackageContent to the end of the list.
    }
    function Append : TFhirMedicationPackageContent;

    
    {@member AddItem
      Add an already existing FhirMedicationPackageContent to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPackageContent); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPackageContent) : Integer;
    

    {@member Insert
      Insert FhirMedicationPackageContent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPackageContent;
    

    {@member InsertItem
       Insert an existing FhirMedicationPackageContent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPackageContent);
    
    {@member Item
       Get the iIndexth FhirMedicationPackageContent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPackageContent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPackageContent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPackageContent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPackageContents[index : Integer] : TFhirMedicationPackageContent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationAdministrationDosage : TFhirElement
    Provides details of how much of the medication was administered.
  }
  {!.Net HL7Connect.Fhir.MedicationAdministrationDosage}
  TFhirMedicationAdministrationDosage = class (TFhirBackboneElement)
  private
    FTiming : TFhirType;
    FAsNeeded : TFhirType;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FRate : TFhirRatio;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetTiming(value : TFhirType);
    Procedure SetAsNeeded(value : TFhirType);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirRatio);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationAdministrationDosage; overload;
    function Clone : TFhirMedicationAdministrationDosage; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member timing
      The timing schedule for giving the medication to the patient.  This may be a single time point (using dateTime) or it may be a start and end dateTime (Period).
    }
    property timing : TFhirType read FTiming write SetTiming;
    property timingObject : TFhirType read FTiming write SetTiming;

    {@member asNeeded
      If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    }
    property asNeeded : TFhirType read FAsNeeded write SetAsNeeded;
    property asNeededObject : TFhirType read FAsNeeded write SetAsNeeded;

    {@member site
      A coded specification of the anatomic site where the medication first entered the body.  E.g. "left arm".
    }
    property site : TFhirCodeableConcept read FSite write SetSite;
    property siteObject : TFhirCodeableConcept read FSite write SetSite;

    {@member route
      A code specifying the route or physiological path of administration of a therapeutic agent into or onto the patient.   E.g. topical, intravenous, etc.
    }
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    property routeObject : TFhirCodeableConcept read FRoute write SetRoute;

    {@member method
      A coded value indicating the method by which the medication was introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.

Terminologies used often pre-coordinate this term with the route and or form of administration.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    property methodObject : TFhirCodeableConcept read FMethod write SetMethod;

    {@member quantity
      The amount of the medication given at one administration event.   Use this value when the administration is essentially an instantaneous event such as a swallowing a tablet or giving an injection.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    property quantityObject : TFhirQuantity read FQuantity write SetQuantity;

    {@member rate
      Identifies the speed with which the medication was introduced into the patient. Typically the rate for an infusion e.g. 200ml in 2 hours.  May also expressed as a rate per unit of time such as 100ml per hour - the duration is then not specified, or is specified in the quantity.
    }
    property rate : TFhirRatio read FRate write SetRate;
    property rateObject : TFhirRatio read FRate write SetRate;

    {@member maxDosePerPeriod
      The maximum total quantity of a therapeutic substance that was administered to the patient over the specified period of time. E.g. 1000mg in 24 hours.
    }
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;
    property maxDosePerPeriodObject : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;


  TFhirMedicationAdministrationDosageListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMedicationAdministrationDosageList;
    function GetCurrent : TFhirMedicationAdministrationDosage;
  public
    Constructor Create(list : TFhirMedicationAdministrationDosageList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationAdministrationDosage read GetCurrent;
  end;


  {@Class TFhirMedicationAdministrationDosageList
    A list of FhirMedicationAdministrationDosage
  }
  {!.Net HL7Connect.Fhir.MedicationAdministrationDosageList}
  TFhirMedicationAdministrationDosageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationAdministrationDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationAdministrationDosage);
  public
    {!script hide}
    function Link : TFhirMedicationAdministrationDosageList; Overload;
    function Clone : TFhirMedicationAdministrationDosageList; Overload;
    function GetEnumerator : TFhirMedicationAdministrationDosageListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMedicationAdministrationDosage to the end of the list.
    }
    function Append : TFhirMedicationAdministrationDosage;

    
    {@member AddItem
      Add an already existing FhirMedicationAdministrationDosage to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationAdministrationDosage); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationAdministrationDosage) : Integer;
    

    {@member Insert
      Insert FhirMedicationAdministrationDosage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationAdministrationDosage;
    

    {@member InsertItem
       Insert an existing FhirMedicationAdministrationDosage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationAdministrationDosage);
    
    {@member Item
       Get the iIndexth FhirMedicationAdministrationDosage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationAdministrationDosage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationAdministrationDosage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationAdministrationDosage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationAdministrationDosages[index : Integer] : TFhirMedicationAdministrationDosage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationDispenseDispense : TFhirElement
    Indicates the details of the dispense event such as the days supply and quantity of medication dispensed.
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseDispense}
  TFhirMedicationDispenseDispense = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FMedication : TFhirResourceReference{TFhirMedication};
    FWhenPrepared : TFhirDateTime;
    FWhenHandedOver : TFhirDateTime;
    FDestination : TFhirResourceReference{TFhirLocation};
    FreceiverList : TFhirResourceReferenceList{Resource};
    FdosageList : TFhirMedicationDispenseDispenseDosageList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMedicationDispenseStatus;
    Procedure SetStatusST(value : TFhirMedicationDispenseStatus);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetMedication(value : TFhirResourceReference{TFhirMedication});
    Procedure SetWhenPrepared(value : TFhirDateTime);
    Function GetWhenPreparedST : TDateTimeEx;
    Procedure SetWhenPreparedST(value : TDateTimeEx);
    Procedure SetWhenHandedOver(value : TFhirDateTime);
    Function GetWhenHandedOverST : TDateTimeEx;
    Procedure SetWhenHandedOverST(value : TDateTimeEx);
    Procedure SetDestination(value : TFhirResourceReference{TFhirLocation});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationDispenseDispense; overload;
    function Clone : TFhirMedicationDispenseDispense; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member identifier
      Identifier assigned by the dispensing facility.   This is an identifier assigned outside FHIR.
    }
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    property identifierObject : TFhirIdentifier read FIdentifier write SetIdentifier;

    {@member status
      A code specifying the state of the dispense event.
    }
    property status : TFhirMedicationDispenseStatus read GetStatusST write SetStatusST;
    property statusObject : TFhirEnum read FStatus write SetStatus;

    {@member type_
      Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    property type_Object : TFhirCodeableConcept read FType_ write SetType_;

    {@member quantity
      The amount of medication that has been dispensed. Includes unit of measure.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    property quantityObject : TFhirQuantity read FQuantity write SetQuantity;

    {@member medication
      Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    }
    property medication : TFhirResourceReference{TFhirMedication} read FMedication write SetMedication;
    property medicationObject : TFhirResourceReference{TFhirMedication} read FMedication write SetMedication;

    {@member whenPrepared
      The time when the dispensed product was packaged and reviewed.
    }
    {@member whenPrepared
      Typed access to The time when the dispensed product was packaged and reviewed.
    }
    property whenPrepared : TDateTimeEx read GetWhenPreparedST write SetWhenPreparedST;
    property whenPreparedObject : TFhirDateTime read FWhenPrepared write SetWhenPrepared;

    {@member whenHandedOver
      The time the dispensed product was provided to the patient or their representative.
    }
    {@member whenHandedOver
      Typed access to The time the dispensed product was provided to the patient or their representative.
    }
    property whenHandedOver : TDateTimeEx read GetWhenHandedOverST write SetWhenHandedOverST;
    property whenHandedOverObject : TFhirDateTime read FWhenHandedOver write SetWhenHandedOver;

    {@member destination
      Identification of the facility/location where the medication was shipped to, as part of the dispense event.
    }
    property destination : TFhirResourceReference{TFhirLocation} read FDestination write SetDestination;
    property destinationObject : TFhirResourceReference{TFhirLocation} read FDestination write SetDestination;

    {@member receiverList
      Identifies the person who picked up the medication.  This will usually be a patient or their carer, but some cases exist where it can be a healthcare professional.
    }
    property receiverList : TFhirResourceReferenceList{Resource} read FReceiverList;

    {@member dosageList
      Indicates how the medication is to be used by the patient.
    }
    property dosageList : TFhirMedicationDispenseDispenseDosageList read FDosageList;

  end;


  TFhirMedicationDispenseDispenseListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispenseDispenseList;
    function GetCurrent : TFhirMedicationDispenseDispense;
  public
    Constructor Create(list : TFhirMedicationDispenseDispenseList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispenseDispense read GetCurrent;
  end;


  {@Class TFhirMedicationDispenseDispenseList
    A list of FhirMedicationDispenseDispense
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseDispenseList}
  TFhirMedicationDispenseDispenseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispenseDispense;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispenseDispense);
  public
    {!script hide}
    function Link : TFhirMedicationDispenseDispenseList; Overload;
    function Clone : TFhirMedicationDispenseDispenseList; Overload;
    function GetEnumerator : TFhirMedicationDispenseDispenseListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMedicationDispenseDispense to the end of the list.
    }
    function Append : TFhirMedicationDispenseDispense;

    
    {@member AddItem
      Add an already existing FhirMedicationDispenseDispense to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationDispenseDispense); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationDispenseDispense) : Integer;
    

    {@member Insert
      Insert FhirMedicationDispenseDispense before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationDispenseDispense;
    

    {@member InsertItem
       Insert an existing FhirMedicationDispenseDispense before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationDispenseDispense);
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseDispense. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseDispense. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispenseDispense);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationDispenseDispense;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationDispenseDispenses[index : Integer] : TFhirMedicationDispenseDispense read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationDispenseDispenseDosage : TFhirElement
    Indicates how the medication is to be used by the patient.
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseDispenseDosage}
  TFhirMedicationDispenseDispenseDosage = class (TFhirBackboneElement)
  private
    FAdditionalInstructions : TFhirCodeableConcept;
    FTiming : TFhirType;
    FAsNeeded : TFhirType;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FRate : TFhirRatio;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetAdditionalInstructions(value : TFhirCodeableConcept);
    Procedure SetTiming(value : TFhirType);
    Procedure SetAsNeeded(value : TFhirType);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirRatio);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationDispenseDispenseDosage; overload;
    function Clone : TFhirMedicationDispenseDispenseDosage; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member additionalInstructions
      Additional instructions such as "Swallow with plenty of water" which may or may not be coded.
    }
    property additionalInstructions : TFhirCodeableConcept read FAdditionalInstructions write SetAdditionalInstructions;
    property additionalInstructionsObject : TFhirCodeableConcept read FAdditionalInstructions write SetAdditionalInstructions;

    {@member timing
      The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    }
    property timing : TFhirType read FTiming write SetTiming;
    property timingObject : TFhirType read FTiming write SetTiming;

    {@member asNeeded
      If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    }
    property asNeeded : TFhirType read FAsNeeded write SetAsNeeded;
    property asNeededObject : TFhirType read FAsNeeded write SetAsNeeded;

    {@member site
      A coded specification of the anatomic site where the medication first enters the body.
    }
    property site : TFhirCodeableConcept read FSite write SetSite;
    property siteObject : TFhirCodeableConcept read FSite write SetSite;

    {@member route
      A code specifying the route or physiological path of administration of a therapeutic agent into or onto a subject.
    }
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    property routeObject : TFhirCodeableConcept read FRoute write SetRoute;

    {@member method
      A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.

Terminologies used often pre-coordinate this term with the route and or form of administration.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    property methodObject : TFhirCodeableConcept read FMethod write SetMethod;

    {@member quantity
      The amount of therapeutic or other substance given at one administration event.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    property quantityObject : TFhirQuantity read FQuantity write SetQuantity;

    {@member rate
      Identifies the speed with which the substance is introduced into the subject. Typically the rate for an infusion. 200ml in 2 hours.
    }
    property rate : TFhirRatio read FRate write SetRate;
    property rateObject : TFhirRatio read FRate write SetRate;

    {@member maxDosePerPeriod
      The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time,  e.g. 1000mg in 24 hours.
    }
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;
    property maxDosePerPeriodObject : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;


  TFhirMedicationDispenseDispenseDosageListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispenseDispenseDosageList;
    function GetCurrent : TFhirMedicationDispenseDispenseDosage;
  public
    Constructor Create(list : TFhirMedicationDispenseDispenseDosageList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispenseDispenseDosage read GetCurrent;
  end;


  {@Class TFhirMedicationDispenseDispenseDosageList
    A list of FhirMedicationDispenseDispenseDosage
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseDispenseDosageList}
  TFhirMedicationDispenseDispenseDosageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispenseDispenseDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispenseDispenseDosage);
  public
    {!script hide}
    function Link : TFhirMedicationDispenseDispenseDosageList; Overload;
    function Clone : TFhirMedicationDispenseDispenseDosageList; Overload;
    function GetEnumerator : TFhirMedicationDispenseDispenseDosageListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMedicationDispenseDispenseDosage to the end of the list.
    }
    function Append : TFhirMedicationDispenseDispenseDosage;

    
    {@member AddItem
      Add an already existing FhirMedicationDispenseDispenseDosage to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationDispenseDispenseDosage); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationDispenseDispenseDosage) : Integer;
    

    {@member Insert
      Insert FhirMedicationDispenseDispenseDosage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationDispenseDispenseDosage;
    

    {@member InsertItem
       Insert an existing FhirMedicationDispenseDispenseDosage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationDispenseDispenseDosage);
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseDispenseDosage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseDispenseDosage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispenseDispenseDosage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationDispenseDispenseDosage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationDispenseDispenseDosages[index : Integer] : TFhirMedicationDispenseDispenseDosage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationDispenseSubstitution : TFhirElement
    Indicates whether or not substitution was made as part of the dispense.  In some cases substitution will be expected but doesn't happen, in other cases substitution is not expected but does happen.  This block explains what substitition did or did not happen and why.
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseSubstitution}
  TFhirMedicationDispenseSubstitution = class (TFhirBackboneElement)
  private
    FType_ : TFhirCodeableConcept;
    FreasonList : TFhirCodeableConceptList;
    FresponsiblePartyList : TFhirResourceReferenceList{TFhirPractitioner};
    Procedure SetType_(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationDispenseSubstitution; overload;
    function Clone : TFhirMedicationDispenseSubstitution; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member type_
      A code signifying whether a different drug was dispensed from what was prescribed.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    property type_Object : TFhirCodeableConcept read FType_ write SetType_;

    {@member reasonList
      Indicates the reason for the substitution of (or lack of substitution) from what was prescribed.
    }
    property reasonList : TFhirCodeableConceptList read FReasonList;

    {@member responsiblePartyList
      The person or organization that has primary responsibility for the substitution.
    }
    property responsiblePartyList : TFhirResourceReferenceList{TFhirPractitioner} read FResponsiblePartyList;

  end;


  TFhirMedicationDispenseSubstitutionListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispenseSubstitutionList;
    function GetCurrent : TFhirMedicationDispenseSubstitution;
  public
    Constructor Create(list : TFhirMedicationDispenseSubstitutionList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispenseSubstitution read GetCurrent;
  end;


  {@Class TFhirMedicationDispenseSubstitutionList
    A list of FhirMedicationDispenseSubstitution
  }
  {!.Net HL7Connect.Fhir.MedicationDispenseSubstitutionList}
  TFhirMedicationDispenseSubstitutionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispenseSubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispenseSubstitution);
  public
    {!script hide}
    function Link : TFhirMedicationDispenseSubstitutionList; Overload;
    function Clone : TFhirMedicationDispenseSubstitutionList; Overload;
    function GetEnumerator : TFhirMedicationDispenseSubstitutionListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMedicationDispenseSubstitution to the end of the list.
    }
    function Append : TFhirMedicationDispenseSubstitution;

    
    {@member AddItem
      Add an already existing FhirMedicationDispenseSubstitution to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationDispenseSubstitution); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationDispenseSubstitution) : Integer;
    

    {@member Insert
      Insert FhirMedicationDispenseSubstitution before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationDispenseSubstitution;
    

    {@member InsertItem
       Insert an existing FhirMedicationDispenseSubstitution before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationDispenseSubstitution);
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseSubstitution. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationDispenseSubstitution. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispenseSubstitution);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationDispenseSubstitution;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationDispenseSubstitutions[index : Integer] : TFhirMedicationDispenseSubstitution read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPrescriptionDosageInstruction : TFhirElement
    Indicates how the medication is to be used by the patient.
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionDosageInstruction}
  TFhirMedicationPrescriptionDosageInstruction = class (TFhirBackboneElement)
  private
    FText : TFhirString;
    FAdditionalInstructions : TFhirCodeableConcept;
    FTiming : TFhirType;
    FAsNeeded : TFhirType;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FDoseQuantity : TFhirQuantity;
    FRate : TFhirRatio;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetAdditionalInstructions(value : TFhirCodeableConcept);
    Procedure SetTiming(value : TFhirType);
    Procedure SetAsNeeded(value : TFhirType);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetDoseQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirRatio);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPrescriptionDosageInstruction; overload;
    function Clone : TFhirMedicationPrescriptionDosageInstruction; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member text
      Free text dosage instructions for cases where the instructions are too complex to code.
    }
    {@member text
      Typed access to Free text dosage instructions for cases where the instructions are too complex to code.
    }
    property text : String read GetTextST write SetTextST;
    property textObject : TFhirString read FText write SetText;

    {@member additionalInstructions
      Additional instructions such as "Swallow with plenty of water" which may or may not be coded.
    }
    property additionalInstructions : TFhirCodeableConcept read FAdditionalInstructions write SetAdditionalInstructions;
    property additionalInstructionsObject : TFhirCodeableConcept read FAdditionalInstructions write SetAdditionalInstructions;

    {@member timing
      The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    }
    property timing : TFhirType read FTiming write SetTiming;
    property timingObject : TFhirType read FTiming write SetTiming;

    {@member asNeeded
      If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    }
    property asNeeded : TFhirType read FAsNeeded write SetAsNeeded;
    property asNeededObject : TFhirType read FAsNeeded write SetAsNeeded;

    {@member site
      A coded specification of the anatomic site where the medication first enters the body.
    }
    property site : TFhirCodeableConcept read FSite write SetSite;
    property siteObject : TFhirCodeableConcept read FSite write SetSite;

    {@member route
      A code specifying the route or physiological path of administration of a therapeutic agent into or onto a patient.
    }
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    property routeObject : TFhirCodeableConcept read FRoute write SetRoute;

    {@member method
      A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.

Terminologies used often pre-coordinate this term with the route and or form of administration.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    property methodObject : TFhirCodeableConcept read FMethod write SetMethod;

    {@member doseQuantity
      The amount of therapeutic or other substance given at one administration event.
    }
    property doseQuantity : TFhirQuantity read FDoseQuantity write SetDoseQuantity;
    property doseQuantityObject : TFhirQuantity read FDoseQuantity write SetDoseQuantity;

    {@member rate
      Identifies the speed with which the substance is introduced into the subject. Typically the rate for an infusion. 200ml in 2 hours.
    }
    property rate : TFhirRatio read FRate write SetRate;
    property rateObject : TFhirRatio read FRate write SetRate;

    {@member maxDosePerPeriod
      The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time. E.g. 1000mg in 24 hours.
    }
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;
    property maxDosePerPeriodObject : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;


  TFhirMedicationPrescriptionDosageInstructionListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMedicationPrescriptionDosageInstructionList;
    function GetCurrent : TFhirMedicationPrescriptionDosageInstruction;
  public
    Constructor Create(list : TFhirMedicationPrescriptionDosageInstructionList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationPrescriptionDosageInstruction read GetCurrent;
  end;


  {@Class TFhirMedicationPrescriptionDosageInstructionList
    A list of FhirMedicationPrescriptionDosageInstruction
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionDosageInstructionList}
  TFhirMedicationPrescriptionDosageInstructionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPrescriptionDosageInstruction;
    procedure SetItemN(index : Integer; value : TFhirMedicationPrescriptionDosageInstruction);
  public
    {!script hide}
    function Link : TFhirMedicationPrescriptionDosageInstructionList; Overload;
    function Clone : TFhirMedicationPrescriptionDosageInstructionList; Overload;
    function GetEnumerator : TFhirMedicationPrescriptionDosageInstructionListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPrescriptionDosageInstruction to the end of the list.
    }
    function Append : TFhirMedicationPrescriptionDosageInstruction;

    
    {@member AddItem
      Add an already existing FhirMedicationPrescriptionDosageInstruction to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPrescriptionDosageInstruction); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPrescriptionDosageInstruction) : Integer;
    

    {@member Insert
      Insert FhirMedicationPrescriptionDosageInstruction before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPrescriptionDosageInstruction;
    

    {@member InsertItem
       Insert an existing FhirMedicationPrescriptionDosageInstruction before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPrescriptionDosageInstruction);
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionDosageInstruction. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionDosageInstruction. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPrescriptionDosageInstruction);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPrescriptionDosageInstruction;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPrescriptionDosageInstructions[index : Integer] : TFhirMedicationPrescriptionDosageInstruction read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPrescriptionDispense : TFhirElement
    Deals with details of the dispense part of the order.
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionDispense}
  TFhirMedicationPrescriptionDispense = class (TFhirBackboneElement)
  private
    FMedication : TFhirResourceReference{TFhirMedication};
    FValidityPeriod : TFhirPeriod;
    FNumberOfRepeatsAllowed : TFhirInteger;
    FQuantity : TFhirQuantity;
    FExpectedSupplyDuration : TFhirQuantity;
    Procedure SetMedication(value : TFhirResourceReference{TFhirMedication});
    Procedure SetValidityPeriod(value : TFhirPeriod);
    Procedure SetNumberOfRepeatsAllowed(value : TFhirInteger);
    Function GetNumberOfRepeatsAllowedST : String;
    Procedure SetNumberOfRepeatsAllowedST(value : String);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetExpectedSupplyDuration(value : TFhirQuantity);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPrescriptionDispense; overload;
    function Clone : TFhirMedicationPrescriptionDispense; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member medication
      Identifies the medication that is to be dispensed.  This may be a more specifically defined than the medicationPrescription.medication . This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    }
    property medication : TFhirResourceReference{TFhirMedication} read FMedication write SetMedication;
    property medicationObject : TFhirResourceReference{TFhirMedication} read FMedication write SetMedication;

    {@member validityPeriod
      Design Comments: This indicates the validity period of a prescription (stale dating the Prescription) 
It reflects the prescriber perspective for the validity of the prescription. Dispenses must not be made against the prescription outside of this period. The lower-bound of the Dispensing Window signifies the earliest date that the prescription can be filled for the first time. If an upper-bound is not specified then the Prescription is open-ended or will default to a stale-date based on regulations. 
Rationale: Indicates when the Prescription becomes valid, and when it ceases to be a dispensable Prescription.
    }
    property validityPeriod : TFhirPeriod read FValidityPeriod write SetValidityPeriod;
    property validityPeriodObject : TFhirPeriod read FValidityPeriod write SetValidityPeriod;

    {@member numberOfRepeatsAllowed
      An integer indicating the number of repeats of the Dispense. 
UsageNotes: For example, the number of times the prescribed quantity is to be supplied including the initial standard fill.
    }
    {@member numberOfRepeatsAllowed
      Typed access to An integer indicating the number of repeats of the Dispense. 
UsageNotes: For example, the number of times the prescribed quantity is to be supplied including the initial standard fill.
    }
    property numberOfRepeatsAllowed : String read GetNumberOfRepeatsAllowedST write SetNumberOfRepeatsAllowedST;
    property numberOfRepeatsAllowedObject : TFhirInteger read FNumberOfRepeatsAllowed write SetNumberOfRepeatsAllowed;

    {@member quantity
      The amount that is to be dispensed.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    property quantityObject : TFhirQuantity read FQuantity write SetQuantity;

    {@member expectedSupplyDuration
      Identifies the period time over which the supplied product is expected to be used, or the length of time the dispense is expected to last. 
In some situations, this attribute may be used instead of quantity to identify the amount supplied by how long it is expected to last, rather than the physical quantity issued, e.g. 90 days supply of medication (based on an ordered dosage) When possible, it is always better to specify quantity, as this tends to be more precise. expectedSupplyDuration will always be an estimate that can be influenced by external factors.
    }
    property expectedSupplyDuration : TFhirQuantity read FExpectedSupplyDuration write SetExpectedSupplyDuration;
    property expectedSupplyDurationObject : TFhirQuantity read FExpectedSupplyDuration write SetExpectedSupplyDuration;

  end;


  TFhirMedicationPrescriptionDispenseListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMedicationPrescriptionDispenseList;
    function GetCurrent : TFhirMedicationPrescriptionDispense;
  public
    Constructor Create(list : TFhirMedicationPrescriptionDispenseList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationPrescriptionDispense read GetCurrent;
  end;


  {@Class TFhirMedicationPrescriptionDispenseList
    A list of FhirMedicationPrescriptionDispense
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionDispenseList}
  TFhirMedicationPrescriptionDispenseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPrescriptionDispense;
    procedure SetItemN(index : Integer; value : TFhirMedicationPrescriptionDispense);
  public
    {!script hide}
    function Link : TFhirMedicationPrescriptionDispenseList; Overload;
    function Clone : TFhirMedicationPrescriptionDispenseList; Overload;
    function GetEnumerator : TFhirMedicationPrescriptionDispenseListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPrescriptionDispense to the end of the list.
    }
    function Append : TFhirMedicationPrescriptionDispense;

    
    {@member AddItem
      Add an already existing FhirMedicationPrescriptionDispense to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPrescriptionDispense); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPrescriptionDispense) : Integer;
    

    {@member Insert
      Insert FhirMedicationPrescriptionDispense before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPrescriptionDispense;
    

    {@member InsertItem
       Insert an existing FhirMedicationPrescriptionDispense before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPrescriptionDispense);
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionDispense. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionDispense. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPrescriptionDispense);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPrescriptionDispense;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPrescriptionDispenses[index : Integer] : TFhirMedicationPrescriptionDispense read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationPrescriptionSubstitution : TFhirElement
    Indicates whether or not substitution can or should be part of the dispense. In some cases substitution must happen, in other cases substitution must not happen, and in others it does not matter. This block explains the prescriber's intent. If nothing is specified substitution may be done.
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionSubstitution}
  TFhirMedicationPrescriptionSubstitution = class (TFhirBackboneElement)
  private
    FType_ : TFhirCodeableConcept;
    FReason : TFhirCodeableConcept;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetReason(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationPrescriptionSubstitution; overload;
    function Clone : TFhirMedicationPrescriptionSubstitution; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member type_
      A code signifying whether a different drug should be dispensed from what was prescribed.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    property type_Object : TFhirCodeableConcept read FType_ write SetType_;

    {@member reason
      Indicates the reason for the substitution, or why substitution must or must not be performed.
    }
    property reason : TFhirCodeableConcept read FReason write SetReason;
    property reasonObject : TFhirCodeableConcept read FReason write SetReason;

  end;


  TFhirMedicationPrescriptionSubstitutionListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMedicationPrescriptionSubstitutionList;
    function GetCurrent : TFhirMedicationPrescriptionSubstitution;
  public
    Constructor Create(list : TFhirMedicationPrescriptionSubstitutionList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationPrescriptionSubstitution read GetCurrent;
  end;


  {@Class TFhirMedicationPrescriptionSubstitutionList
    A list of FhirMedicationPrescriptionSubstitution
  }
  {!.Net HL7Connect.Fhir.MedicationPrescriptionSubstitutionList}
  TFhirMedicationPrescriptionSubstitutionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationPrescriptionSubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationPrescriptionSubstitution);
  public
    {!script hide}
    function Link : TFhirMedicationPrescriptionSubstitutionList; Overload;
    function Clone : TFhirMedicationPrescriptionSubstitutionList; Overload;
    function GetEnumerator : TFhirMedicationPrescriptionSubstitutionListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMedicationPrescriptionSubstitution to the end of the list.
    }
    function Append : TFhirMedicationPrescriptionSubstitution;

    
    {@member AddItem
      Add an already existing FhirMedicationPrescriptionSubstitution to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationPrescriptionSubstitution); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationPrescriptionSubstitution) : Integer;
    

    {@member Insert
      Insert FhirMedicationPrescriptionSubstitution before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationPrescriptionSubstitution;
    

    {@member InsertItem
       Insert an existing FhirMedicationPrescriptionSubstitution before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationPrescriptionSubstitution);
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionSubstitution. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationPrescriptionSubstitution. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPrescriptionSubstitution);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationPrescriptionSubstitution;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationPrescriptionSubstitutions[index : Integer] : TFhirMedicationPrescriptionSubstitution read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMedicationStatementDosage : TFhirElement
    Indicates how the medication is/was used by the patient.
  }
  {!.Net HL7Connect.Fhir.MedicationStatementDosage}
  TFhirMedicationStatementDosage = class (TFhirBackboneElement)
  private
    FTiming : TFhirSchedule;
    FAsNeeded : TFhirType;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FRate : TFhirRatio;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetTiming(value : TFhirSchedule);
    Procedure SetAsNeeded(value : TFhirType);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirRatio);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMedicationStatementDosage; overload;
    function Clone : TFhirMedicationStatementDosage; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member timing
      The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    }
    property timing : TFhirSchedule read FTiming write SetTiming;
    property timingObject : TFhirSchedule read FTiming write SetTiming;

    {@member asNeeded
      If set to true or if specified as a CodeableConcept, indicates that the medication is only taken when needed within the specified schedule rather than at every scheduled dose.  If a CodeableConcept is present, it indicates the pre-condition for taking the Medication.
    }
    property asNeeded : TFhirType read FAsNeeded write SetAsNeeded;
    property asNeededObject : TFhirType read FAsNeeded write SetAsNeeded;

    {@member site
      A coded specification of the anatomic site where the medication first enters the body.
    }
    property site : TFhirCodeableConcept read FSite write SetSite;
    property siteObject : TFhirCodeableConcept read FSite write SetSite;

    {@member route
      A code specifying the route or physiological path of administration of a therapeutic agent into or onto a subject.
    }
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    property routeObject : TFhirCodeableConcept read FRoute write SetRoute;

    {@member method
      A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  Examples:  Slow Push; Deep IV.

Terminologies used often pre-coordinate this term with the route and or form of administration.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    property methodObject : TFhirCodeableConcept read FMethod write SetMethod;

    {@member quantity
      The amount of therapeutic or other substance given at one administration event.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    property quantityObject : TFhirQuantity read FQuantity write SetQuantity;

    {@member rate
      Identifies the speed with which the substance is introduced into the subject. Typically the rate for an infusion. 200ml in 2 hours.
    }
    property rate : TFhirRatio read FRate write SetRate;
    property rateObject : TFhirRatio read FRate write SetRate;

    {@member maxDosePerPeriod
      The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time. E.g. 1000mg in 24 hours.
    }
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;
    property maxDosePerPeriodObject : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;


  TFhirMedicationStatementDosageListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMedicationStatementDosageList;
    function GetCurrent : TFhirMedicationStatementDosage;
  public
    Constructor Create(list : TFhirMedicationStatementDosageList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationStatementDosage read GetCurrent;
  end;


  {@Class TFhirMedicationStatementDosageList
    A list of FhirMedicationStatementDosage
  }
  {!.Net HL7Connect.Fhir.MedicationStatementDosageList}
  TFhirMedicationStatementDosageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationStatementDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationStatementDosage);
  public
    {!script hide}
    function Link : TFhirMedicationStatementDosageList; Overload;
    function Clone : TFhirMedicationStatementDosageList; Overload;
    function GetEnumerator : TFhirMedicationStatementDosageListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMedicationStatementDosage to the end of the list.
    }
    function Append : TFhirMedicationStatementDosage;

    
    {@member AddItem
      Add an already existing FhirMedicationStatementDosage to the end of the list.
    }
    procedure AddItem(value : TFhirMedicationStatementDosage); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMedicationStatementDosage) : Integer;
    

    {@member Insert
      Insert FhirMedicationStatementDosage before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMedicationStatementDosage;
    

    {@member InsertItem
       Insert an existing FhirMedicationStatementDosage before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMedicationStatementDosage);
    
    {@member Item
       Get the iIndexth FhirMedicationStatementDosage. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMedicationStatementDosage. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationStatementDosage);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMedicationStatementDosage;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMedicationStatementDosages[index : Integer] : TFhirMedicationStatementDosage read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMessageHeaderResponse : TFhirElement
    Information about the message that this message is a response to.  Only present if this message is a response.
  }
  {!.Net HL7Connect.Fhir.MessageHeaderResponse}
  TFhirMessageHeaderResponse = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirId;
    FCode : TFhirEnum;
    FDetails : TFhirResourceReference{TFhirOperationOutcome};
    Procedure SetIdentifier(value : TFhirId);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirResponseCode;
    Procedure SetCodeST(value : TFhirResponseCode);
    Procedure SetDetails(value : TFhirResourceReference{TFhirOperationOutcome});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMessageHeaderResponse; overload;
    function Clone : TFhirMessageHeaderResponse; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member identifier
      The id of the message that this message is a response to.
    }
    {@member identifier
      Typed access to The id of the message that this message is a response to.
    }
    property identifier : String read GetIdentifierST write SetIdentifierST;
    property identifierObject : TFhirId read FIdentifier write SetIdentifier;

    {@member code
      Code that identifies the type of response to the message - whether it was successful or not, and whether it should be resent or not.
    }
    property code : TFhirResponseCode read GetCodeST write SetCodeST;
    property codeObject : TFhirEnum read FCode write SetCode;

    {@member details
      Full details of any issues found in the message.
    }
    property details : TFhirResourceReference{TFhirOperationOutcome} read FDetails write SetDetails;
    property detailsObject : TFhirResourceReference{TFhirOperationOutcome} read FDetails write SetDetails;

  end;


  TFhirMessageHeaderResponseListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderResponseList;
    function GetCurrent : TFhirMessageHeaderResponse;
  public
    Constructor Create(list : TFhirMessageHeaderResponseList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderResponse read GetCurrent;
  end;


  {@Class TFhirMessageHeaderResponseList
    A list of FhirMessageHeaderResponse
  }
  {!.Net HL7Connect.Fhir.MessageHeaderResponseList}
  TFhirMessageHeaderResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageHeaderResponse;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderResponse);
  public
    {!script hide}
    function Link : TFhirMessageHeaderResponseList; Overload;
    function Clone : TFhirMessageHeaderResponseList; Overload;
    function GetEnumerator : TFhirMessageHeaderResponseListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMessageHeaderResponse to the end of the list.
    }
    function Append : TFhirMessageHeaderResponse;

    
    {@member AddItem
      Add an already existing FhirMessageHeaderResponse to the end of the list.
    }
    procedure AddItem(value : TFhirMessageHeaderResponse); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMessageHeaderResponse) : Integer;
    

    {@member Insert
      Insert FhirMessageHeaderResponse before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMessageHeaderResponse;
    

    {@member InsertItem
       Insert an existing FhirMessageHeaderResponse before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderResponse);
    
    {@member Item
       Get the iIndexth FhirMessageHeaderResponse. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMessageHeaderResponse. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderResponse);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMessageHeaderResponse;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMessageHeaderResponses[index : Integer] : TFhirMessageHeaderResponse read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMessageHeaderSource : TFhirElement
    The source application from which this message originated.
  }
  {!.Net HL7Connect.Fhir.MessageHeaderSource}
  TFhirMessageHeaderSource = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FSoftware : TFhirString;
    FVersion : TFhirString;
    FContact : TFhirContact;
    FEndpoint : TFhirUri;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSoftware(value : TFhirString);
    Function GetSoftwareST : String;
    Procedure SetSoftwareST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetContact(value : TFhirContact);
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMessageHeaderSource; overload;
    function Clone : TFhirMessageHeaderSource; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member name
      Human-readable name for the target system.
    }
    {@member name
      Typed access to Human-readable name for the target system.
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member software
      May include configuration or other information useful in debugging.
    }
    {@member software
      Typed access to May include configuration or other information useful in debugging.
    }
    property software : String read GetSoftwareST write SetSoftwareST;
    property softwareObject : TFhirString read FSoftware write SetSoftware;

    {@member version
      Can convey versions of multiple systems in situations where a message passes through multiple hands.
    }
    {@member version
      Typed access to Can convey versions of multiple systems in situations where a message passes through multiple hands.
    }
    property version : String read GetVersionST write SetVersionST;
    property versionObject : TFhirString read FVersion write SetVersion;

    {@member contact
      An e-mail, phone, website or other contact point to use to resolve issues with message communications.
    }
    property contact : TFhirContact read FContact write SetContact;
    property contactObject : TFhirContact read FContact write SetContact;

    {@member endpoint
      Identifies the routing target to send acknowledgements to.
    }
    {@member endpoint
      Typed access to Identifies the routing target to send acknowledgements to.
    }
    property endpoint : String read GetEndpointST write SetEndpointST;
    property endpointObject : TFhirUri read FEndpoint write SetEndpoint;

  end;


  TFhirMessageHeaderSourceListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderSourceList;
    function GetCurrent : TFhirMessageHeaderSource;
  public
    Constructor Create(list : TFhirMessageHeaderSourceList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderSource read GetCurrent;
  end;


  {@Class TFhirMessageHeaderSourceList
    A list of FhirMessageHeaderSource
  }
  {!.Net HL7Connect.Fhir.MessageHeaderSourceList}
  TFhirMessageHeaderSourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageHeaderSource;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderSource);
  public
    {!script hide}
    function Link : TFhirMessageHeaderSourceList; Overload;
    function Clone : TFhirMessageHeaderSourceList; Overload;
    function GetEnumerator : TFhirMessageHeaderSourceListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMessageHeaderSource to the end of the list.
    }
    function Append : TFhirMessageHeaderSource;

    
    {@member AddItem
      Add an already existing FhirMessageHeaderSource to the end of the list.
    }
    procedure AddItem(value : TFhirMessageHeaderSource); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMessageHeaderSource) : Integer;
    

    {@member Insert
      Insert FhirMessageHeaderSource before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMessageHeaderSource;
    

    {@member InsertItem
       Insert an existing FhirMessageHeaderSource before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderSource);
    
    {@member Item
       Get the iIndexth FhirMessageHeaderSource. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMessageHeaderSource. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderSource);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMessageHeaderSource;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMessageHeaderSources[index : Integer] : TFhirMessageHeaderSource read GetItemN write SetItemN; default;
  End;


  {@Class TFhirMessageHeaderDestination : TFhirElement
    The destination application which the message is intended for.
  }
  {!.Net HL7Connect.Fhir.MessageHeaderDestination}
  TFhirMessageHeaderDestination = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FTarget : TFhirResourceReference{TFhirDevice};
    FEndpoint : TFhirUri;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetTarget(value : TFhirResourceReference{TFhirDevice});
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirMessageHeaderDestination; overload;
    function Clone : TFhirMessageHeaderDestination; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member name
      Human-readable name for the source system.
    }
    {@member name
      Typed access to Human-readable name for the source system.
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member target
      Identifies the target end system in situations where the initial message transmission is to an intermediary system.
    }
    property target : TFhirResourceReference{TFhirDevice} read FTarget write SetTarget;
    property targetObject : TFhirResourceReference{TFhirDevice} read FTarget write SetTarget;

    {@member endpoint
      Indicates where the message should be routed to.
    }
    {@member endpoint
      Typed access to Indicates where the message should be routed to.
    }
    property endpoint : String read GetEndpointST write SetEndpointST;
    property endpointObject : TFhirUri read FEndpoint write SetEndpoint;

  end;


  TFhirMessageHeaderDestinationListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderDestinationList;
    function GetCurrent : TFhirMessageHeaderDestination;
  public
    Constructor Create(list : TFhirMessageHeaderDestinationList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderDestination read GetCurrent;
  end;


  {@Class TFhirMessageHeaderDestinationList
    A list of FhirMessageHeaderDestination
  }
  {!.Net HL7Connect.Fhir.MessageHeaderDestinationList}
  TFhirMessageHeaderDestinationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageHeaderDestination;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderDestination);
  public
    {!script hide}
    function Link : TFhirMessageHeaderDestinationList; Overload;
    function Clone : TFhirMessageHeaderDestinationList; Overload;
    function GetEnumerator : TFhirMessageHeaderDestinationListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirMessageHeaderDestination to the end of the list.
    }
    function Append : TFhirMessageHeaderDestination;

    
    {@member AddItem
      Add an already existing FhirMessageHeaderDestination to the end of the list.
    }
    procedure AddItem(value : TFhirMessageHeaderDestination); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirMessageHeaderDestination) : Integer;
    

    {@member Insert
      Insert FhirMessageHeaderDestination before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirMessageHeaderDestination;
    

    {@member InsertItem
       Insert an existing FhirMessageHeaderDestination before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderDestination);
    
    {@member Item
       Get the iIndexth FhirMessageHeaderDestination. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirMessageHeaderDestination. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderDestination);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirMessageHeaderDestination;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirMessageHeaderDestinations[index : Integer] : TFhirMessageHeaderDestination read GetItemN write SetItemN; default;
  End;


  {@Class TFhirObservationReferenceRange : TFhirElement
    Guidance on how to interpret the value by comparison to a normal or recommended range.
  }
  {!.Net HL7Connect.Fhir.ObservationReferenceRange}
  TFhirObservationReferenceRange = class (TFhirBackboneElement)
  private
    FLow : TFhirQuantity;
    FHigh : TFhirQuantity;
    FMeaning : TFhirCodeableConcept;
    FAge : TFhirRange;
    Procedure SetLow(value : TFhirQuantity);
    Procedure SetHigh(value : TFhirQuantity);
    Procedure SetMeaning(value : TFhirCodeableConcept);
    Procedure SetAge(value : TFhirRange);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirObservationReferenceRange; overload;
    function Clone : TFhirObservationReferenceRange; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member low
      The value of the low bound of the reference range. If this is omitted, the low bound of the reference range is assumed to be meaningless. E.g. <2.3.
    }
    property low : TFhirQuantity read FLow write SetLow;
    property lowObject : TFhirQuantity read FLow write SetLow;

    {@member high
      The value of the high bound of the reference range. If this is omitted, the high bound of the reference range is assumed to be meaningless. E.g. >5.
    }
    property high : TFhirQuantity read FHigh write SetHigh;
    property highObject : TFhirQuantity read FHigh write SetHigh;

    {@member meaning
      Code for the meaning of the reference range.
    }
    property meaning : TFhirCodeableConcept read FMeaning write SetMeaning;
    property meaningObject : TFhirCodeableConcept read FMeaning write SetMeaning;

    {@member age
      The age at which this reference range is applicable. This is a neonatal age (e.g. number of weeks at term) if the meaning says so.
    }
    property age : TFhirRange read FAge write SetAge;
    property ageObject : TFhirRange read FAge write SetAge;

  end;


  TFhirObservationReferenceRangeListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirObservationReferenceRangeList;
    function GetCurrent : TFhirObservationReferenceRange;
  public
    Constructor Create(list : TFhirObservationReferenceRangeList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationReferenceRange read GetCurrent;
  end;


  {@Class TFhirObservationReferenceRangeList
    A list of FhirObservationReferenceRange
  }
  {!.Net HL7Connect.Fhir.ObservationReferenceRangeList}
  TFhirObservationReferenceRangeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservationReferenceRange;
    procedure SetItemN(index : Integer; value : TFhirObservationReferenceRange);
  public
    {!script hide}
    function Link : TFhirObservationReferenceRangeList; Overload;
    function Clone : TFhirObservationReferenceRangeList; Overload;
    function GetEnumerator : TFhirObservationReferenceRangeListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirObservationReferenceRange to the end of the list.
    }
    function Append : TFhirObservationReferenceRange;

    
    {@member AddItem
      Add an already existing FhirObservationReferenceRange to the end of the list.
    }
    procedure AddItem(value : TFhirObservationReferenceRange); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirObservationReferenceRange) : Integer;
    

    {@member Insert
      Insert FhirObservationReferenceRange before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirObservationReferenceRange;
    

    {@member InsertItem
       Insert an existing FhirObservationReferenceRange before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirObservationReferenceRange);
    
    {@member Item
       Get the iIndexth FhirObservationReferenceRange. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirObservationReferenceRange. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirObservationReferenceRange);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirObservationReferenceRange;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirObservationReferenceRanges[index : Integer] : TFhirObservationReferenceRange read GetItemN write SetItemN; default;
  End;


  {@Class TFhirObservationRelated : TFhirElement
    Related observations - either components, or previous observations, or statements of derivation.
  }
  {!.Net HL7Connect.Fhir.ObservationRelated}
  TFhirObservationRelated = class (TFhirBackboneElement)
  private
    FType_ : TFhirEnum;
    FTarget : TFhirResourceReference{TFhirObservation};
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirObservationRelationshiptypes;
    Procedure SetType_ST(value : TFhirObservationRelationshiptypes);
    Procedure SetTarget(value : TFhirResourceReference{TFhirObservation});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirObservationRelated; overload;
    function Clone : TFhirObservationRelated; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member type_
      A code specifying the kind of relationship that exists with the target observation.
    }
    property type_ : TFhirObservationRelationshiptypes read GetType_ST write SetType_ST;
    property type_Object : TFhirEnum read FType_ write SetType_;

    {@member target
      A reference to the observation that is related to this observation.
    }
    property target : TFhirResourceReference{TFhirObservation} read FTarget write SetTarget;
    property targetObject : TFhirResourceReference{TFhirObservation} read FTarget write SetTarget;

  end;


  TFhirObservationRelatedListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirObservationRelatedList;
    function GetCurrent : TFhirObservationRelated;
  public
    Constructor Create(list : TFhirObservationRelatedList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationRelated read GetCurrent;
  end;


  {@Class TFhirObservationRelatedList
    A list of FhirObservationRelated
  }
  {!.Net HL7Connect.Fhir.ObservationRelatedList}
  TFhirObservationRelatedList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservationRelated;
    procedure SetItemN(index : Integer; value : TFhirObservationRelated);
  public
    {!script hide}
    function Link : TFhirObservationRelatedList; Overload;
    function Clone : TFhirObservationRelatedList; Overload;
    function GetEnumerator : TFhirObservationRelatedListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirObservationRelated to the end of the list.
    }
    function Append : TFhirObservationRelated;

    
    {@member AddItem
      Add an already existing FhirObservationRelated to the end of the list.
    }
    procedure AddItem(value : TFhirObservationRelated); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirObservationRelated) : Integer;
    

    {@member Insert
      Insert FhirObservationRelated before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirObservationRelated;
    

    {@member InsertItem
       Insert an existing FhirObservationRelated before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirObservationRelated);
    
    {@member Item
       Get the iIndexth FhirObservationRelated. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirObservationRelated. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirObservationRelated);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirObservationRelated;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirObservationRelateds[index : Integer] : TFhirObservationRelated read GetItemN write SetItemN; default;
  End;


  {@Class TFhirOperationOutcomeIssue : TFhirElement
    An error, warning or information message that results from a system action.
  }
  {!.Net HL7Connect.Fhir.OperationOutcomeIssue}
  TFhirOperationOutcomeIssue = class (TFhirBackboneElement)
  private
    FSeverity : TFhirEnum;
    FType_ : TFhirCoding;
    FDetails : TFhirString;
    FlocationList : TFhirStringList;
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirIssueSeverity;
    Procedure SetSeverityST(value : TFhirIssueSeverity);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetDetails(value : TFhirString);
    Function GetDetailsST : String;
    Procedure SetDetailsST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirOperationOutcomeIssue; overload;
    function Clone : TFhirOperationOutcomeIssue; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member severity
      Indicates whether the issue indicates a variation from successful processing.
    }
    property severity : TFhirIssueSeverity read GetSeverityST write SetSeverityST;
    property severityObject : TFhirEnum read FSeverity write SetSeverity;

    {@member type_
      A code indicating the type of error, warning or information message.
    }
    property type_ : TFhirCoding read FType_ write SetType_;
    property type_Object : TFhirCoding read FType_ write SetType_;

    {@member details
      Additional description of the issue.
    }
    {@member details
      Typed access to Additional description of the issue.
    }
    property details : String read GetDetailsST write SetDetailsST;
    property detailsObject : TFhirString read FDetails write SetDetails;

    {@member locationList
      A simple XPath limited to element names, repetition indicators and the default child access that identifies one of the elements in the resource that caused this issue to be raised.
    }
    property locationList : TFhirStringList read FLocationList;

  end;


  TFhirOperationOutcomeIssueListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirOperationOutcomeIssueList;
    function GetCurrent : TFhirOperationOutcomeIssue;
  public
    Constructor Create(list : TFhirOperationOutcomeIssueList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationOutcomeIssue read GetCurrent;
  end;


  {@Class TFhirOperationOutcomeIssueList
    A list of FhirOperationOutcomeIssue
  }
  {!.Net HL7Connect.Fhir.OperationOutcomeIssueList}
  TFhirOperationOutcomeIssueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOperationOutcomeIssue;
    procedure SetItemN(index : Integer; value : TFhirOperationOutcomeIssue);
  public
    {!script hide}
    function Link : TFhirOperationOutcomeIssueList; Overload;
    function Clone : TFhirOperationOutcomeIssueList; Overload;
    function GetEnumerator : TFhirOperationOutcomeIssueListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirOperationOutcomeIssue to the end of the list.
    }
    function Append : TFhirOperationOutcomeIssue;

    
    {@member AddItem
      Add an already existing FhirOperationOutcomeIssue to the end of the list.
    }
    procedure AddItem(value : TFhirOperationOutcomeIssue); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirOperationOutcomeIssue) : Integer;
    

    {@member Insert
      Insert FhirOperationOutcomeIssue before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirOperationOutcomeIssue;
    

    {@member InsertItem
       Insert an existing FhirOperationOutcomeIssue before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirOperationOutcomeIssue);
    
    {@member Item
       Get the iIndexth FhirOperationOutcomeIssue. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirOperationOutcomeIssue. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirOperationOutcomeIssue);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirOperationOutcomeIssue;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirOperationOutcomeIssues[index : Integer] : TFhirOperationOutcomeIssue read GetItemN write SetItemN; default;
  End;


  {@Class TFhirOrderWhen : TFhirElement
    When order should be fulfilled.
  }
  {!.Net HL7Connect.Fhir.OrderWhen}
  TFhirOrderWhen = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FSchedule : TFhirSchedule;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSchedule(value : TFhirSchedule);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirOrderWhen; overload;
    function Clone : TFhirOrderWhen; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      Code specifies when request should be done. The code may simply be a priority code.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;
    property codeObject : TFhirCodeableConcept read FCode write SetCode;

    {@member schedule
      A formal schedule.
    }
    property schedule : TFhirSchedule read FSchedule write SetSchedule;
    property scheduleObject : TFhirSchedule read FSchedule write SetSchedule;

  end;


  TFhirOrderWhenListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirOrderWhenList;
    function GetCurrent : TFhirOrderWhen;
  public
    Constructor Create(list : TFhirOrderWhenList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrderWhen read GetCurrent;
  end;


  {@Class TFhirOrderWhenList
    A list of FhirOrderWhen
  }
  {!.Net HL7Connect.Fhir.OrderWhenList}
  TFhirOrderWhenList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrderWhen;
    procedure SetItemN(index : Integer; value : TFhirOrderWhen);
  public
    {!script hide}
    function Link : TFhirOrderWhenList; Overload;
    function Clone : TFhirOrderWhenList; Overload;
    function GetEnumerator : TFhirOrderWhenListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirOrderWhen to the end of the list.
    }
    function Append : TFhirOrderWhen;

    
    {@member AddItem
      Add an already existing FhirOrderWhen to the end of the list.
    }
    procedure AddItem(value : TFhirOrderWhen); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirOrderWhen) : Integer;
    

    {@member Insert
      Insert FhirOrderWhen before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirOrderWhen;
    

    {@member InsertItem
       Insert an existing FhirOrderWhen before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirOrderWhen);
    
    {@member Item
       Get the iIndexth FhirOrderWhen. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirOrderWhen. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirOrderWhen);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirOrderWhen;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirOrderWhens[index : Integer] : TFhirOrderWhen read GetItemN write SetItemN; default;
  End;


  {@Class TFhirOrganizationContact : TFhirElement
    Contact for the organization for a certain purpose.
  }
  {!.Net HL7Connect.Fhir.OrganizationContact}
  TFhirOrganizationContact = class (TFhirBackboneElement)
  private
    FPurpose : TFhirCodeableConcept;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactList;
    FAddress : TFhirAddress;
    FGender : TFhirCodeableConcept;
    Procedure SetPurpose(value : TFhirCodeableConcept);
    Procedure SetName(value : TFhirHumanName);
    Procedure SetAddress(value : TFhirAddress);
    Procedure SetGender(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirOrganizationContact; overload;
    function Clone : TFhirOrganizationContact; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member purpose
      Indicates a purpose for which the contact can be reached.
    }
    property purpose : TFhirCodeableConcept read FPurpose write SetPurpose;
    property purposeObject : TFhirCodeableConcept read FPurpose write SetPurpose;

    {@member name
      A name associated with the contact.
    }
    property name : TFhirHumanName read FName write SetName;
    property nameObject : TFhirHumanName read FName write SetName;

    {@member telecomList
      A contact detail (e.g. a telephone number or an email address) by which the party may be contacted.
    }
    property telecomList : TFhirContactList read FTelecomList;

    {@member address
      Visiting or postal addresses for the contact.
    }
    property address : TFhirAddress read FAddress write SetAddress;
    property addressObject : TFhirAddress read FAddress write SetAddress;

    {@member gender
      Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    }
    property gender : TFhirCodeableConcept read FGender write SetGender;
    property genderObject : TFhirCodeableConcept read FGender write SetGender;

  end;


  TFhirOrganizationContactListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirOrganizationContactList;
    function GetCurrent : TFhirOrganizationContact;
  public
    Constructor Create(list : TFhirOrganizationContactList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrganizationContact read GetCurrent;
  end;


  {@Class TFhirOrganizationContactList
    A list of FhirOrganizationContact
  }
  {!.Net HL7Connect.Fhir.OrganizationContactList}
  TFhirOrganizationContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrganizationContact;
    procedure SetItemN(index : Integer; value : TFhirOrganizationContact);
  public
    {!script hide}
    function Link : TFhirOrganizationContactList; Overload;
    function Clone : TFhirOrganizationContactList; Overload;
    function GetEnumerator : TFhirOrganizationContactListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirOrganizationContact to the end of the list.
    }
    function Append : TFhirOrganizationContact;

    
    {@member AddItem
      Add an already existing FhirOrganizationContact to the end of the list.
    }
    procedure AddItem(value : TFhirOrganizationContact); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirOrganizationContact) : Integer;
    

    {@member Insert
      Insert FhirOrganizationContact before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirOrganizationContact;
    

    {@member InsertItem
       Insert an existing FhirOrganizationContact before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirOrganizationContact);
    
    {@member Item
       Get the iIndexth FhirOrganizationContact. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirOrganizationContact. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirOrganizationContact);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirOrganizationContact;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirOrganizationContacts[index : Integer] : TFhirOrganizationContact read GetItemN write SetItemN; default;
  End;


  {@Class TFhirPatientContact : TFhirElement
    A contact party (e.g. guardian, partner, friend) for the patient.
  }
  {!.Net HL7Connect.Fhir.PatientContact}
  TFhirPatientContact = class (TFhirBackboneElement)
  private
    FrelationshipList : TFhirCodeableConceptList;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactList;
    FAddress : TFhirAddress;
    FGender : TFhirCodeableConcept;
    FOrganization : TFhirResourceReference{TFhirOrganization};
    Procedure SetName(value : TFhirHumanName);
    Procedure SetAddress(value : TFhirAddress);
    Procedure SetGender(value : TFhirCodeableConcept);
    Procedure SetOrganization(value : TFhirResourceReference{TFhirOrganization});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirPatientContact; overload;
    function Clone : TFhirPatientContact; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member relationshipList
      The nature of the relationship between the patient and the contact person.
    }
    property relationshipList : TFhirCodeableConceptList read FRelationshipList;

    {@member name
      A name associated with the person.
    }
    property name : TFhirHumanName read FName write SetName;
    property nameObject : TFhirHumanName read FName write SetName;

    {@member telecomList
      A contact detail for the person, e.g. a telephone number or an email address.
    }
    property telecomList : TFhirContactList read FTelecomList;

    {@member address
      Address for the contact person.
    }
    property address : TFhirAddress read FAddress write SetAddress;
    property addressObject : TFhirAddress read FAddress write SetAddress;

    {@member gender
      Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    }
    property gender : TFhirCodeableConcept read FGender write SetGender;
    property genderObject : TFhirCodeableConcept read FGender write SetGender;

    {@member organization
      Organization on behalf of which the contact is acting or for which the contact is working.
    }
    property organization : TFhirResourceReference{TFhirOrganization} read FOrganization write SetOrganization;
    property organizationObject : TFhirResourceReference{TFhirOrganization} read FOrganization write SetOrganization;

  end;


  TFhirPatientContactListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirPatientContactList;
    function GetCurrent : TFhirPatientContact;
  public
    Constructor Create(list : TFhirPatientContactList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientContact read GetCurrent;
  end;


  {@Class TFhirPatientContactList
    A list of FhirPatientContact
  }
  {!.Net HL7Connect.Fhir.PatientContactList}
  TFhirPatientContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientContact;
    procedure SetItemN(index : Integer; value : TFhirPatientContact);
  public
    {!script hide}
    function Link : TFhirPatientContactList; Overload;
    function Clone : TFhirPatientContactList; Overload;
    function GetEnumerator : TFhirPatientContactListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirPatientContact to the end of the list.
    }
    function Append : TFhirPatientContact;

    
    {@member AddItem
      Add an already existing FhirPatientContact to the end of the list.
    }
    procedure AddItem(value : TFhirPatientContact); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirPatientContact) : Integer;
    

    {@member Insert
      Insert FhirPatientContact before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirPatientContact;
    

    {@member InsertItem
       Insert an existing FhirPatientContact before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirPatientContact);
    
    {@member Item
       Get the iIndexth FhirPatientContact. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirPatientContact. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirPatientContact);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirPatientContact;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirPatientContacts[index : Integer] : TFhirPatientContact read GetItemN write SetItemN; default;
  End;


  {@Class TFhirPatientAnimal : TFhirElement
    This element has a value if the patient is an animal.
  }
  {!.Net HL7Connect.Fhir.PatientAnimal}
  TFhirPatientAnimal = class (TFhirBackboneElement)
  private
    FSpecies : TFhirCodeableConcept;
    FBreed : TFhirCodeableConcept;
    FGenderStatus : TFhirCodeableConcept;
    Procedure SetSpecies(value : TFhirCodeableConcept);
    Procedure SetBreed(value : TFhirCodeableConcept);
    Procedure SetGenderStatus(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirPatientAnimal; overload;
    function Clone : TFhirPatientAnimal; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member species
      Identifies the high level categorization of the kind of animal.
    }
    property species : TFhirCodeableConcept read FSpecies write SetSpecies;
    property speciesObject : TFhirCodeableConcept read FSpecies write SetSpecies;

    {@member breed
      Identifies the detailed categorization of the kind of animal.
    }
    property breed : TFhirCodeableConcept read FBreed write SetBreed;
    property breedObject : TFhirCodeableConcept read FBreed write SetBreed;

    {@member genderStatus
      Indicates the current state of the animal's reproductive organs.
    }
    property genderStatus : TFhirCodeableConcept read FGenderStatus write SetGenderStatus;
    property genderStatusObject : TFhirCodeableConcept read FGenderStatus write SetGenderStatus;

  end;


  TFhirPatientAnimalListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirPatientAnimalList;
    function GetCurrent : TFhirPatientAnimal;
  public
    Constructor Create(list : TFhirPatientAnimalList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientAnimal read GetCurrent;
  end;


  {@Class TFhirPatientAnimalList
    A list of FhirPatientAnimal
  }
  {!.Net HL7Connect.Fhir.PatientAnimalList}
  TFhirPatientAnimalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientAnimal;
    procedure SetItemN(index : Integer; value : TFhirPatientAnimal);
  public
    {!script hide}
    function Link : TFhirPatientAnimalList; Overload;
    function Clone : TFhirPatientAnimalList; Overload;
    function GetEnumerator : TFhirPatientAnimalListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirPatientAnimal to the end of the list.
    }
    function Append : TFhirPatientAnimal;

    
    {@member AddItem
      Add an already existing FhirPatientAnimal to the end of the list.
    }
    procedure AddItem(value : TFhirPatientAnimal); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirPatientAnimal) : Integer;
    

    {@member Insert
      Insert FhirPatientAnimal before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirPatientAnimal;
    

    {@member InsertItem
       Insert an existing FhirPatientAnimal before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirPatientAnimal);
    
    {@member Item
       Get the iIndexth FhirPatientAnimal. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirPatientAnimal. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirPatientAnimal);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirPatientAnimal;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirPatientAnimals[index : Integer] : TFhirPatientAnimal read GetItemN write SetItemN; default;
  End;


  {@Class TFhirPatientLink : TFhirElement
    Link to another patient resource that concerns the same actual person.
  }
  {!.Net HL7Connect.Fhir.PatientLink}
  TFhirPatientLink = class (TFhirBackboneElement)
  private
    FOther : TFhirResourceReference{TFhirPatient};
    FType_ : TFhirEnum;
    Procedure SetOther(value : TFhirResourceReference{TFhirPatient});
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirLinkType;
    Procedure SetType_ST(value : TFhirLinkType);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirPatientLink; overload;
    function Clone : TFhirPatientLink; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member other
      The other patient resource that the link refers to.
    }
    property other : TFhirResourceReference{TFhirPatient} read FOther write SetOther;
    property otherObject : TFhirResourceReference{TFhirPatient} read FOther write SetOther;

    {@member type_
      The type of link between this patient resource and another patient resource.
    }
    property type_ : TFhirLinkType read GetType_ST write SetType_ST;
    property type_Object : TFhirEnum read FType_ write SetType_;

  end;


  TFhirPatientLinkListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirPatientLinkList;
    function GetCurrent : TFhirPatientLink;
  public
    Constructor Create(list : TFhirPatientLinkList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientLink read GetCurrent;
  end;


  {@Class TFhirPatientLinkList
    A list of FhirPatientLink
  }
  {!.Net HL7Connect.Fhir.PatientLinkList}
  TFhirPatientLinkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientLink;
    procedure SetItemN(index : Integer; value : TFhirPatientLink);
  public
    {!script hide}
    function Link : TFhirPatientLinkList; Overload;
    function Clone : TFhirPatientLinkList; Overload;
    function GetEnumerator : TFhirPatientLinkListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirPatientLink to the end of the list.
    }
    function Append : TFhirPatientLink;

    
    {@member AddItem
      Add an already existing FhirPatientLink to the end of the list.
    }
    procedure AddItem(value : TFhirPatientLink); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirPatientLink) : Integer;
    

    {@member Insert
      Insert FhirPatientLink before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirPatientLink;
    

    {@member InsertItem
       Insert an existing FhirPatientLink before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirPatientLink);
    
    {@member Item
       Get the iIndexth FhirPatientLink. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirPatientLink. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirPatientLink);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirPatientLink;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirPatientLinks[index : Integer] : TFhirPatientLink read GetItemN write SetItemN; default;
  End;


  {@Class TFhirPractitionerQualification : TFhirElement
    Qualifications obtained by training and certification.
  }
  {!.Net HL7Connect.Fhir.PractitionerQualification}
  TFhirPractitionerQualification = class (TFhirBackboneElement)
  private
    FCode : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FIssuer : TFhirResourceReference{TFhirOrganization};
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetIssuer(value : TFhirResourceReference{TFhirOrganization});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirPractitionerQualification; overload;
    function Clone : TFhirPractitionerQualification; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      Coded representation of the qualification.
    }
    property code : TFhirCodeableConcept read FCode write SetCode;
    property codeObject : TFhirCodeableConcept read FCode write SetCode;

    {@member period
      Period during which the qualification is valid.
    }
    property period : TFhirPeriod read FPeriod write SetPeriod;
    property periodObject : TFhirPeriod read FPeriod write SetPeriod;

    {@member issuer
      Organization that regulates and issues the qualification.
    }
    property issuer : TFhirResourceReference{TFhirOrganization} read FIssuer write SetIssuer;
    property issuerObject : TFhirResourceReference{TFhirOrganization} read FIssuer write SetIssuer;

  end;


  TFhirPractitionerQualificationListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerQualificationList;
    function GetCurrent : TFhirPractitionerQualification;
  public
    Constructor Create(list : TFhirPractitionerQualificationList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerQualification read GetCurrent;
  end;


  {@Class TFhirPractitionerQualificationList
    A list of FhirPractitionerQualification
  }
  {!.Net HL7Connect.Fhir.PractitionerQualificationList}
  TFhirPractitionerQualificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitionerQualification;
    procedure SetItemN(index : Integer; value : TFhirPractitionerQualification);
  public
    {!script hide}
    function Link : TFhirPractitionerQualificationList; Overload;
    function Clone : TFhirPractitionerQualificationList; Overload;
    function GetEnumerator : TFhirPractitionerQualificationListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirPractitionerQualification to the end of the list.
    }
    function Append : TFhirPractitionerQualification;

    
    {@member AddItem
      Add an already existing FhirPractitionerQualification to the end of the list.
    }
    procedure AddItem(value : TFhirPractitionerQualification); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirPractitionerQualification) : Integer;
    

    {@member Insert
      Insert FhirPractitionerQualification before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirPractitionerQualification;
    

    {@member InsertItem
       Insert an existing FhirPractitionerQualification before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirPractitionerQualification);
    
    {@member Item
       Get the iIndexth FhirPractitionerQualification. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirPractitionerQualification. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerQualification);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirPractitionerQualification;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirPractitionerQualifications[index : Integer] : TFhirPractitionerQualification read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProcedurePerformer : TFhirElement
    Limited to 'real' people rather than equipment.
  }
  {!.Net HL7Connect.Fhir.ProcedurePerformer}
  TFhirProcedurePerformer = class (TFhirBackboneElement)
  private
    FPerson : TFhirResourceReference{TFhirPractitioner};
    FRole : TFhirCodeableConcept;
    Procedure SetPerson(value : TFhirResourceReference{TFhirPractitioner});
    Procedure SetRole(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProcedurePerformer; overload;
    function Clone : TFhirProcedurePerformer; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member person
      The practitioner who was involved in the procedure.
    }
    property person : TFhirResourceReference{TFhirPractitioner} read FPerson write SetPerson;
    property personObject : TFhirResourceReference{TFhirPractitioner} read FPerson write SetPerson;

    {@member role
      E.g. surgeon, anaethetist, endoscopist.
    }
    property role : TFhirCodeableConcept read FRole write SetRole;
    property roleObject : TFhirCodeableConcept read FRole write SetRole;

  end;


  TFhirProcedurePerformerListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProcedurePerformerList;
    function GetCurrent : TFhirProcedurePerformer;
  public
    Constructor Create(list : TFhirProcedurePerformerList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedurePerformer read GetCurrent;
  end;


  {@Class TFhirProcedurePerformerList
    A list of FhirProcedurePerformer
  }
  {!.Net HL7Connect.Fhir.ProcedurePerformerList}
  TFhirProcedurePerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProcedurePerformer;
    procedure SetItemN(index : Integer; value : TFhirProcedurePerformer);
  public
    {!script hide}
    function Link : TFhirProcedurePerformerList; Overload;
    function Clone : TFhirProcedurePerformerList; Overload;
    function GetEnumerator : TFhirProcedurePerformerListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProcedurePerformer to the end of the list.
    }
    function Append : TFhirProcedurePerformer;

    
    {@member AddItem
      Add an already existing FhirProcedurePerformer to the end of the list.
    }
    procedure AddItem(value : TFhirProcedurePerformer); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProcedurePerformer) : Integer;
    

    {@member Insert
      Insert FhirProcedurePerformer before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProcedurePerformer;
    

    {@member InsertItem
       Insert an existing FhirProcedurePerformer before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProcedurePerformer);
    
    {@member Item
       Get the iIndexth FhirProcedurePerformer. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProcedurePerformer. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProcedurePerformer);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProcedurePerformer;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProcedurePerformers[index : Integer] : TFhirProcedurePerformer read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProcedureRelatedItem : TFhirElement
    Procedures may be related to other items such as procedures or medications. For example treating wound dehiscence following a previous procedure.
  }
  {!.Net HL7Connect.Fhir.ProcedureRelatedItem}
  TFhirProcedureRelatedItem = class (TFhirBackboneElement)
  private
    FType_ : TFhirEnum;
    FTarget : TFhirResourceReference{Resource};
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirProcedureRelationshipType;
    Procedure SetType_ST(value : TFhirProcedureRelationshipType);
    Procedure SetTarget(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProcedureRelatedItem; overload;
    function Clone : TFhirProcedureRelatedItem; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member type_
      The nature of the relationship.
    }
    property type_ : TFhirProcedureRelationshipType read GetType_ST write SetType_ST;
    property type_Object : TFhirEnum read FType_ write SetType_;

    {@member target
      The related item - e.g. a procedure.
    }
    property target : TFhirResourceReference{Resource} read FTarget write SetTarget;
    property targetObject : TFhirResourceReference{Resource} read FTarget write SetTarget;

  end;


  TFhirProcedureRelatedItemListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProcedureRelatedItemList;
    function GetCurrent : TFhirProcedureRelatedItem;
  public
    Constructor Create(list : TFhirProcedureRelatedItemList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedureRelatedItem read GetCurrent;
  end;


  {@Class TFhirProcedureRelatedItemList
    A list of FhirProcedureRelatedItem
  }
  {!.Net HL7Connect.Fhir.ProcedureRelatedItemList}
  TFhirProcedureRelatedItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProcedureRelatedItem;
    procedure SetItemN(index : Integer; value : TFhirProcedureRelatedItem);
  public
    {!script hide}
    function Link : TFhirProcedureRelatedItemList; Overload;
    function Clone : TFhirProcedureRelatedItemList; Overload;
    function GetEnumerator : TFhirProcedureRelatedItemListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProcedureRelatedItem to the end of the list.
    }
    function Append : TFhirProcedureRelatedItem;

    
    {@member AddItem
      Add an already existing FhirProcedureRelatedItem to the end of the list.
    }
    procedure AddItem(value : TFhirProcedureRelatedItem); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProcedureRelatedItem) : Integer;
    

    {@member Insert
      Insert FhirProcedureRelatedItem before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProcedureRelatedItem;
    

    {@member InsertItem
       Insert an existing FhirProcedureRelatedItem before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProcedureRelatedItem);
    
    {@member Item
       Get the iIndexth FhirProcedureRelatedItem. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProcedureRelatedItem. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProcedureRelatedItem);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProcedureRelatedItem;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProcedureRelatedItems[index : Integer] : TFhirProcedureRelatedItem read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileMapping : TFhirElement
    An external specification that the content is mapped to.
  }
  {!.Net HL7Connect.Fhir.ProfileMapping}
  TFhirProfileMapping = class (TFhirBackboneElement)
  private
    FIdentity : TFhirId;
    FUri : TFhirUri;
    FName : TFhirString;
    FComments : TFhirString;
    Procedure SetIdentity(value : TFhirId);
    Function GetIdentityST : String;
    Procedure SetIdentityST(value : String);
    Procedure SetUri(value : TFhirUri);
    Function GetUriST : String;
    Procedure SetUriST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetComments(value : TFhirString);
    Function GetCommentsST : String;
    Procedure SetCommentsST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileMapping; overload;
    function Clone : TFhirProfileMapping; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member identity
      An Internal id that is used to identify this mapping set when specific mappings are made.
    }
    {@member identity
      Typed access to An Internal id that is used to identify this mapping set when specific mappings are made.
    }
    property identity : String read GetIdentityST write SetIdentityST;
    property identityObject : TFhirId read FIdentity write SetIdentity;

    {@member uri
      A URI that identifies the specification that this mapping is expressed to.
    }
    {@member uri
      Typed access to A URI that identifies the specification that this mapping is expressed to.
    }
    property uri : String read GetUriST write SetUriST;
    property uriObject : TFhirUri read FUri write SetUri;

    {@member name
      A name for the specification that is being mapped to.
    }
    {@member name
      Typed access to A name for the specification that is being mapped to.
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member comments
      Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    }
    {@member comments
      Typed access to Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    }
    property comments : String read GetCommentsST write SetCommentsST;
    property commentsObject : TFhirString read FComments write SetComments;

  end;


  TFhirProfileMappingListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProfileMappingList;
    function GetCurrent : TFhirProfileMapping;
  public
    Constructor Create(list : TFhirProfileMappingList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProfileMapping read GetCurrent;
  end;


  {@Class TFhirProfileMappingList
    A list of FhirProfileMapping
  }
  {!.Net HL7Connect.Fhir.ProfileMappingList}
  TFhirProfileMappingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileMapping;
    procedure SetItemN(index : Integer; value : TFhirProfileMapping);
  public
    {!script hide}
    function Link : TFhirProfileMappingList; Overload;
    function Clone : TFhirProfileMappingList; Overload;
    function GetEnumerator : TFhirProfileMappingListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProfileMapping to the end of the list.
    }
    function Append : TFhirProfileMapping;

    
    {@member AddItem
      Add an already existing FhirProfileMapping to the end of the list.
    }
    procedure AddItem(value : TFhirProfileMapping); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileMapping) : Integer;
    

    {@member Insert
      Insert FhirProfileMapping before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileMapping;
    

    {@member InsertItem
       Insert an existing FhirProfileMapping before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileMapping);
    
    {@member Item
       Get the iIndexth FhirProfileMapping. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileMapping. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileMapping);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileMapping;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileMappings[index : Integer] : TFhirProfileMapping read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructure : TFhirElement
    A constraint statement about what contents a resource or data type may have.
  }
  {!.Net HL7Connect.Fhir.ProfileStructure}
  TFhirProfileStructure = class (TFhirBackboneElement)
  private
    FType_ : TFhirCode;
    FName : TFhirString;
    FPublish : TFhirBoolean;
    FPurpose : TFhirString;
    FelementList : TFhirProfileStructureElementList;
    FsearchParamList : TFhirProfileStructureSearchParamList;
    Procedure SetType_(value : TFhirCode);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetPublish(value : TFhirBoolean);
    Function GetPublishST : Boolean;
    Procedure SetPublishST(value : Boolean);
    Procedure SetPurpose(value : TFhirString);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructure; overload;
    function Clone : TFhirProfileStructure; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member type_
      The Resource or Data type being described.
    }
    {@member type_
      Typed access to The Resource or Data type being described.
    }
    property type_ : String read GetType_ST write SetType_ST;
    property type_Object : TFhirCode read FType_ write SetType_;

    {@member name
      The name of this resource constraint statement (to refer to it from other resource constraints - from Profile.structure.element.definition.type.profile).
    }
    {@member name
      Typed access to The name of this resource constraint statement (to refer to it from other resource constraints - from Profile.structure.element.definition.type.profile).
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member publish
      This definition of a profile on a structure is published as a formal statement. Some structural definitions might be defined purely for internal use within the profile, and not intended to be used outside that context.
    }
    {@member publish
      Typed access to This definition of a profile on a structure is published as a formal statement. Some structural definitions might be defined purely for internal use within the profile, and not intended to be used outside that context.
    }
    property publish : Boolean read GetPublishST write SetPublishST;
    property publishObject : TFhirBoolean read FPublish write SetPublish;

    {@member purpose
      Human summary: why describe this resource?.
    }
    {@member purpose
      Typed access to Human summary: why describe this resource?.
    }
    property purpose : String read GetPurposeST write SetPurposeST;
    property purposeObject : TFhirString read FPurpose write SetPurpose;

    {@member elementList
      Captures constraints on each element within the resource.
    }
    property elementList : TFhirProfileStructureElementList read FElementList;

    {@member searchParamList
      Additional search parameters for implementations to support and/or make use of.
    }
    property searchParamList : TFhirProfileStructureSearchParamList read FSearchParamList;

  end;


  TFhirProfileStructureListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProfileStructureList;
    function GetCurrent : TFhirProfileStructure;
  public
    Constructor Create(list : TFhirProfileStructureList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProfileStructure read GetCurrent;
  end;


  {@Class TFhirProfileStructureList
    A list of FhirProfileStructure
  }
  {!.Net HL7Connect.Fhir.ProfileStructureList}
  TFhirProfileStructureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructure;
    procedure SetItemN(index : Integer; value : TFhirProfileStructure);
  public
    {!script hide}
    function Link : TFhirProfileStructureList; Overload;
    function Clone : TFhirProfileStructureList; Overload;
    function GetEnumerator : TFhirProfileStructureListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructure to the end of the list.
    }
    function Append : TFhirProfileStructure;

    
    {@member AddItem
      Add an already existing FhirProfileStructure to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructure); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructure) : Integer;
    

    {@member Insert
      Insert FhirProfileStructure before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructure;
    

    {@member InsertItem
       Insert an existing FhirProfileStructure before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructure);
    
    {@member Item
       Get the iIndexth FhirProfileStructure. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructure. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructure);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructure;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructures[index : Integer] : TFhirProfileStructure read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElement : TFhirElement
    Captures constraints on each element within the resource.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElement}
  TFhirProfileStructureElement = class (TFhirBackboneElement)
  private
    FPath : TFhirString;
    FRepresentation : TFhirEnumList;
    FName : TFhirString;
    FSlicing : TFhirProfileStructureElementSlicing;
    FDefinition : TFhirProfileStructureElementDefinition;
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    Function GetRepresentationST : TFhirPropertyRepresentationList;
    Procedure SetRepresentationST(value : TFhirPropertyRepresentationList);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSlicing(value : TFhirProfileStructureElementSlicing);
    Procedure SetDefinition(value : TFhirProfileStructureElementDefinition);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElement; overload;
    function Clone : TFhirProfileStructureElement; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member path
      The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource.
    }
    {@member path
      Typed access to The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource.
    }
    property path : String read GetPathST write SetPathST;
    property pathObject : TFhirString read FPath write SetPath;

    {@member representation
      Codes that define how this element is represented in instances, when the deviation varies from the normal case.
    }
    property representation : TFhirPropertyRepresentationList read GetRepresentationST write SetRepresentationST;
    property representationObject : TFhirEnumList read FRepresentation;
    {@member name
      The name of this element definition (to refer to it from other element definitions using Profile.structure.element.definition.nameReference). This is a unique name referring to a specific set of constraints applied to this element. One use of this is to provide a name to different slices of the same element.
    }
    {@member name
      Typed access to The name of this element definition (to refer to it from other element definitions using Profile.structure.element.definition.nameReference). This is a unique name referring to a specific set of constraints applied to this element. One use of this is to provide a name to different slices of the same element.
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member slicing
      Indicates that the element is sliced into a set of alternative definitions (there are multiple definitions on a single element in the base resource). The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
    }
    property slicing : TFhirProfileStructureElementSlicing read FSlicing write SetSlicing;
    property slicingObject : TFhirProfileStructureElementSlicing read FSlicing write SetSlicing;

    {@member definition
      Definition of the content of the element to provide a more specific definition than that contained for the element in the base resource.
    }
    property definition : TFhirProfileStructureElementDefinition read FDefinition write SetDefinition;
    property definitionObject : TFhirProfileStructureElementDefinition read FDefinition write SetDefinition;

  end;


  TFhirProfileStructureElementListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProfileStructureElementList;
    function GetCurrent : TFhirProfileStructureElement;
  public
    Constructor Create(list : TFhirProfileStructureElementList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProfileStructureElement read GetCurrent;
  end;


  {@Class TFhirProfileStructureElementList
    A list of FhirProfileStructureElement
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementList}
  TFhirProfileStructureElementList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElement;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElement);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementList; Overload;
    function Clone : TFhirProfileStructureElementList; Overload;
    function GetEnumerator : TFhirProfileStructureElementListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElement to the end of the list.
    }
    function Append : TFhirProfileStructureElement;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElement to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElement); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElement) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElement before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElement;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElement before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElement);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElement. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElement. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElement);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElement;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElements[index : Integer] : TFhirProfileStructureElement read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementSlicing : TFhirElement
    Indicates that the element is sliced into a set of alternative definitions (there are multiple definitions on a single element in the base resource). The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementSlicing}
  TFhirProfileStructureElementSlicing = class (TFhirBackboneElement)
  private
    FDiscriminator : TFhirId;
    FOrdered : TFhirBoolean;
    FRules : TFhirEnum;
    Procedure SetDiscriminator(value : TFhirId);
    Function GetDiscriminatorST : String;
    Procedure SetDiscriminatorST(value : String);
    Procedure SetOrdered(value : TFhirBoolean);
    Function GetOrderedST : Boolean;
    Procedure SetOrderedST(value : Boolean);
    Procedure SetRules(value : TFhirEnum);
    Function GetRulesST : TFhirResourceSlicingRules;
    Procedure SetRulesST(value : TFhirResourceSlicingRules);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementSlicing; overload;
    function Clone : TFhirProfileStructureElementSlicing; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member discriminator
      Designates which child element is used to discriminate between the slices when processing an instance. The value of the child element in the instance SHALL completely distinguish which slice the element in the resource matches based on the allowed values for that element in each of the slices.
    }
    {@member discriminator
      Typed access to Designates which child element is used to discriminate between the slices when processing an instance. The value of the child element in the instance SHALL completely distinguish which slice the element in the resource matches based on the allowed values for that element in each of the slices.
    }
    property discriminator : String read GetDiscriminatorST write SetDiscriminatorST;
    property discriminatorObject : TFhirId read FDiscriminator write SetDiscriminator;

    {@member ordered
      If the matching elements have to occur in the same order as defined in the profile.
    }
    {@member ordered
      Typed access to If the matching elements have to occur in the same order as defined in the profile.
    }
    property ordered : Boolean read GetOrderedST write SetOrderedST;
    property orderedObject : TFhirBoolean read FOrdered write SetOrdered;

    {@member rules
      Whether additional slices are allowed or not. When the slices are ordered, profile authors can also say that additional slices are only allowed at the end.
    }
    property rules : TFhirResourceSlicingRules read GetRulesST write SetRulesST;
    property rulesObject : TFhirEnum read FRules write SetRules;

  end;


  TFhirProfileStructureElementSlicingListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProfileStructureElementSlicingList;
    function GetCurrent : TFhirProfileStructureElementSlicing;
  public
    Constructor Create(list : TFhirProfileStructureElementSlicingList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProfileStructureElementSlicing read GetCurrent;
  end;


  {@Class TFhirProfileStructureElementSlicingList
    A list of FhirProfileStructureElementSlicing
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementSlicingList}
  TFhirProfileStructureElementSlicingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementSlicing;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementSlicing);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementSlicingList; Overload;
    function Clone : TFhirProfileStructureElementSlicingList; Overload;
    function GetEnumerator : TFhirProfileStructureElementSlicingListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementSlicing to the end of the list.
    }
    function Append : TFhirProfileStructureElementSlicing;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementSlicing to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementSlicing); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementSlicing) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementSlicing before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementSlicing;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementSlicing before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementSlicing);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementSlicing. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementSlicing. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementSlicing);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementSlicing;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementSlicings[index : Integer] : TFhirProfileStructureElementSlicing read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementDefinition : TFhirElement
    Definition of the content of the element to provide a more specific definition than that contained for the element in the base resource.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinition}
  TFhirProfileStructureElementDefinition = class (TFhirBackboneElement)
  private
    FShort : TFhirString;
    FFormal : TFhirString;
    FComments : TFhirString;
    FRequirements : TFhirString;
    FsynonymList : TFhirStringList;
    FMin : TFhirInteger;
    FMax : TFhirString;
    Ftype_List : TFhirProfileStructureElementDefinitionTypeList;
    FNameReference : TFhirString;
    FValue : TFhirType;
    FExample : TFhirType;
    FMaxLength : TFhirInteger;
    FconditionList : TFhirIdList;
    FconstraintList : TFhirProfileStructureElementDefinitionConstraintList;
    FMustSupport : TFhirBoolean;
    FIsModifier : TFhirBoolean;
    FBinding : TFhirProfileStructureElementDefinitionBinding;
    FmappingList : TFhirProfileStructureElementDefinitionMappingList;
    Procedure SetShort(value : TFhirString);
    Function GetShortST : String;
    Procedure SetShortST(value : String);
    Procedure SetFormal(value : TFhirString);
    Function GetFormalST : String;
    Procedure SetFormalST(value : String);
    Procedure SetComments(value : TFhirString);
    Function GetCommentsST : String;
    Procedure SetCommentsST(value : String);
    Procedure SetRequirements(value : TFhirString);
    Function GetRequirementsST : String;
    Procedure SetRequirementsST(value : String);
    Procedure SetMin(value : TFhirInteger);
    Function GetMinST : String;
    Procedure SetMinST(value : String);
    Procedure SetMax(value : TFhirString);
    Function GetMaxST : String;
    Procedure SetMaxST(value : String);
    Procedure SetNameReference(value : TFhirString);
    Function GetNameReferenceST : String;
    Procedure SetNameReferenceST(value : String);
    Procedure SetValue(value : TFhirType);
    Procedure SetExample(value : TFhirType);
    Procedure SetMaxLength(value : TFhirInteger);
    Function GetMaxLengthST : String;
    Procedure SetMaxLengthST(value : String);
    Procedure SetMustSupport(value : TFhirBoolean);
    Function GetMustSupportST : Boolean;
    Procedure SetMustSupportST(value : Boolean);
    Procedure SetIsModifier(value : TFhirBoolean);
    Function GetIsModifierST : Boolean;
    Procedure SetIsModifierST(value : Boolean);
    Procedure SetBinding(value : TFhirProfileStructureElementDefinitionBinding);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementDefinition; overload;
    function Clone : TFhirProfileStructureElementDefinition; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member short
      A concise definition that  is shown in the generated XML format that summarizes profiles (used throughout the specification).
    }
    {@member short
      Typed access to A concise definition that  is shown in the generated XML format that summarizes profiles (used throughout the specification).
    }
    property short : String read GetShortST write SetShortST;
    property shortObject : TFhirString read FShort write SetShort;

    {@member formal
      The definition SHALL be consistent with the base definition, but convey the meaning of the element in the particular context of use of the resource.
    }
    {@member formal
      Typed access to The definition SHALL be consistent with the base definition, but convey the meaning of the element in the particular context of use of the resource.
    }
    property formal : String read GetFormalST write SetFormalST;
    property formalObject : TFhirString read FFormal write SetFormal;

    {@member comments
      Comments about the use of the element, including notes about how to use the data properly, exceptions to proper use, etc.
    }
    {@member comments
      Typed access to Comments about the use of the element, including notes about how to use the data properly, exceptions to proper use, etc.
    }
    property comments : String read GetCommentsST write SetCommentsST;
    property commentsObject : TFhirString read FComments write SetComments;

    {@member requirements
      Explains why this element is needed and why it's been constrained as it has.
    }
    {@member requirements
      Typed access to Explains why this element is needed and why it's been constrained as it has.
    }
    property requirements : String read GetRequirementsST write SetRequirementsST;
    property requirementsObject : TFhirString read FRequirements write SetRequirements;

    {@member synonymList
      Identifies additional names by which this element might also be known.
    }
    property synonymList : TFhirStringList read FSynonymList;

    {@member min
      The minimum number of times this element SHALL appear in the instance.
    }
    {@member min
      Typed access to The minimum number of times this element SHALL appear in the instance.
    }
    property min : String read GetMinST write SetMinST;
    property minObject : TFhirInteger read FMin write SetMin;

    {@member max
      The maximum number of times this element is permitted to appear in the instance.
    }
    {@member max
      Typed access to The maximum number of times this element is permitted to appear in the instance.
    }
    property max : String read GetMaxST write SetMaxST;
    property maxObject : TFhirString read FMax write SetMax;

    {@member type_List
      The data type or resource that the value of this element is permitted to be.
    }
    property type_List : TFhirProfileStructureElementDefinitionTypeList read FType_List;

    {@member nameReference
      Identifies the name of a slice defined elsewhere in the profile whose constraints should be applied to the current element.
    }
    {@member nameReference
      Typed access to Identifies the name of a slice defined elsewhere in the profile whose constraints should be applied to the current element.
    }
    property nameReference : String read GetNameReferenceST write SetNameReferenceST;
    property nameReferenceObject : TFhirString read FNameReference write SetNameReference;

    {@member value
      Specifies a primitive value that SHALL hold for this element in the instance.
    }
    property value : TFhirType read FValue write SetValue;
    property valueObject : TFhirType read FValue write SetValue;

    {@member example
      An example value for this element.
    }
    property example : TFhirType read FExample write SetExample;
    property exampleObject : TFhirType read FExample write SetExample;

    {@member maxLength
      Indicates the shortest length that SHALL be supported by conformant instances without truncation.
    }
    {@member maxLength
      Typed access to Indicates the shortest length that SHALL be supported by conformant instances without truncation.
    }
    property maxLength : String read GetMaxLengthST write SetMaxLengthST;
    property maxLengthObject : TFhirInteger read FMaxLength write SetMaxLength;

    {@member conditionList
      A reference to an invariant that may make additional statements about the cardinality or value in the instance.
    }
    property conditionList : TFhirIdList read FConditionList;

    {@member constraintList
      Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
    }
    property constraintList : TFhirProfileStructureElementDefinitionConstraintList read FConstraintList;

    {@member mustSupport
      If true, conformant resource authors SHALL be capable of providing a value for the element and resource consumers SHALL be capable of extracting and doing something useful with the data element.  If false, the element may be ignored and not supported.
    }
    {@member mustSupport
      Typed access to If true, conformant resource authors SHALL be capable of providing a value for the element and resource consumers SHALL be capable of extracting and doing something useful with the data element.  If false, the element may be ignored and not supported.
    }
    property mustSupport : Boolean read GetMustSupportST write SetMustSupportST;
    property mustSupportObject : TFhirBoolean read FMustSupport write SetMustSupport;

    {@member isModifier
      If true, the value of this element affects the interpretation of the element or resource that contains it, and the value of the element cannot be ignored. Typically, this is used for status, negation and qualification codes. The effect of this is that the element cannot be ignored by systems: they SHALL either recognize the element and process it, and/or a pre-determination has been made that it is not relevant to their particular system.
    }
    {@member isModifier
      Typed access to If true, the value of this element affects the interpretation of the element or resource that contains it, and the value of the element cannot be ignored. Typically, this is used for status, negation and qualification codes. The effect of this is that the element cannot be ignored by systems: they SHALL either recognize the element and process it, and/or a pre-determination has been made that it is not relevant to their particular system.
    }
    property isModifier : Boolean read GetIsModifierST write SetIsModifierST;
    property isModifierObject : TFhirBoolean read FIsModifier write SetIsModifier;

    {@member binding
      Binds to a value set if this element is coded (code, Coding, CodeableConcept).
    }
    property binding : TFhirProfileStructureElementDefinitionBinding read FBinding write SetBinding;
    property bindingObject : TFhirProfileStructureElementDefinitionBinding read FBinding write SetBinding;

    {@member mappingList
      Identifies a concept from an external specification that roughly corresponds to this element.
    }
    property mappingList : TFhirProfileStructureElementDefinitionMappingList read FMappingList;

  end;


  TFhirProfileStructureElementDefinitionListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProfileStructureElementDefinitionList;
    function GetCurrent : TFhirProfileStructureElementDefinition;
  public
    Constructor Create(list : TFhirProfileStructureElementDefinitionList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProfileStructureElementDefinition read GetCurrent;
  end;


  {@Class TFhirProfileStructureElementDefinitionList
    A list of FhirProfileStructureElementDefinition
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionList}
  TFhirProfileStructureElementDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementDefinition;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementDefinition);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementDefinitionList; Overload;
    function Clone : TFhirProfileStructureElementDefinitionList; Overload;
    function GetEnumerator : TFhirProfileStructureElementDefinitionListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementDefinition to the end of the list.
    }
    function Append : TFhirProfileStructureElementDefinition;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementDefinition to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementDefinition); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementDefinition) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementDefinition before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementDefinition;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementDefinition before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementDefinition);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinition. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinition. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementDefinition);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementDefinition;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementDefinitions[index : Integer] : TFhirProfileStructureElementDefinition read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementDefinitionType : TFhirElement
    The data type or resource that the value of this element is permitted to be.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionType}
  TFhirProfileStructureElementDefinitionType = class (TFhirBackboneElement)
  private
    FCode : TFhirCode;
    FProfile : TFhirUri;
    FAggregation : TFhirEnumList;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetProfile(value : TFhirUri);
    Function GetProfileST : String;
    Procedure SetProfileST(value : String);
    Function GetAggregationST : TFhirResourceAggregationModeList;
    Procedure SetAggregationST(value : TFhirResourceAggregationModeList);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementDefinitionType; overload;
    function Clone : TFhirProfileStructureElementDefinitionType; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      Name of Data type or Resource.
    }
    {@member code
      Typed access to Name of Data type or Resource.
    }
    property code : String read GetCodeST write SetCodeST;
    property codeObject : TFhirCode read FCode write SetCode;

    {@member profile
      Identifies a profile that SHALL hold for resources or datatypes referenced as the type of this element. Can be a local reference - to another structure in this profile, or a reference to a structure in another profile.
    }
    {@member profile
      Typed access to Identifies a profile that SHALL hold for resources or datatypes referenced as the type of this element. Can be a local reference - to another structure in this profile, or a reference to a structure in another profile.
    }
    property profile : String read GetProfileST write SetProfileST;
    property profileObject : TFhirUri read FProfile write SetProfile;

    {@member aggregation
      If the type is a reference to another resource, how the resource is or can be aggreated - is it a contained resource, or a reference, and if the context is a bundle, is it included in the bundle.
    }
    property aggregation : TFhirResourceAggregationModeList read GetAggregationST write SetAggregationST;
    property aggregationObject : TFhirEnumList read FAggregation;
  end;


  TFhirProfileStructureElementDefinitionTypeListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProfileStructureElementDefinitionTypeList;
    function GetCurrent : TFhirProfileStructureElementDefinitionType;
  public
    Constructor Create(list : TFhirProfileStructureElementDefinitionTypeList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProfileStructureElementDefinitionType read GetCurrent;
  end;


  {@Class TFhirProfileStructureElementDefinitionTypeList
    A list of FhirProfileStructureElementDefinitionType
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionTypeList}
  TFhirProfileStructureElementDefinitionTypeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementDefinitionType;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementDefinitionType);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementDefinitionTypeList; Overload;
    function Clone : TFhirProfileStructureElementDefinitionTypeList; Overload;
    function GetEnumerator : TFhirProfileStructureElementDefinitionTypeListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementDefinitionType to the end of the list.
    }
    function Append : TFhirProfileStructureElementDefinitionType;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementDefinitionType to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementDefinitionType); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementDefinitionType) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementDefinitionType before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementDefinitionType;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementDefinitionType before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementDefinitionType);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionType. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionType. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementDefinitionType);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementDefinitionType;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementDefinitionTypes[index : Integer] : TFhirProfileStructureElementDefinitionType read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementDefinitionConstraint : TFhirElement
    Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionConstraint}
  TFhirProfileStructureElementDefinitionConstraint = class (TFhirBackboneElement)
  private
    FKey : TFhirId;
    FName : TFhirString;
    FSeverity : TFhirEnum;
    FHuman : TFhirString;
    FXpath : TFhirString;
    Procedure SetKey(value : TFhirId);
    Function GetKeyST : String;
    Procedure SetKeyST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirConstraintSeverity;
    Procedure SetSeverityST(value : TFhirConstraintSeverity);
    Procedure SetHuman(value : TFhirString);
    Function GetHumanST : String;
    Procedure SetHumanST(value : String);
    Procedure SetXpath(value : TFhirString);
    Function GetXpathST : String;
    Procedure SetXpathST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementDefinitionConstraint; overload;
    function Clone : TFhirProfileStructureElementDefinitionConstraint; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member key
      Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
    }
    {@member key
      Typed access to Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
    }
    property key : String read GetKeyST write SetKeyST;
    property keyObject : TFhirId read FKey write SetKey;

    {@member name
      Used to label the constraint in OCL or in short displays incapable of displaying the full human description.
    }
    {@member name
      Typed access to Used to label the constraint in OCL or in short displays incapable of displaying the full human description.
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member severity
      Identifies the impact constraint violation has on the conformance of the instance.
    }
    property severity : TFhirConstraintSeverity read GetSeverityST write SetSeverityST;
    property severityObject : TFhirEnum read FSeverity write SetSeverity;

    {@member human
      Text that can be used to describe the constraint in messages identifying that the constraint has been violated.
    }
    {@member human
      Typed access to Text that can be used to describe the constraint in messages identifying that the constraint has been violated.
    }
    property human : String read GetHumanST write SetHumanST;
    property humanObject : TFhirString read FHuman write SetHuman;

    {@member xpath
      XPath expression of constraint.
    }
    {@member xpath
      Typed access to XPath expression of constraint.
    }
    property xpath : String read GetXpathST write SetXpathST;
    property xpathObject : TFhirString read FXpath write SetXpath;

  end;


  TFhirProfileStructureElementDefinitionConstraintListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProfileStructureElementDefinitionConstraintList;
    function GetCurrent : TFhirProfileStructureElementDefinitionConstraint;
  public
    Constructor Create(list : TFhirProfileStructureElementDefinitionConstraintList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProfileStructureElementDefinitionConstraint read GetCurrent;
  end;


  {@Class TFhirProfileStructureElementDefinitionConstraintList
    A list of FhirProfileStructureElementDefinitionConstraint
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionConstraintList}
  TFhirProfileStructureElementDefinitionConstraintList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementDefinitionConstraint;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementDefinitionConstraint);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementDefinitionConstraintList; Overload;
    function Clone : TFhirProfileStructureElementDefinitionConstraintList; Overload;
    function GetEnumerator : TFhirProfileStructureElementDefinitionConstraintListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementDefinitionConstraint to the end of the list.
    }
    function Append : TFhirProfileStructureElementDefinitionConstraint;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementDefinitionConstraint to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementDefinitionConstraint); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementDefinitionConstraint) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementDefinitionConstraint before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementDefinitionConstraint;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementDefinitionConstraint before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementDefinitionConstraint);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionConstraint. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionConstraint. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementDefinitionConstraint);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementDefinitionConstraint;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementDefinitionConstraints[index : Integer] : TFhirProfileStructureElementDefinitionConstraint read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementDefinitionBinding : TFhirElement
    Binds to a value set if this element is coded (code, Coding, CodeableConcept).
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionBinding}
  TFhirProfileStructureElementDefinitionBinding = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FIsExtensible : TFhirBoolean;
    FConformance : TFhirEnum;
    FDescription : TFhirString;
    FReference : TFhirType;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetIsExtensible(value : TFhirBoolean);
    Function GetIsExtensibleST : Boolean;
    Procedure SetIsExtensibleST(value : Boolean);
    Procedure SetConformance(value : TFhirEnum);
    Function GetConformanceST : TFhirBindingConformance;
    Procedure SetConformanceST(value : TFhirBindingConformance);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetReference(value : TFhirType);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementDefinitionBinding; overload;
    function Clone : TFhirProfileStructureElementDefinitionBinding; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member name
      A descriptive name for this - can be useful for generating implementation artifacts.
    }
    {@member name
      Typed access to A descriptive name for this - can be useful for generating implementation artifacts.
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member isExtensible
      If true, then conformant systems may use additional codes or (where the data type permits) text alone to convey concepts not covered by the set of codes identified in the binding.  If false, then conformant systems are constrained to the provided codes alone.
    }
    {@member isExtensible
      Typed access to If true, then conformant systems may use additional codes or (where the data type permits) text alone to convey concepts not covered by the set of codes identified in the binding.  If false, then conformant systems are constrained to the provided codes alone.
    }
    property isExtensible : Boolean read GetIsExtensibleST write SetIsExtensibleST;
    property isExtensibleObject : TFhirBoolean read FIsExtensible write SetIsExtensible;

    {@member conformance
      Indicates the degree of conformance expectations associated with this binding.
    }
    property conformance : TFhirBindingConformance read GetConformanceST write SetConformanceST;
    property conformanceObject : TFhirEnum read FConformance write SetConformance;

    {@member description
      Describes the intended use of this particular set of codes.
    }
    {@member description
      Typed access to Describes the intended use of this particular set of codes.
    }
    property description : String read GetDescriptionST write SetDescriptionST;
    property descriptionObject : TFhirString read FDescription write SetDescription;

    {@member reference
      Points to the value set or external definition that identifies the set of codes to be used.
    }
    property reference : TFhirType read FReference write SetReference;
    property referenceObject : TFhirType read FReference write SetReference;

  end;


  TFhirProfileStructureElementDefinitionBindingListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProfileStructureElementDefinitionBindingList;
    function GetCurrent : TFhirProfileStructureElementDefinitionBinding;
  public
    Constructor Create(list : TFhirProfileStructureElementDefinitionBindingList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProfileStructureElementDefinitionBinding read GetCurrent;
  end;


  {@Class TFhirProfileStructureElementDefinitionBindingList
    A list of FhirProfileStructureElementDefinitionBinding
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionBindingList}
  TFhirProfileStructureElementDefinitionBindingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementDefinitionBinding;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementDefinitionBinding);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementDefinitionBindingList; Overload;
    function Clone : TFhirProfileStructureElementDefinitionBindingList; Overload;
    function GetEnumerator : TFhirProfileStructureElementDefinitionBindingListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementDefinitionBinding to the end of the list.
    }
    function Append : TFhirProfileStructureElementDefinitionBinding;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementDefinitionBinding to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementDefinitionBinding); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementDefinitionBinding) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementDefinitionBinding before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementDefinitionBinding;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementDefinitionBinding before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementDefinitionBinding);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionBinding. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionBinding. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementDefinitionBinding);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementDefinitionBinding;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementDefinitionBindings[index : Integer] : TFhirProfileStructureElementDefinitionBinding read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureElementDefinitionMapping : TFhirElement
    Identifies a concept from an external specification that roughly corresponds to this element.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionMapping}
  TFhirProfileStructureElementDefinitionMapping = class (TFhirBackboneElement)
  private
    FIdentity : TFhirId;
    FMap : TFhirString;
    Procedure SetIdentity(value : TFhirId);
    Function GetIdentityST : String;
    Procedure SetIdentityST(value : String);
    Procedure SetMap(value : TFhirString);
    Function GetMapST : String;
    Procedure SetMapST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureElementDefinitionMapping; overload;
    function Clone : TFhirProfileStructureElementDefinitionMapping; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member identity
      An internal reference to the definition of a mapping.
    }
    {@member identity
      Typed access to An internal reference to the definition of a mapping.
    }
    property identity : String read GetIdentityST write SetIdentityST;
    property identityObject : TFhirId read FIdentity write SetIdentity;

    {@member map
      Expresses what part of the target specification corresponds to this element.
    }
    {@member map
      Typed access to Expresses what part of the target specification corresponds to this element.
    }
    property map : String read GetMapST write SetMapST;
    property mapObject : TFhirString read FMap write SetMap;

  end;


  TFhirProfileStructureElementDefinitionMappingListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProfileStructureElementDefinitionMappingList;
    function GetCurrent : TFhirProfileStructureElementDefinitionMapping;
  public
    Constructor Create(list : TFhirProfileStructureElementDefinitionMappingList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProfileStructureElementDefinitionMapping read GetCurrent;
  end;


  {@Class TFhirProfileStructureElementDefinitionMappingList
    A list of FhirProfileStructureElementDefinitionMapping
  }
  {!.Net HL7Connect.Fhir.ProfileStructureElementDefinitionMappingList}
  TFhirProfileStructureElementDefinitionMappingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureElementDefinitionMapping;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureElementDefinitionMapping);
  public
    {!script hide}
    function Link : TFhirProfileStructureElementDefinitionMappingList; Overload;
    function Clone : TFhirProfileStructureElementDefinitionMappingList; Overload;
    function GetEnumerator : TFhirProfileStructureElementDefinitionMappingListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureElementDefinitionMapping to the end of the list.
    }
    function Append : TFhirProfileStructureElementDefinitionMapping;

    
    {@member AddItem
      Add an already existing FhirProfileStructureElementDefinitionMapping to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureElementDefinitionMapping); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureElementDefinitionMapping) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureElementDefinitionMapping before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureElementDefinitionMapping;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureElementDefinitionMapping before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureElementDefinitionMapping);
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionMapping. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureElementDefinitionMapping. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureElementDefinitionMapping);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureElementDefinitionMapping;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureElementDefinitionMappings[index : Integer] : TFhirProfileStructureElementDefinitionMapping read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileStructureSearchParam : TFhirElement
    Additional search parameters for implementations to support and/or make use of.
  }
  {!.Net HL7Connect.Fhir.ProfileStructureSearchParam}
  TFhirProfileStructureSearchParam = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FType_ : TFhirEnum;
    FDocumentation : TFhirString;
    FXpath : TFhirString;
    FtargetList : TFhirCodeList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirSearchParamType;
    Procedure SetType_ST(value : TFhirSearchParamType);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetXpath(value : TFhirString);
    Function GetXpathST : String;
    Procedure SetXpathST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileStructureSearchParam; overload;
    function Clone : TFhirProfileStructureSearchParam; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member name
      The name of the standard or custom search parameter.
    }
    {@member name
      Typed access to The name of the standard or custom search parameter.
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member type_
      The type of value a search parameter refers to, and how the content is interpreted.
    }
    property type_ : TFhirSearchParamType read GetType_ST write SetType_ST;
    property type_Object : TFhirEnum read FType_ write SetType_;

    {@member documentation
      A specification for search parameters. For standard parameters, provides additional information on how the parameter is used in this solution.  For custom parameters, provides a description of what the parameter does.
    }
    {@member documentation
      Typed access to A specification for search parameters. For standard parameters, provides additional information on how the parameter is used in this solution.  For custom parameters, provides a description of what the parameter does.
    }
    property documentation : String read GetDocumentationST write SetDocumentationST;
    property documentationObject : TFhirString read FDocumentation write SetDocumentation;

    {@member xpath
      An XPath expression that returns a set of elements for the search parameter.
    }
    {@member xpath
      Typed access to An XPath expression that returns a set of elements for the search parameter.
    }
    property xpath : String read GetXpathST write SetXpathST;
    property xpathObject : TFhirString read FXpath write SetXpath;

    {@member targetList
      Types of resource (if a resource is referenced).
    }
    property targetList : TFhirCodeList read FTargetList;

  end;


  TFhirProfileStructureSearchParamListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProfileStructureSearchParamList;
    function GetCurrent : TFhirProfileStructureSearchParam;
  public
    Constructor Create(list : TFhirProfileStructureSearchParamList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProfileStructureSearchParam read GetCurrent;
  end;


  {@Class TFhirProfileStructureSearchParamList
    A list of FhirProfileStructureSearchParam
  }
  {!.Net HL7Connect.Fhir.ProfileStructureSearchParamList}
  TFhirProfileStructureSearchParamList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileStructureSearchParam;
    procedure SetItemN(index : Integer; value : TFhirProfileStructureSearchParam);
  public
    {!script hide}
    function Link : TFhirProfileStructureSearchParamList; Overload;
    function Clone : TFhirProfileStructureSearchParamList; Overload;
    function GetEnumerator : TFhirProfileStructureSearchParamListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProfileStructureSearchParam to the end of the list.
    }
    function Append : TFhirProfileStructureSearchParam;

    
    {@member AddItem
      Add an already existing FhirProfileStructureSearchParam to the end of the list.
    }
    procedure AddItem(value : TFhirProfileStructureSearchParam); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileStructureSearchParam) : Integer;
    

    {@member Insert
      Insert FhirProfileStructureSearchParam before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileStructureSearchParam;
    

    {@member InsertItem
       Insert an existing FhirProfileStructureSearchParam before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileStructureSearchParam);
    
    {@member Item
       Get the iIndexth FhirProfileStructureSearchParam. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileStructureSearchParam. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileStructureSearchParam);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileStructureSearchParam;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileStructureSearchParams[index : Integer] : TFhirProfileStructureSearchParam read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileExtensionDefn : TFhirElement
    An extension defined as part of the profile.
  }
  {!.Net HL7Connect.Fhir.ProfileExtensionDefn}
  TFhirProfileExtensionDefn = class (TFhirBackboneElement)
  private
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FContextType : TFhirEnum;
    FcontextList : TFhirStringList;
    FDefinition : TFhirProfileStructureElementDefinition;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetContextType(value : TFhirEnum);
    Function GetContextTypeST : TFhirExtensionContext;
    Procedure SetContextTypeST(value : TFhirExtensionContext);
    Procedure SetDefinition(value : TFhirProfileStructureElementDefinition);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileExtensionDefn; overload;
    function Clone : TFhirProfileExtensionDefn; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      A unique code (within the profile) used to identify the extension.
    }
    {@member code
      Typed access to A unique code (within the profile) used to identify the extension.
    }
    property code : String read GetCodeST write SetCodeST;
    property codeObject : TFhirCode read FCode write SetCode;

    {@member display
      Defined so that applications can use this name when displaying the value of the extension to the user.
    }
    {@member display
      Typed access to Defined so that applications can use this name when displaying the value of the extension to the user.
    }
    property display : String read GetDisplayST write SetDisplayST;
    property displayObject : TFhirString read FDisplay write SetDisplay;

    {@member contextType
      Identifies the type of context to which the extension applies.
    }
    property contextType : TFhirExtensionContext read GetContextTypeST write SetContextTypeST;
    property contextTypeObject : TFhirEnum read FContextType write SetContextType;

    {@member contextList
      Identifies the types of resource or data type elements to which the extension can be applied.
    }
    property contextList : TFhirStringList read FContextList;

    {@member definition
      Definition of the extension and its content.
    }
    property definition : TFhirProfileStructureElementDefinition read FDefinition write SetDefinition;
    property definitionObject : TFhirProfileStructureElementDefinition read FDefinition write SetDefinition;

  end;


  TFhirProfileExtensionDefnListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProfileExtensionDefnList;
    function GetCurrent : TFhirProfileExtensionDefn;
  public
    Constructor Create(list : TFhirProfileExtensionDefnList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProfileExtensionDefn read GetCurrent;
  end;


  {@Class TFhirProfileExtensionDefnList
    A list of FhirProfileExtensionDefn
  }
  {!.Net HL7Connect.Fhir.ProfileExtensionDefnList}
  TFhirProfileExtensionDefnList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileExtensionDefn;
    procedure SetItemN(index : Integer; value : TFhirProfileExtensionDefn);
  public
    {!script hide}
    function Link : TFhirProfileExtensionDefnList; Overload;
    function Clone : TFhirProfileExtensionDefnList; Overload;
    function GetEnumerator : TFhirProfileExtensionDefnListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProfileExtensionDefn to the end of the list.
    }
    function Append : TFhirProfileExtensionDefn;

    
    {@member AddItem
      Add an already existing FhirProfileExtensionDefn to the end of the list.
    }
    procedure AddItem(value : TFhirProfileExtensionDefn); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileExtensionDefn) : Integer;
    

    {@member Insert
      Insert FhirProfileExtensionDefn before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileExtensionDefn;
    

    {@member InsertItem
       Insert an existing FhirProfileExtensionDefn before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileExtensionDefn);
    
    {@member Item
       Get the iIndexth FhirProfileExtensionDefn. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileExtensionDefn. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileExtensionDefn);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileExtensionDefn;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileExtensionDefns[index : Integer] : TFhirProfileExtensionDefn read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProfileQuery : TFhirElement
    Definition of a named query and its parameters and their meaning.
  }
  {!.Net HL7Connect.Fhir.ProfileQuery}
  TFhirProfileQuery = class (TFhirBackboneElement)
  private
    FName : TFhirString;
    FDocumentation : TFhirString;
    FparameterList : TFhirProfileStructureSearchParamList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProfileQuery; overload;
    function Clone : TFhirProfileQuery; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member name
      The name of a query, which is used in the URI from Conformance statements declaring use of the query.  Typically this will also be the name for the _query parameter when the query is called, though in some cases it may be aliased by a server to avoid collisions.
    }
    {@member name
      Typed access to The name of a query, which is used in the URI from Conformance statements declaring use of the query.  Typically this will also be the name for the _query parameter when the query is called, though in some cases it may be aliased by a server to avoid collisions.
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member documentation
      Description of the query - the functionality it offers, and considerations about how it functions and to use it.
    }
    {@member documentation
      Typed access to Description of the query - the functionality it offers, and considerations about how it functions and to use it.
    }
    property documentation : String read GetDocumentationST write SetDocumentationST;
    property documentationObject : TFhirString read FDocumentation write SetDocumentation;

    {@member parameterList
      A parameter of a named query.
    }
    property parameterList : TFhirProfileStructureSearchParamList read FParameterList;

  end;


  TFhirProfileQueryListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProfileQueryList;
    function GetCurrent : TFhirProfileQuery;
  public
    Constructor Create(list : TFhirProfileQueryList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProfileQuery read GetCurrent;
  end;


  {@Class TFhirProfileQueryList
    A list of FhirProfileQuery
  }
  {!.Net HL7Connect.Fhir.ProfileQueryList}
  TFhirProfileQueryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProfileQuery;
    procedure SetItemN(index : Integer; value : TFhirProfileQuery);
  public
    {!script hide}
    function Link : TFhirProfileQueryList; Overload;
    function Clone : TFhirProfileQueryList; Overload;
    function GetEnumerator : TFhirProfileQueryListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProfileQuery to the end of the list.
    }
    function Append : TFhirProfileQuery;

    
    {@member AddItem
      Add an already existing FhirProfileQuery to the end of the list.
    }
    procedure AddItem(value : TFhirProfileQuery); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProfileQuery) : Integer;
    

    {@member Insert
      Insert FhirProfileQuery before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProfileQuery;
    

    {@member InsertItem
       Insert an existing FhirProfileQuery before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProfileQuery);
    
    {@member Item
       Get the iIndexth FhirProfileQuery. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProfileQuery. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProfileQuery);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProfileQuery;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProfileQueries[index : Integer] : TFhirProfileQuery read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProvenanceAgent : TFhirElement
    An agent takes a role in an activity such that the agent can be assigned some degree of responsibility for the activity taking place. An agent can be a person, a piece of software, an inanimate object, an organization, or other entities that may be ascribed responsibility.
  }
  {!.Net HL7Connect.Fhir.ProvenanceAgent}
  TFhirProvenanceAgent = class (TFhirBackboneElement)
  private
    FRole : TFhirCoding;
    FType_ : TFhirCoding;
    FReference : TFhirUri;
    FDisplay : TFhirString;
    Procedure SetRole(value : TFhirCoding);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetReference(value : TFhirUri);
    Function GetReferenceST : String;
    Procedure SetReferenceST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProvenanceAgent; overload;
    function Clone : TFhirProvenanceAgent; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member role
      The role that the participant played.
    }
    property role : TFhirCoding read FRole write SetRole;
    property roleObject : TFhirCoding read FRole write SetRole;

    {@member type_
      The type of the participant.
    }
    property type_ : TFhirCoding read FType_ write SetType_;
    property type_Object : TFhirCoding read FType_ write SetType_;

    {@member reference
      Identity of participant. May be a logical or physical uri and maybe absolute or relative.
    }
    {@member reference
      Typed access to Identity of participant. May be a logical or physical uri and maybe absolute or relative.
    }
    property reference : String read GetReferenceST write SetReferenceST;
    property referenceObject : TFhirUri read FReference write SetReference;

    {@member display
      Human-readable description of the participant.
    }
    {@member display
      Typed access to Human-readable description of the participant.
    }
    property display : String read GetDisplayST write SetDisplayST;
    property displayObject : TFhirString read FDisplay write SetDisplay;

  end;


  TFhirProvenanceAgentListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceAgentList;
    function GetCurrent : TFhirProvenanceAgent;
  public
    Constructor Create(list : TFhirProvenanceAgentList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenanceAgent read GetCurrent;
  end;


  {@Class TFhirProvenanceAgentList
    A list of FhirProvenanceAgent
  }
  {!.Net HL7Connect.Fhir.ProvenanceAgentList}
  TFhirProvenanceAgentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProvenanceAgent;
    procedure SetItemN(index : Integer; value : TFhirProvenanceAgent);
  public
    {!script hide}
    function Link : TFhirProvenanceAgentList; Overload;
    function Clone : TFhirProvenanceAgentList; Overload;
    function GetEnumerator : TFhirProvenanceAgentListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProvenanceAgent to the end of the list.
    }
    function Append : TFhirProvenanceAgent;

    
    {@member AddItem
      Add an already existing FhirProvenanceAgent to the end of the list.
    }
    procedure AddItem(value : TFhirProvenanceAgent); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProvenanceAgent) : Integer;
    

    {@member Insert
      Insert FhirProvenanceAgent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProvenanceAgent;
    

    {@member InsertItem
       Insert an existing FhirProvenanceAgent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProvenanceAgent);
    
    {@member Item
       Get the iIndexth FhirProvenanceAgent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProvenanceAgent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceAgent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProvenanceAgent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProvenanceAgents[index : Integer] : TFhirProvenanceAgent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirProvenanceEntity : TFhirElement
    An entity used in this activity.
  }
  {!.Net HL7Connect.Fhir.ProvenanceEntity}
  TFhirProvenanceEntity = class (TFhirBackboneElement)
  private
    FRole : TFhirEnum;
    FType_ : TFhirCoding;
    FReference : TFhirUri;
    FDisplay : TFhirString;
    FAgent : TFhirProvenanceAgent;
    Procedure SetRole(value : TFhirEnum);
    Function GetRoleST : TFhirProvenanceEntityRole;
    Procedure SetRoleST(value : TFhirProvenanceEntityRole);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetReference(value : TFhirUri);
    Function GetReferenceST : String;
    Procedure SetReferenceST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetAgent(value : TFhirProvenanceAgent);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirProvenanceEntity; overload;
    function Clone : TFhirProvenanceEntity; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member role
      How the entity was used during the activity.
    }
    property role : TFhirProvenanceEntityRole read GetRoleST write SetRoleST;
    property roleObject : TFhirEnum read FRole write SetRole;

    {@member type_
      The type of the entity. If the entity is a resource, then this is a resource type.
    }
    property type_ : TFhirCoding read FType_ write SetType_;
    property type_Object : TFhirCoding read FType_ write SetType_;

    {@member reference
      Identity of participant. May be a logical or physical uri and maybe absolute or relative.
    }
    {@member reference
      Typed access to Identity of participant. May be a logical or physical uri and maybe absolute or relative.
    }
    property reference : String read GetReferenceST write SetReferenceST;
    property referenceObject : TFhirUri read FReference write SetReference;

    {@member display
      Human-readable description of the entity.
    }
    {@member display
      Typed access to Human-readable description of the entity.
    }
    property display : String read GetDisplayST write SetDisplayST;
    property displayObject : TFhirString read FDisplay write SetDisplay;

    {@member agent
      The entity is attributed to an agent to express the agent's responsibility for that entity, possibly along with other agents. This description can be understood as shorthand for saying that the agent was responsible for the activity which generated the entity.
    }
    property agent : TFhirProvenanceAgent read FAgent write SetAgent;
    property agentObject : TFhirProvenanceAgent read FAgent write SetAgent;

  end;


  TFhirProvenanceEntityListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceEntityList;
    function GetCurrent : TFhirProvenanceEntity;
  public
    Constructor Create(list : TFhirProvenanceEntityList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenanceEntity read GetCurrent;
  end;


  {@Class TFhirProvenanceEntityList
    A list of FhirProvenanceEntity
  }
  {!.Net HL7Connect.Fhir.ProvenanceEntityList}
  TFhirProvenanceEntityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProvenanceEntity;
    procedure SetItemN(index : Integer; value : TFhirProvenanceEntity);
  public
    {!script hide}
    function Link : TFhirProvenanceEntityList; Overload;
    function Clone : TFhirProvenanceEntityList; Overload;
    function GetEnumerator : TFhirProvenanceEntityListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirProvenanceEntity to the end of the list.
    }
    function Append : TFhirProvenanceEntity;

    
    {@member AddItem
      Add an already existing FhirProvenanceEntity to the end of the list.
    }
    procedure AddItem(value : TFhirProvenanceEntity); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirProvenanceEntity) : Integer;
    

    {@member Insert
      Insert FhirProvenanceEntity before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirProvenanceEntity;
    

    {@member InsertItem
       Insert an existing FhirProvenanceEntity before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirProvenanceEntity);
    
    {@member Item
       Get the iIndexth FhirProvenanceEntity. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirProvenanceEntity. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceEntity);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirProvenanceEntity;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirProvenanceEntities[index : Integer] : TFhirProvenanceEntity read GetItemN write SetItemN; default;
  End;


  {@Class TFhirQueryResponse : TFhirElement
    If this is a response to a query.
  }
  {!.Net HL7Connect.Fhir.QueryResponse}
  TFhirQueryResponse = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirUri;
    FOutcome : TFhirEnum;
    FTotal : TFhirInteger;
    FparameterList : TFhirExtensionList;
    FfirstList : TFhirExtensionList;
    FpreviousList : TFhirExtensionList;
    FnextList : TFhirExtensionList;
    FlastList : TFhirExtensionList;
    FreferenceList : TFhirResourceReferenceList{Resource};
    Procedure SetIdentifier(value : TFhirUri);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirQueryOutcome;
    Procedure SetOutcomeST(value : TFhirQueryOutcome);
    Procedure SetTotal(value : TFhirInteger);
    Function GetTotalST : String;
    Procedure SetTotalST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirQueryResponse; overload;
    function Clone : TFhirQueryResponse; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member identifier
      Links response to source query.
    }
    {@member identifier
      Typed access to Links response to source query.
    }
    property identifier : String read GetIdentifierST write SetIdentifierST;
    property identifierObject : TFhirUri read FIdentifier write SetIdentifier;

    {@member outcome
      Outcome of processing the query.
    }
    property outcome : TFhirQueryOutcome read GetOutcomeST write SetOutcomeST;
    property outcomeObject : TFhirEnum read FOutcome write SetOutcome;

    {@member total
      Total number of matching records.
    }
    {@member total
      Typed access to Total number of matching records.
    }
    property total : String read GetTotalST write SetTotalST;
    property totalObject : TFhirInteger read FTotal write SetTotal;

    {@member parameterList
      Parameters server used.
    }
    property parameterList : TFhirExtensionList read FParameterList;

    {@member firstList
      To get first page (if paged).
    }
    property firstList : TFhirExtensionList read FFirstList;

    {@member previousList
      To get previous page (if paged).
    }
    property previousList : TFhirExtensionList read FPreviousList;

    {@member nextList
      To get next page (if paged).
    }
    property nextList : TFhirExtensionList read FNextList;

    {@member lastList
      To get last page (if paged).
    }
    property lastList : TFhirExtensionList read FLastList;

    {@member referenceList
      Resources that are the results of the search.
    }
    property referenceList : TFhirResourceReferenceList{Resource} read FReferenceList;

  end;


  TFhirQueryResponseListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirQueryResponseList;
    function GetCurrent : TFhirQueryResponse;
  public
    Constructor Create(list : TFhirQueryResponseList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQueryResponse read GetCurrent;
  end;


  {@Class TFhirQueryResponseList
    A list of FhirQueryResponse
  }
  {!.Net HL7Connect.Fhir.QueryResponseList}
  TFhirQueryResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQueryResponse;
    procedure SetItemN(index : Integer; value : TFhirQueryResponse);
  public
    {!script hide}
    function Link : TFhirQueryResponseList; Overload;
    function Clone : TFhirQueryResponseList; Overload;
    function GetEnumerator : TFhirQueryResponseListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirQueryResponse to the end of the list.
    }
    function Append : TFhirQueryResponse;

    
    {@member AddItem
      Add an already existing FhirQueryResponse to the end of the list.
    }
    procedure AddItem(value : TFhirQueryResponse); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirQueryResponse) : Integer;
    

    {@member Insert
      Insert FhirQueryResponse before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirQueryResponse;
    

    {@member InsertItem
       Insert an existing FhirQueryResponse before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirQueryResponse);
    
    {@member Item
       Get the iIndexth FhirQueryResponse. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirQueryResponse. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirQueryResponse);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirQueryResponse;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirQueryResponses[index : Integer] : TFhirQueryResponse read GetItemN write SetItemN; default;
  End;


  {@Class TFhirQuestionnaireGroup : TFhirElement
    A group of questions to a possibly similarly grouped set of questions in the questionnaire.
  }
  {!.Net HL7Connect.Fhir.QuestionnaireGroup}
  TFhirQuestionnaireGroup = class (TFhirBackboneElement)
  private
    FName : TFhirCodeableConcept;
    FHeader : TFhirString;
    FText : TFhirString;
    FSubject : TFhirResourceReference{Resource};
    FgroupList : TFhirQuestionnaireGroupList;
    FquestionList : TFhirQuestionnaireGroupQuestionList;
    Procedure SetName(value : TFhirCodeableConcept);
    Procedure SetHeader(value : TFhirString);
    Function GetHeaderST : String;
    Procedure SetHeaderST(value : String);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetSubject(value : TFhirResourceReference{Resource});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirQuestionnaireGroup; overload;
    function Clone : TFhirQuestionnaireGroup; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member name
      Structured name for a section of a predefined list of questions this questionnaire is responding to.
    }
    property name : TFhirCodeableConcept read FName write SetName;
    property nameObject : TFhirCodeableConcept read FName write SetName;

    {@member header
      Text that is displayed above the contents of the group.
    }
    {@member header
      Typed access to Text that is displayed above the contents of the group.
    }
    property header : String read GetHeaderST write SetHeaderST;
    property headerObject : TFhirString read FHeader write SetHeader;

    {@member text
      Additional text for the group, used for display purposes.
    }
    {@member text
      Typed access to Additional text for the group, used for display purposes.
    }
    property text : String read GetTextST write SetTextST;
    property textObject : TFhirString read FText write SetText;

    {@member subject
      More specific subject this section's answers are about, details the subject given in Questionnaire.
    }
    property subject : TFhirResourceReference{Resource} read FSubject write SetSubject;
    property subjectObject : TFhirResourceReference{Resource} read FSubject write SetSubject;

    {@member groupList
      A sub-group within a group. The ordering of groups within this group is relevant.
    }
    property groupList : TFhirQuestionnaireGroupList read FGroupList;

    {@member questionList
      Set of questions within this group. The order of questions within the group is relevant.
    }
    property questionList : TFhirQuestionnaireGroupQuestionList read FQuestionList;

  end;


  TFhirQuestionnaireGroupListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireGroupList;
    function GetCurrent : TFhirQuestionnaireGroup;
  public
    Constructor Create(list : TFhirQuestionnaireGroupList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireGroup read GetCurrent;
  end;


  {@Class TFhirQuestionnaireGroupList
    A list of FhirQuestionnaireGroup
  }
  {!.Net HL7Connect.Fhir.QuestionnaireGroupList}
  TFhirQuestionnaireGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireGroup;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireGroup);
  public
    {!script hide}
    function Link : TFhirQuestionnaireGroupList; Overload;
    function Clone : TFhirQuestionnaireGroupList; Overload;
    function GetEnumerator : TFhirQuestionnaireGroupListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirQuestionnaireGroup to the end of the list.
    }
    function Append : TFhirQuestionnaireGroup;

    
    {@member AddItem
      Add an already existing FhirQuestionnaireGroup to the end of the list.
    }
    procedure AddItem(value : TFhirQuestionnaireGroup); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirQuestionnaireGroup) : Integer;
    

    {@member Insert
      Insert FhirQuestionnaireGroup before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirQuestionnaireGroup;
    

    {@member InsertItem
       Insert an existing FhirQuestionnaireGroup before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireGroup);
    
    {@member Item
       Get the iIndexth FhirQuestionnaireGroup. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirQuestionnaireGroup. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireGroup);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirQuestionnaireGroup;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirQuestionnaireGroups[index : Integer] : TFhirQuestionnaireGroup read GetItemN write SetItemN; default;
  End;


  {@Class TFhirQuestionnaireGroupQuestion : TFhirElement
    Set of questions within this group. The order of questions within the group is relevant.
  }
  {!.Net HL7Connect.Fhir.QuestionnaireGroupQuestion}
  TFhirQuestionnaireGroupQuestion = class (TFhirBackboneElement)
  private
    FName : TFhirCodeableConcept;
    FText : TFhirString;
    FAnswer : TFhirType;
    FchoiceList : TFhirCodingList;
    FOptions : TFhirResourceReference{TFhirValueSet};
    FData : TFhirType;
    FRemarks : TFhirString;
    FgroupList : TFhirQuestionnaireGroupList;
    Procedure SetName(value : TFhirCodeableConcept);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetAnswer(value : TFhirType);
    Procedure SetOptions(value : TFhirResourceReference{TFhirValueSet});
    Procedure SetData(value : TFhirType);
    Procedure SetRemarks(value : TFhirString);
    Function GetRemarksST : String;
    Procedure SetRemarksST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirQuestionnaireGroupQuestion; overload;
    function Clone : TFhirQuestionnaireGroupQuestion; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member name
      Structured name for the question that identifies this question within the Questionnaire or Group.
    }
    property name : TFhirCodeableConcept read FName write SetName;
    property nameObject : TFhirCodeableConcept read FName write SetName;

    {@member text
      Text of the question as it is shown to the user.
    }
    {@member text
      Typed access to Text of the question as it is shown to the user.
    }
    property text : String read GetTextST write SetTextST;
    property textObject : TFhirString read FText write SetText;

    {@member answer
      Single-valued answer to the question.
    }
    property answer : TFhirType read FAnswer write SetAnswer;
    property answerObject : TFhirType read FAnswer write SetAnswer;

    {@member choiceList
      Selections made by the user from the list of options.
    }
    property choiceList : TFhirCodingList read FChoiceList;

    {@member options
      Reference to a valueset containing the possible options.
    }
    property options : TFhirResourceReference{TFhirValueSet} read FOptions write SetOptions;
    property optionsObject : TFhirResourceReference{TFhirValueSet} read FOptions write SetOptions;

    {@member data
      Structured answer in the form of a FHIR Resource or datatype.
    }
    property data : TFhirType read FData write SetData;
    property dataObject : TFhirType read FData write SetData;

    {@member remarks
      The remark contains information about the answer given. This is additional information about the answer the author wishes to convey, but should not be used to contain information that is part of the answer itself.
    }
    {@member remarks
      Typed access to The remark contains information about the answer given. This is additional information about the answer the author wishes to convey, but should not be used to contain information that is part of the answer itself.
    }
    property remarks : String read GetRemarksST write SetRemarksST;
    property remarksObject : TFhirString read FRemarks write SetRemarks;

    {@member groupList
      Nested group, containing nested question for this question. The order of groups within the question is relevant.
    }
    property groupList : TFhirQuestionnaireGroupList read FGroupList;

  end;


  TFhirQuestionnaireGroupQuestionListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireGroupQuestionList;
    function GetCurrent : TFhirQuestionnaireGroupQuestion;
  public
    Constructor Create(list : TFhirQuestionnaireGroupQuestionList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireGroupQuestion read GetCurrent;
  end;


  {@Class TFhirQuestionnaireGroupQuestionList
    A list of FhirQuestionnaireGroupQuestion
  }
  {!.Net HL7Connect.Fhir.QuestionnaireGroupQuestionList}
  TFhirQuestionnaireGroupQuestionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireGroupQuestion;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireGroupQuestion);
  public
    {!script hide}
    function Link : TFhirQuestionnaireGroupQuestionList; Overload;
    function Clone : TFhirQuestionnaireGroupQuestionList; Overload;
    function GetEnumerator : TFhirQuestionnaireGroupQuestionListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirQuestionnaireGroupQuestion to the end of the list.
    }
    function Append : TFhirQuestionnaireGroupQuestion;

    
    {@member AddItem
      Add an already existing FhirQuestionnaireGroupQuestion to the end of the list.
    }
    procedure AddItem(value : TFhirQuestionnaireGroupQuestion); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirQuestionnaireGroupQuestion) : Integer;
    

    {@member Insert
      Insert FhirQuestionnaireGroupQuestion before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirQuestionnaireGroupQuestion;
    

    {@member InsertItem
       Insert an existing FhirQuestionnaireGroupQuestion before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireGroupQuestion);
    
    {@member Item
       Get the iIndexth FhirQuestionnaireGroupQuestion. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirQuestionnaireGroupQuestion. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireGroupQuestion);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirQuestionnaireGroupQuestion;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirQuestionnaireGroupQuestions[index : Integer] : TFhirQuestionnaireGroupQuestion read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventEvent : TFhirElement
    Identifies the name, action type, time, and disposition of the audited event.
  }
  {!.Net HL7Connect.Fhir.SecurityEventEvent}
  TFhirSecurityEventEvent = class (TFhirBackboneElement)
  private
    FType_ : TFhirCodeableConcept;
    FsubtypeList : TFhirCodeableConceptList;
    FAction : TFhirEnum;
    FDateTime : TFhirInstant;
    FOutcome : TFhirEnum;
    FOutcomeDesc : TFhirString;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAction(value : TFhirEnum);
    Function GetActionST : TFhirSecurityEventAction;
    Procedure SetActionST(value : TFhirSecurityEventAction);
    Procedure SetDateTime(value : TFhirInstant);
    Function GetDateTimeST : TDateTimeEx;
    Procedure SetDateTimeST(value : TDateTimeEx);
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirSecurityEventOutcome;
    Procedure SetOutcomeST(value : TFhirSecurityEventOutcome);
    Procedure SetOutcomeDesc(value : TFhirString);
    Function GetOutcomeDescST : String;
    Procedure SetOutcomeDescST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventEvent; overload;
    function Clone : TFhirSecurityEventEvent; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member type_
      Identifier for a family of the event.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    property type_Object : TFhirCodeableConcept read FType_ write SetType_;

    {@member subtypeList
      Identifier for the category of event.
    }
    property subtypeList : TFhirCodeableConceptList read FSubtypeList;

    {@member action
      Indicator for type of action performed during the event that generated the audit.
    }
    property action : TFhirSecurityEventAction read GetActionST write SetActionST;
    property actionObject : TFhirEnum read FAction write SetAction;

    {@member dateTime
      The time when the event occurred on the source.
    }
    {@member dateTime
      Typed access to The time when the event occurred on the source.
    }
    property dateTime : TDateTimeEx read GetDateTimeST write SetDateTimeST;
    property dateTimeObject : TFhirInstant read FDateTime write SetDateTime;

    {@member outcome
      Indicates whether the event succeeded or failed.
    }
    property outcome : TFhirSecurityEventOutcome read GetOutcomeST write SetOutcomeST;
    property outcomeObject : TFhirEnum read FOutcome write SetOutcome;

    {@member outcomeDesc
      A free text description of the outcome of the event.
    }
    {@member outcomeDesc
      Typed access to A free text description of the outcome of the event.
    }
    property outcomeDesc : String read GetOutcomeDescST write SetOutcomeDescST;
    property outcomeDescObject : TFhirString read FOutcomeDesc write SetOutcomeDesc;

  end;


  TFhirSecurityEventEventListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirSecurityEventEventList;
    function GetCurrent : TFhirSecurityEventEvent;
  public
    Constructor Create(list : TFhirSecurityEventEventList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSecurityEventEvent read GetCurrent;
  end;


  {@Class TFhirSecurityEventEventList
    A list of FhirSecurityEventEvent
  }
  {!.Net HL7Connect.Fhir.SecurityEventEventList}
  TFhirSecurityEventEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventEvent;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventEvent);
  public
    {!script hide}
    function Link : TFhirSecurityEventEventList; Overload;
    function Clone : TFhirSecurityEventEventList; Overload;
    function GetEnumerator : TFhirSecurityEventEventListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventEvent to the end of the list.
    }
    function Append : TFhirSecurityEventEvent;

    
    {@member AddItem
      Add an already existing FhirSecurityEventEvent to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventEvent); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventEvent) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventEvent before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventEvent;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventEvent before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventEvent);
    
    {@member Item
       Get the iIndexth FhirSecurityEventEvent. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventEvent. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventEvent);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventEvent;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventEvents[index : Integer] : TFhirSecurityEventEvent read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventParticipant : TFhirElement
    A person, a hardware device or software process.
  }
  {!.Net HL7Connect.Fhir.SecurityEventParticipant}
  TFhirSecurityEventParticipant = class (TFhirBackboneElement)
  private
    FroleList : TFhirCodeableConceptList;
    FReference : TFhirResourceReference{Resource};
    FUserId : TFhirString;
    FAltId : TFhirString;
    FName : TFhirString;
    FRequestor : TFhirBoolean;
    FMedia : TFhirCoding;
    FNetwork : TFhirSecurityEventParticipantNetwork;
    Procedure SetReference(value : TFhirResourceReference{Resource});
    Procedure SetUserId(value : TFhirString);
    Function GetUserIdST : String;
    Procedure SetUserIdST(value : String);
    Procedure SetAltId(value : TFhirString);
    Function GetAltIdST : String;
    Procedure SetAltIdST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetRequestor(value : TFhirBoolean);
    Function GetRequestorST : Boolean;
    Procedure SetRequestorST(value : Boolean);
    Procedure SetMedia(value : TFhirCoding);
    Procedure SetNetwork(value : TFhirSecurityEventParticipantNetwork);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventParticipant; overload;
    function Clone : TFhirSecurityEventParticipant; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member roleList
      Specification of the role(s) the user plays when performing the event. Usually the codes used in this element are local codes defined by the role-based access control security system used in the local context.
    }
    property roleList : TFhirCodeableConceptList read FRoleList;

    {@member reference
      Direct reference to a resource that identifies the participant.
    }
    property reference : TFhirResourceReference{Resource} read FReference write SetReference;
    property referenceObject : TFhirResourceReference{Resource} read FReference write SetReference;

    {@member userId
      Unique identifier for the user actively participating in the event.
    }
    {@member userId
      Typed access to Unique identifier for the user actively participating in the event.
    }
    property userId : String read GetUserIdST write SetUserIdST;
    property userIdObject : TFhirString read FUserId write SetUserId;

    {@member altId
      Alternative Participant Identifier. For a human, this should be a user identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g., single sign-on), if available.
    }
    {@member altId
      Typed access to Alternative Participant Identifier. For a human, this should be a user identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g., single sign-on), if available.
    }
    property altId : String read GetAltIdST write SetAltIdST;
    property altIdObject : TFhirString read FAltId write SetAltId;

    {@member name
      Human-meaningful name for the user.
    }
    {@member name
      Typed access to Human-meaningful name for the user.
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member requestor
      Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    }
    {@member requestor
      Typed access to Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    }
    property requestor : Boolean read GetRequestorST write SetRequestorST;
    property requestorObject : TFhirBoolean read FRequestor write SetRequestor;

    {@member media
      Type of media involved. Used when the event is about exporting/importing onto media.
    }
    property media : TFhirCoding read FMedia write SetMedia;
    property mediaObject : TFhirCoding read FMedia write SetMedia;

    {@member network
      Logical network location for application activity, if the activity has a network location.
    }
    property network : TFhirSecurityEventParticipantNetwork read FNetwork write SetNetwork;
    property networkObject : TFhirSecurityEventParticipantNetwork read FNetwork write SetNetwork;

  end;


  TFhirSecurityEventParticipantListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirSecurityEventParticipantList;
    function GetCurrent : TFhirSecurityEventParticipant;
  public
    Constructor Create(list : TFhirSecurityEventParticipantList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSecurityEventParticipant read GetCurrent;
  end;


  {@Class TFhirSecurityEventParticipantList
    A list of FhirSecurityEventParticipant
  }
  {!.Net HL7Connect.Fhir.SecurityEventParticipantList}
  TFhirSecurityEventParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventParticipant;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventParticipant);
  public
    {!script hide}
    function Link : TFhirSecurityEventParticipantList; Overload;
    function Clone : TFhirSecurityEventParticipantList; Overload;
    function GetEnumerator : TFhirSecurityEventParticipantListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventParticipant to the end of the list.
    }
    function Append : TFhirSecurityEventParticipant;

    
    {@member AddItem
      Add an already existing FhirSecurityEventParticipant to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventParticipant); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventParticipant) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventParticipant before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventParticipant;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventParticipant before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventParticipant);
    
    {@member Item
       Get the iIndexth FhirSecurityEventParticipant. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventParticipant. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventParticipant);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventParticipant;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventParticipants[index : Integer] : TFhirSecurityEventParticipant read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventParticipantNetwork : TFhirElement
    Logical network location for application activity, if the activity has a network location.
  }
  {!.Net HL7Connect.Fhir.SecurityEventParticipantNetwork}
  TFhirSecurityEventParticipantNetwork = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirString;
    FType_ : TFhirEnum;
    Procedure SetIdentifier(value : TFhirString);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirNetworkType;
    Procedure SetType_ST(value : TFhirNetworkType);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventParticipantNetwork; overload;
    function Clone : TFhirSecurityEventParticipantNetwork; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member identifier
      An identifier for the network access point of the user device for the audit event.
    }
    {@member identifier
      Typed access to An identifier for the network access point of the user device for the audit event.
    }
    property identifier : String read GetIdentifierST write SetIdentifierST;
    property identifierObject : TFhirString read FIdentifier write SetIdentifier;

    {@member type_
      An identifier for the type of network access point that originated the audit event.
    }
    property type_ : TFhirNetworkType read GetType_ST write SetType_ST;
    property type_Object : TFhirEnum read FType_ write SetType_;

  end;


  TFhirSecurityEventParticipantNetworkListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirSecurityEventParticipantNetworkList;
    function GetCurrent : TFhirSecurityEventParticipantNetwork;
  public
    Constructor Create(list : TFhirSecurityEventParticipantNetworkList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSecurityEventParticipantNetwork read GetCurrent;
  end;


  {@Class TFhirSecurityEventParticipantNetworkList
    A list of FhirSecurityEventParticipantNetwork
  }
  {!.Net HL7Connect.Fhir.SecurityEventParticipantNetworkList}
  TFhirSecurityEventParticipantNetworkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventParticipantNetwork;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventParticipantNetwork);
  public
    {!script hide}
    function Link : TFhirSecurityEventParticipantNetworkList; Overload;
    function Clone : TFhirSecurityEventParticipantNetworkList; Overload;
    function GetEnumerator : TFhirSecurityEventParticipantNetworkListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventParticipantNetwork to the end of the list.
    }
    function Append : TFhirSecurityEventParticipantNetwork;

    
    {@member AddItem
      Add an already existing FhirSecurityEventParticipantNetwork to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventParticipantNetwork); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventParticipantNetwork) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventParticipantNetwork before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventParticipantNetwork;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventParticipantNetwork before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventParticipantNetwork);
    
    {@member Item
       Get the iIndexth FhirSecurityEventParticipantNetwork. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventParticipantNetwork. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventParticipantNetwork);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventParticipantNetwork;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventParticipantNetworks[index : Integer] : TFhirSecurityEventParticipantNetwork read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventSource : TFhirElement
    Application systems and processes.
  }
  {!.Net HL7Connect.Fhir.SecurityEventSource}
  TFhirSecurityEventSource = class (TFhirBackboneElement)
  private
    FSite : TFhirString;
    FIdentifier : TFhirString;
    Ftype_List : TFhirCodingList;
    Procedure SetSite(value : TFhirString);
    Function GetSiteST : String;
    Procedure SetSiteST(value : String);
    Procedure SetIdentifier(value : TFhirString);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventSource; overload;
    function Clone : TFhirSecurityEventSource; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member site
      Logical source location within the healthcare enterprise network.
    }
    {@member site
      Typed access to Logical source location within the healthcare enterprise network.
    }
    property site : String read GetSiteST write SetSiteST;
    property siteObject : TFhirString read FSite write SetSite;

    {@member identifier
      Identifier of the source where the event originated.
    }
    {@member identifier
      Typed access to Identifier of the source where the event originated.
    }
    property identifier : String read GetIdentifierST write SetIdentifierST;
    property identifierObject : TFhirString read FIdentifier write SetIdentifier;

    {@member type_List
      Code specifying the type of source where event originated.
    }
    property type_List : TFhirCodingList read FType_List;

  end;


  TFhirSecurityEventSourceListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirSecurityEventSourceList;
    function GetCurrent : TFhirSecurityEventSource;
  public
    Constructor Create(list : TFhirSecurityEventSourceList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSecurityEventSource read GetCurrent;
  end;


  {@Class TFhirSecurityEventSourceList
    A list of FhirSecurityEventSource
  }
  {!.Net HL7Connect.Fhir.SecurityEventSourceList}
  TFhirSecurityEventSourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventSource;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventSource);
  public
    {!script hide}
    function Link : TFhirSecurityEventSourceList; Overload;
    function Clone : TFhirSecurityEventSourceList; Overload;
    function GetEnumerator : TFhirSecurityEventSourceListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventSource to the end of the list.
    }
    function Append : TFhirSecurityEventSource;

    
    {@member AddItem
      Add an already existing FhirSecurityEventSource to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventSource); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventSource) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventSource before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventSource;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventSource before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventSource);
    
    {@member Item
       Get the iIndexth FhirSecurityEventSource. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventSource. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventSource);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventSource;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventSources[index : Integer] : TFhirSecurityEventSource read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventObject : TFhirElement
    Specific instances of data or objects that have been accessed.
  }
  {!.Net HL7Connect.Fhir.SecurityEventObject}
  TFhirSecurityEventObject = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirIdentifier;
    FReference : TFhirResourceReference{Resource};
    FType_ : TFhirEnum;
    FRole : TFhirEnum;
    FLifecycle : TFhirEnum;
    FSensitivity : TFhirCodeableConcept;
    FName : TFhirString;
    FDescription : TFhirString;
    FQuery : TFhirBase64Binary;
    FdetailList : TFhirSecurityEventObjectDetailList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetReference(value : TFhirResourceReference{Resource});
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirObjectType;
    Procedure SetType_ST(value : TFhirObjectType);
    Procedure SetRole(value : TFhirEnum);
    Function GetRoleST : TFhirObjectRole;
    Procedure SetRoleST(value : TFhirObjectRole);
    Procedure SetLifecycle(value : TFhirEnum);
    Function GetLifecycleST : TFhirObjectLifecycle;
    Procedure SetLifecycleST(value : TFhirObjectLifecycle);
    Procedure SetSensitivity(value : TFhirCodeableConcept);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetQuery(value : TFhirBase64Binary);
    Function GetQueryST : String;
    Procedure SetQueryST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventObject; overload;
    function Clone : TFhirSecurityEventObject; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member identifier
      Identifies a specific instance of the participant object. The reference should always be version specific.
    }
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    property identifierObject : TFhirIdentifier read FIdentifier write SetIdentifier;

    {@member reference
      Identifies a specific instance of the participant object. The reference should always be version specific.
    }
    property reference : TFhirResourceReference{Resource} read FReference write SetReference;
    property referenceObject : TFhirResourceReference{Resource} read FReference write SetReference;

    {@member type_
      Object type being audited.
    }
    property type_ : TFhirObjectType read GetType_ST write SetType_ST;
    property type_Object : TFhirEnum read FType_ write SetType_;

    {@member role
      Code representing the functional application role of Participant Object being audited.
    }
    property role : TFhirObjectRole read GetRoleST write SetRoleST;
    property roleObject : TFhirEnum read FRole write SetRole;

    {@member lifecycle
      Identifier for the data life-cycle stage for the participant object.
    }
    property lifecycle : TFhirObjectLifecycle read GetLifecycleST write SetLifecycleST;
    property lifecycleObject : TFhirEnum read FLifecycle write SetLifecycle;

    {@member sensitivity
      Denotes policy-defined sensitivity for the Participant Object ID such as VIP, HIV status, mental health status or similar topics.
    }
    property sensitivity : TFhirCodeableConcept read FSensitivity write SetSensitivity;
    property sensitivityObject : TFhirCodeableConcept read FSensitivity write SetSensitivity;

    {@member name
      An instance-specific descriptor of the Participant Object ID audited, such as a person's name.
    }
    {@member name
      Typed access to An instance-specific descriptor of the Participant Object ID audited, such as a person's name.
    }
    property name : String read GetNameST write SetNameST;
    property nameObject : TFhirString read FName write SetName;

    {@member description
      Text that describes the object in more detail.
    }
    {@member description
      Typed access to Text that describes the object in more detail.
    }
    property description : String read GetDescriptionST write SetDescriptionST;
    property descriptionObject : TFhirString read FDescription write SetDescription;

    {@member query
      The actual query for a query-type participant object.
    }
    {@member query
      Typed access to The actual query for a query-type participant object.
    }
    property query : String read GetQueryST write SetQueryST;
    property queryObject : TFhirBase64Binary read FQuery write SetQuery;

    {@member detailList
      Additional Information about the Object.
    }
    property detailList : TFhirSecurityEventObjectDetailList read FDetailList;

  end;


  TFhirSecurityEventObjectListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirSecurityEventObjectList;
    function GetCurrent : TFhirSecurityEventObject;
  public
    Constructor Create(list : TFhirSecurityEventObjectList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSecurityEventObject read GetCurrent;
  end;


  {@Class TFhirSecurityEventObjectList
    A list of FhirSecurityEventObject
  }
  {!.Net HL7Connect.Fhir.SecurityEventObjectList}
  TFhirSecurityEventObjectList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventObject;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventObject);
  public
    {!script hide}
    function Link : TFhirSecurityEventObjectList; Overload;
    function Clone : TFhirSecurityEventObjectList; Overload;
    function GetEnumerator : TFhirSecurityEventObjectListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventObject to the end of the list.
    }
    function Append : TFhirSecurityEventObject;

    
    {@member AddItem
      Add an already existing FhirSecurityEventObject to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventObject); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventObject) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventObject before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventObject;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventObject before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventObject);
    
    {@member Item
       Get the iIndexth FhirSecurityEventObject. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventObject. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventObject);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventObject;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventObjects[index : Integer] : TFhirSecurityEventObject read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSecurityEventObjectDetail : TFhirElement
    Additional Information about the Object.
  }
  {!.Net HL7Connect.Fhir.SecurityEventObjectDetail}
  TFhirSecurityEventObjectDetail = class (TFhirBackboneElement)
  private
    FType_ : TFhirString;
    FValue : TFhirBase64Binary;
    Procedure SetType_(value : TFhirString);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetValue(value : TFhirBase64Binary);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSecurityEventObjectDetail; overload;
    function Clone : TFhirSecurityEventObjectDetail; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member type_
      Name of the property.
    }
    {@member type_
      Typed access to Name of the property.
    }
    property type_ : String read GetType_ST write SetType_ST;
    property type_Object : TFhirString read FType_ write SetType_;

    {@member value
      Property value.
    }
    {@member value
      Typed access to Property value.
    }
    property value : String read GetValueST write SetValueST;
    property valueObject : TFhirBase64Binary read FValue write SetValue;

  end;


  TFhirSecurityEventObjectDetailListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirSecurityEventObjectDetailList;
    function GetCurrent : TFhirSecurityEventObjectDetail;
  public
    Constructor Create(list : TFhirSecurityEventObjectDetailList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSecurityEventObjectDetail read GetCurrent;
  end;


  {@Class TFhirSecurityEventObjectDetailList
    A list of FhirSecurityEventObjectDetail
  }
  {!.Net HL7Connect.Fhir.SecurityEventObjectDetailList}
  TFhirSecurityEventObjectDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSecurityEventObjectDetail;
    procedure SetItemN(index : Integer; value : TFhirSecurityEventObjectDetail);
  public
    {!script hide}
    function Link : TFhirSecurityEventObjectDetailList; Overload;
    function Clone : TFhirSecurityEventObjectDetailList; Overload;
    function GetEnumerator : TFhirSecurityEventObjectDetailListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirSecurityEventObjectDetail to the end of the list.
    }
    function Append : TFhirSecurityEventObjectDetail;

    
    {@member AddItem
      Add an already existing FhirSecurityEventObjectDetail to the end of the list.
    }
    procedure AddItem(value : TFhirSecurityEventObjectDetail); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSecurityEventObjectDetail) : Integer;
    

    {@member Insert
      Insert FhirSecurityEventObjectDetail before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSecurityEventObjectDetail;
    

    {@member InsertItem
       Insert an existing FhirSecurityEventObjectDetail before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSecurityEventObjectDetail);
    
    {@member Item
       Get the iIndexth FhirSecurityEventObjectDetail. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSecurityEventObjectDetail. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSecurityEventObjectDetail);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSecurityEventObjectDetail;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSecurityEventObjectDetails[index : Integer] : TFhirSecurityEventObjectDetail read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSpecimenSource : TFhirElement
    Parent specimen from which the focal specimen was a component.
  }
  {!.Net HL7Connect.Fhir.SpecimenSource}
  TFhirSpecimenSource = class (TFhirBackboneElement)
  private
    FRelationship : TFhirEnum;
    FtargetList : TFhirResourceReferenceList{TFhirSpecimen};
    Procedure SetRelationship(value : TFhirEnum);
    Function GetRelationshipST : TFhirHierarchicalRelationshipType;
    Procedure SetRelationshipST(value : TFhirHierarchicalRelationshipType);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSpecimenSource; overload;
    function Clone : TFhirSpecimenSource; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member relationship
      Whether this relationship is to a parent or to a child.
    }
    property relationship : TFhirHierarchicalRelationshipType read GetRelationshipST write SetRelationshipST;
    property relationshipObject : TFhirEnum read FRelationship write SetRelationship;

    {@member targetList
      The specimen resource that is the target of this relationship.
    }
    property targetList : TFhirResourceReferenceList{TFhirSpecimen} read FTargetList;

  end;


  TFhirSpecimenSourceListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenSourceList;
    function GetCurrent : TFhirSpecimenSource;
  public
    Constructor Create(list : TFhirSpecimenSourceList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenSource read GetCurrent;
  end;


  {@Class TFhirSpecimenSourceList
    A list of FhirSpecimenSource
  }
  {!.Net HL7Connect.Fhir.SpecimenSourceList}
  TFhirSpecimenSourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenSource;
    procedure SetItemN(index : Integer; value : TFhirSpecimenSource);
  public
    {!script hide}
    function Link : TFhirSpecimenSourceList; Overload;
    function Clone : TFhirSpecimenSourceList; Overload;
    function GetEnumerator : TFhirSpecimenSourceListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirSpecimenSource to the end of the list.
    }
    function Append : TFhirSpecimenSource;

    
    {@member AddItem
      Add an already existing FhirSpecimenSource to the end of the list.
    }
    procedure AddItem(value : TFhirSpecimenSource); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSpecimenSource) : Integer;
    

    {@member Insert
      Insert FhirSpecimenSource before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSpecimenSource;
    

    {@member InsertItem
       Insert an existing FhirSpecimenSource before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSpecimenSource);
    
    {@member Item
       Get the iIndexth FhirSpecimenSource. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSpecimenSource. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenSource);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSpecimenSource;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSpecimenSources[index : Integer] : TFhirSpecimenSource read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSpecimenCollection : TFhirElement
    Details concerning the specimen collection.
  }
  {!.Net HL7Connect.Fhir.SpecimenCollection}
  TFhirSpecimenCollection = class (TFhirBackboneElement)
  private
    FCollector : TFhirResourceReference{TFhirPractitioner};
    FcommentList : TFhirStringList;
    FCollected : TFhirType;
    FQuantity : TFhirQuantity;
    FMethod : TFhirCodeableConcept;
    FSourceSite : TFhirCodeableConcept;
    Procedure SetCollector(value : TFhirResourceReference{TFhirPractitioner});
    Procedure SetCollected(value : TFhirType);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetSourceSite(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSpecimenCollection; overload;
    function Clone : TFhirSpecimenCollection; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member collector
      Person who collected the specimen.
    }
    property collector : TFhirResourceReference{TFhirPractitioner} read FCollector write SetCollector;
    property collectorObject : TFhirResourceReference{TFhirPractitioner} read FCollector write SetCollector;

    {@member commentList
      To communicate any details or issues encountered during the specimen collection procedure.
    }
    property commentList : TFhirStringList read FCommentList;

    {@member collected
      Time when specimen was collected from subject - the physiologically relevant time.
    }
    property collected : TFhirType read FCollected write SetCollected;
    property collectedObject : TFhirType read FCollected write SetCollected;

    {@member quantity
      The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    property quantityObject : TFhirQuantity read FQuantity write SetQuantity;

    {@member method
      A coded value specifying the technique that is used to perform the procedure.
    }
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    property methodObject : TFhirCodeableConcept read FMethod write SetMethod;

    {@member sourceSite
      Anatomical location from which the specimen should be collected (if subject is a patient). This element is not used for environmental specimens.
    }
    property sourceSite : TFhirCodeableConcept read FSourceSite write SetSourceSite;
    property sourceSiteObject : TFhirCodeableConcept read FSourceSite write SetSourceSite;

  end;


  TFhirSpecimenCollectionListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenCollectionList;
    function GetCurrent : TFhirSpecimenCollection;
  public
    Constructor Create(list : TFhirSpecimenCollectionList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenCollection read GetCurrent;
  end;


  {@Class TFhirSpecimenCollectionList
    A list of FhirSpecimenCollection
  }
  {!.Net HL7Connect.Fhir.SpecimenCollectionList}
  TFhirSpecimenCollectionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenCollection;
    procedure SetItemN(index : Integer; value : TFhirSpecimenCollection);
  public
    {!script hide}
    function Link : TFhirSpecimenCollectionList; Overload;
    function Clone : TFhirSpecimenCollectionList; Overload;
    function GetEnumerator : TFhirSpecimenCollectionListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirSpecimenCollection to the end of the list.
    }
    function Append : TFhirSpecimenCollection;

    
    {@member AddItem
      Add an already existing FhirSpecimenCollection to the end of the list.
    }
    procedure AddItem(value : TFhirSpecimenCollection); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSpecimenCollection) : Integer;
    

    {@member Insert
      Insert FhirSpecimenCollection before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSpecimenCollection;
    

    {@member InsertItem
       Insert an existing FhirSpecimenCollection before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSpecimenCollection);
    
    {@member Item
       Get the iIndexth FhirSpecimenCollection. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSpecimenCollection. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenCollection);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSpecimenCollection;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSpecimenCollections[index : Integer] : TFhirSpecimenCollection read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSpecimenTreatment : TFhirElement
    Details concerning treatment and processing steps for the specimen.
  }
  {!.Net HL7Connect.Fhir.SpecimenTreatment}
  TFhirSpecimenTreatment = class (TFhirBackboneElement)
  private
    FDescription : TFhirString;
    FProcedure_ : TFhirCodeableConcept;
    FadditiveList : TFhirResourceReferenceList{TFhirSubstance};
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetProcedure_(value : TFhirCodeableConcept);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSpecimenTreatment; overload;
    function Clone : TFhirSpecimenTreatment; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member description
      Textual description of procedure.
    }
    {@member description
      Typed access to Textual description of procedure.
    }
    property description : String read GetDescriptionST write SetDescriptionST;
    property descriptionObject : TFhirString read FDescription write SetDescription;

    {@member procedure_
      A coded value specifying the procedure used to process the specimen.
    }
    property procedure_ : TFhirCodeableConcept read FProcedure_ write SetProcedure_;
    property procedure_Object : TFhirCodeableConcept read FProcedure_ write SetProcedure_;

    {@member additiveList
      Material used in the processing step.
    }
    property additiveList : TFhirResourceReferenceList{TFhirSubstance} read FAdditiveList;

  end;


  TFhirSpecimenTreatmentListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenTreatmentList;
    function GetCurrent : TFhirSpecimenTreatment;
  public
    Constructor Create(list : TFhirSpecimenTreatmentList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenTreatment read GetCurrent;
  end;


  {@Class TFhirSpecimenTreatmentList
    A list of FhirSpecimenTreatment
  }
  {!.Net HL7Connect.Fhir.SpecimenTreatmentList}
  TFhirSpecimenTreatmentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenTreatment;
    procedure SetItemN(index : Integer; value : TFhirSpecimenTreatment);
  public
    {!script hide}
    function Link : TFhirSpecimenTreatmentList; Overload;
    function Clone : TFhirSpecimenTreatmentList; Overload;
    function GetEnumerator : TFhirSpecimenTreatmentListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirSpecimenTreatment to the end of the list.
    }
    function Append : TFhirSpecimenTreatment;

    
    {@member AddItem
      Add an already existing FhirSpecimenTreatment to the end of the list.
    }
    procedure AddItem(value : TFhirSpecimenTreatment); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSpecimenTreatment) : Integer;
    

    {@member Insert
      Insert FhirSpecimenTreatment before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSpecimenTreatment;
    

    {@member InsertItem
       Insert an existing FhirSpecimenTreatment before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSpecimenTreatment);
    
    {@member Item
       Get the iIndexth FhirSpecimenTreatment. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSpecimenTreatment. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenTreatment);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSpecimenTreatment;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSpecimenTreatments[index : Integer] : TFhirSpecimenTreatment read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSpecimenContainer : TFhirElement
    The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
  }
  {!.Net HL7Connect.Fhir.SpecimenContainer}
  TFhirSpecimenContainer = class (TFhirBackboneElement)
  private
    FidentifierList : TFhirIdentifierList;
    FDescription : TFhirString;
    FType_ : TFhirCodeableConcept;
    FCapacity : TFhirQuantity;
    FSpecimenQuantity : TFhirQuantity;
    FAdditive : TFhirResourceReference{TFhirSubstance};
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetCapacity(value : TFhirQuantity);
    Procedure SetSpecimenQuantity(value : TFhirQuantity);
    Procedure SetAdditive(value : TFhirResourceReference{TFhirSubstance});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSpecimenContainer; overload;
    function Clone : TFhirSpecimenContainer; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member identifierList
      Id for container. There may be multiple; a manufacturer's bar code, lab assigned identifier, etc. The container ID may differ from the specimen id in some circumstances.
    }
    property identifierList : TFhirIdentifierList read FIdentifierList;

    {@member description
      Textual description of the container.
    }
    {@member description
      Typed access to Textual description of the container.
    }
    property description : String read GetDescriptionST write SetDescriptionST;
    property descriptionObject : TFhirString read FDescription write SetDescription;

    {@member type_
      The type of container associated with the specimen (e.g. slide, aliquot, etc).
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    property type_Object : TFhirCodeableConcept read FType_ write SetType_;

    {@member capacity
      The capacity (volume or other measure) the container may contain.
    }
    property capacity : TFhirQuantity read FCapacity write SetCapacity;
    property capacityObject : TFhirQuantity read FCapacity write SetCapacity;

    {@member specimenQuantity
      The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type.
    }
    property specimenQuantity : TFhirQuantity read FSpecimenQuantity write SetSpecimenQuantity;
    property specimenQuantityObject : TFhirQuantity read FSpecimenQuantity write SetSpecimenQuantity;

    {@member additive
      Additive associated with the container.
    }
    property additive : TFhirResourceReference{TFhirSubstance} read FAdditive write SetAdditive;
    property additiveObject : TFhirResourceReference{TFhirSubstance} read FAdditive write SetAdditive;

  end;


  TFhirSpecimenContainerListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenContainerList;
    function GetCurrent : TFhirSpecimenContainer;
  public
    Constructor Create(list : TFhirSpecimenContainerList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenContainer read GetCurrent;
  end;


  {@Class TFhirSpecimenContainerList
    A list of FhirSpecimenContainer
  }
  {!.Net HL7Connect.Fhir.SpecimenContainerList}
  TFhirSpecimenContainerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenContainer;
    procedure SetItemN(index : Integer; value : TFhirSpecimenContainer);
  public
    {!script hide}
    function Link : TFhirSpecimenContainerList; Overload;
    function Clone : TFhirSpecimenContainerList; Overload;
    function GetEnumerator : TFhirSpecimenContainerListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirSpecimenContainer to the end of the list.
    }
    function Append : TFhirSpecimenContainer;

    
    {@member AddItem
      Add an already existing FhirSpecimenContainer to the end of the list.
    }
    procedure AddItem(value : TFhirSpecimenContainer); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSpecimenContainer) : Integer;
    

    {@member Insert
      Insert FhirSpecimenContainer before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSpecimenContainer;
    

    {@member InsertItem
       Insert an existing FhirSpecimenContainer before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSpecimenContainer);
    
    {@member Item
       Get the iIndexth FhirSpecimenContainer. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSpecimenContainer. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenContainer);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSpecimenContainer;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSpecimenContainers[index : Integer] : TFhirSpecimenContainer read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSubstanceInstance : TFhirElement
    Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
  }
  {!.Net HL7Connect.Fhir.SubstanceInstance}
  TFhirSubstanceInstance = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirIdentifier;
    FExpiry : TFhirDateTime;
    FQuantity : TFhirQuantity;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetExpiry(value : TFhirDateTime);
    Function GetExpiryST : TDateTimeEx;
    Procedure SetExpiryST(value : TDateTimeEx);
    Procedure SetQuantity(value : TFhirQuantity);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSubstanceInstance; overload;
    function Clone : TFhirSubstanceInstance; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member identifier
      Identifier associated with the package/container (usually a label affixed directly).
    }
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    property identifierObject : TFhirIdentifier read FIdentifier write SetIdentifier;

    {@member expiry
      When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
    }
    {@member expiry
      Typed access to When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
    }
    property expiry : TDateTimeEx read GetExpiryST write SetExpiryST;
    property expiryObject : TFhirDateTime read FExpiry write SetExpiry;

    {@member quantity
      The amount of the substance.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    property quantityObject : TFhirQuantity read FQuantity write SetQuantity;

  end;


  TFhirSubstanceInstanceListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceInstanceList;
    function GetCurrent : TFhirSubstanceInstance;
  public
    Constructor Create(list : TFhirSubstanceInstanceList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceInstance read GetCurrent;
  end;


  {@Class TFhirSubstanceInstanceList
    A list of FhirSubstanceInstance
  }
  {!.Net HL7Connect.Fhir.SubstanceInstanceList}
  TFhirSubstanceInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceInstance;
    procedure SetItemN(index : Integer; value : TFhirSubstanceInstance);
  public
    {!script hide}
    function Link : TFhirSubstanceInstanceList; Overload;
    function Clone : TFhirSubstanceInstanceList; Overload;
    function GetEnumerator : TFhirSubstanceInstanceListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirSubstanceInstance to the end of the list.
    }
    function Append : TFhirSubstanceInstance;

    
    {@member AddItem
      Add an already existing FhirSubstanceInstance to the end of the list.
    }
    procedure AddItem(value : TFhirSubstanceInstance); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSubstanceInstance) : Integer;
    

    {@member Insert
      Insert FhirSubstanceInstance before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSubstanceInstance;
    

    {@member InsertItem
       Insert an existing FhirSubstanceInstance before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSubstanceInstance);
    
    {@member Item
       Get the iIndexth FhirSubstanceInstance. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSubstanceInstance. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceInstance);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSubstanceInstance;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSubstanceInstances[index : Integer] : TFhirSubstanceInstance read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSubstanceIngredient : TFhirElement
    A substance can be composed of other substances.
  }
  {!.Net HL7Connect.Fhir.SubstanceIngredient}
  TFhirSubstanceIngredient = class (TFhirBackboneElement)
  private
    FQuantity : TFhirRatio;
    FSubstance : TFhirResourceReference{TFhirSubstance};
    Procedure SetQuantity(value : TFhirRatio);
    Procedure SetSubstance(value : TFhirResourceReference{TFhirSubstance});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSubstanceIngredient; overload;
    function Clone : TFhirSubstanceIngredient; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member quantity
      The amount of the ingredient in the substance - a concentration ratio.
    }
    property quantity : TFhirRatio read FQuantity write SetQuantity;
    property quantityObject : TFhirRatio read FQuantity write SetQuantity;

    {@member substance
      Another substance that is a component of this substance.
    }
    property substance : TFhirResourceReference{TFhirSubstance} read FSubstance write SetSubstance;
    property substanceObject : TFhirResourceReference{TFhirSubstance} read FSubstance write SetSubstance;

  end;


  TFhirSubstanceIngredientListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceIngredientList;
    function GetCurrent : TFhirSubstanceIngredient;
  public
    Constructor Create(list : TFhirSubstanceIngredientList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceIngredient read GetCurrent;
  end;


  {@Class TFhirSubstanceIngredientList
    A list of FhirSubstanceIngredient
  }
  {!.Net HL7Connect.Fhir.SubstanceIngredientList}
  TFhirSubstanceIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceIngredient;
    procedure SetItemN(index : Integer; value : TFhirSubstanceIngredient);
  public
    {!script hide}
    function Link : TFhirSubstanceIngredientList; Overload;
    function Clone : TFhirSubstanceIngredientList; Overload;
    function GetEnumerator : TFhirSubstanceIngredientListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirSubstanceIngredient to the end of the list.
    }
    function Append : TFhirSubstanceIngredient;

    
    {@member AddItem
      Add an already existing FhirSubstanceIngredient to the end of the list.
    }
    procedure AddItem(value : TFhirSubstanceIngredient); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSubstanceIngredient) : Integer;
    

    {@member Insert
      Insert FhirSubstanceIngredient before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSubstanceIngredient;
    

    {@member InsertItem
       Insert an existing FhirSubstanceIngredient before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSubstanceIngredient);
    
    {@member Item
       Get the iIndexth FhirSubstanceIngredient. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSubstanceIngredient. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceIngredient);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSubstanceIngredient;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSubstanceIngredients[index : Integer] : TFhirSubstanceIngredient read GetItemN write SetItemN; default;
  End;


  {@Class TFhirSupplyDispense : TFhirElement
    Indicates the details of the dispense event such as the days supply and quantity of a supply dispensed.
  }
  {!.Net HL7Connect.Fhir.SupplyDispense}
  TFhirSupplyDispense = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FSuppliedItem : TFhirResourceReference{Resource};
    FSupplier : TFhirResourceReference{TFhirPractitioner};
    FWhenPrepared : TFhirPeriod;
    FWhenHandedOver : TFhirPeriod;
    FDestination : TFhirResourceReference{TFhirLocation};
    FreceiverList : TFhirResourceReferenceList{TFhirPractitioner};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirValuesetSupplyDispenseStatus;
    Procedure SetStatusST(value : TFhirValuesetSupplyDispenseStatus);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetSuppliedItem(value : TFhirResourceReference{Resource});
    Procedure SetSupplier(value : TFhirResourceReference{TFhirPractitioner});
    Procedure SetWhenPrepared(value : TFhirPeriod);
    Procedure SetWhenHandedOver(value : TFhirPeriod);
    Procedure SetDestination(value : TFhirResourceReference{TFhirLocation});
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirSupplyDispense; overload;
    function Clone : TFhirSupplyDispense; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member identifier
      Identifier assigned by the dispensing facility when the dispense occurs.
    }
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    property identifierObject : TFhirIdentifier read FIdentifier write SetIdentifier;

    {@member status
      A code specifying the state of the dispense event.
    }
    property status : TFhirValuesetSupplyDispenseStatus read GetStatusST write SetStatusST;
    property statusObject : TFhirEnum read FStatus write SetStatus;

    {@member type_
      Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    }
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    property type_Object : TFhirCodeableConcept read FType_ write SetType_;

    {@member quantity
      The amount of supply that has been dispensed. Includes unit of measure.
    }
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    property quantityObject : TFhirQuantity read FQuantity write SetQuantity;

    {@member suppliedItem
      Identifies the medication or substance being dispensed. This is either a link to a resource representing the details of the medication or substance or a simple attribute carrying a code that identifies the medication from a known list of medications.
    }
    property suppliedItem : TFhirResourceReference{Resource} read FSuppliedItem write SetSuppliedItem;
    property suppliedItemObject : TFhirResourceReference{Resource} read FSuppliedItem write SetSuppliedItem;

    {@member supplier
      The individual responsible for dispensing the medication.
    }
    property supplier : TFhirResourceReference{TFhirPractitioner} read FSupplier write SetSupplier;
    property supplierObject : TFhirResourceReference{TFhirPractitioner} read FSupplier write SetSupplier;

    {@member whenPrepared
      The time the dispense event occurred.
    }
    property whenPrepared : TFhirPeriod read FWhenPrepared write SetWhenPrepared;
    property whenPreparedObject : TFhirPeriod read FWhenPrepared write SetWhenPrepared;

    {@member whenHandedOver
      The time the dispensed item was sent or handed to the patient (or agent).
    }
    property whenHandedOver : TFhirPeriod read FWhenHandedOver write SetWhenHandedOver;
    property whenHandedOverObject : TFhirPeriod read FWhenHandedOver write SetWhenHandedOver;

    {@member destination
      Identification of the facility/location where the Supply was shipped to, as part of the dispense event.
    }
    property destination : TFhirResourceReference{TFhirLocation} read FDestination write SetDestination;
    property destinationObject : TFhirResourceReference{TFhirLocation} read FDestination write SetDestination;

    {@member receiverList
      Identifies the person who picked up the Supply.
    }
    property receiverList : TFhirResourceReferenceList{TFhirPractitioner} read FReceiverList;

  end;


  TFhirSupplyDispenseListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirSupplyDispenseList;
    function GetCurrent : TFhirSupplyDispense;
  public
    Constructor Create(list : TFhirSupplyDispenseList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyDispense read GetCurrent;
  end;


  {@Class TFhirSupplyDispenseList
    A list of FhirSupplyDispense
  }
  {!.Net HL7Connect.Fhir.SupplyDispenseList}
  TFhirSupplyDispenseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSupplyDispense;
    procedure SetItemN(index : Integer; value : TFhirSupplyDispense);
  public
    {!script hide}
    function Link : TFhirSupplyDispenseList; Overload;
    function Clone : TFhirSupplyDispenseList; Overload;
    function GetEnumerator : TFhirSupplyDispenseListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirSupplyDispense to the end of the list.
    }
    function Append : TFhirSupplyDispense;

    
    {@member AddItem
      Add an already existing FhirSupplyDispense to the end of the list.
    }
    procedure AddItem(value : TFhirSupplyDispense); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirSupplyDispense) : Integer;
    

    {@member Insert
      Insert FhirSupplyDispense before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirSupplyDispense;
    

    {@member InsertItem
       Insert an existing FhirSupplyDispense before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirSupplyDispense);
    
    {@member Item
       Get the iIndexth FhirSupplyDispense. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirSupplyDispense. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyDispense);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirSupplyDispense;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirSupplyDispenses[index : Integer] : TFhirSupplyDispense read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetDefine : TFhirElement
    When value set defines its own codes.
  }
  {!.Net HL7Connect.Fhir.ValueSetDefine}
  TFhirValueSetDefine = class (TFhirBackboneElement)
  private
    FSystem : TFhirUri;
    FVersion : TFhirString;
    FCaseSensitive : TFhirBoolean;
    FconceptList : TFhirValueSetDefineConceptList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetCaseSensitive(value : TFhirBoolean);
    Function GetCaseSensitiveST : Boolean;
    Procedure SetCaseSensitiveST(value : Boolean);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetDefine; overload;
    function Clone : TFhirValueSetDefine; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member system
      URI to identify the code system.
    }
    {@member system
      Typed access to URI to identify the code system.
    }
    property system : String read GetSystemST write SetSystemST;
    property systemObject : TFhirUri read FSystem write SetSystem;

    {@member version
      The version of this code system that defines the codes. Note that the version is optional because a well maintained code system does not suffer from versioning, and therefore the version does not need to be maintained. However many code systems are not well maintained, and the version needs to be defined and tracked.
    }
    {@member version
      Typed access to The version of this code system that defines the codes. Note that the version is optional because a well maintained code system does not suffer from versioning, and therefore the version does not need to be maintained. However many code systems are not well maintained, and the version needs to be defined and tracked.
    }
    property version : String read GetVersionST write SetVersionST;
    property versionObject : TFhirString read FVersion write SetVersion;

    {@member caseSensitive
      If code comparison is case sensitive when codes within this system are compared to each other.
    }
    {@member caseSensitive
      Typed access to If code comparison is case sensitive when codes within this system are compared to each other.
    }
    property caseSensitive : Boolean read GetCaseSensitiveST write SetCaseSensitiveST;
    property caseSensitiveObject : TFhirBoolean read FCaseSensitive write SetCaseSensitive;

    {@member conceptList
      Concepts in the code system.
    }
    property conceptList : TFhirValueSetDefineConceptList read FConceptList;

  end;


  TFhirValueSetDefineListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirValueSetDefineList;
    function GetCurrent : TFhirValueSetDefine;
  public
    Constructor Create(list : TFhirValueSetDefineList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetDefine read GetCurrent;
  end;


  {@Class TFhirValueSetDefineList
    A list of FhirValueSetDefine
  }
  {!.Net HL7Connect.Fhir.ValueSetDefineList}
  TFhirValueSetDefineList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetDefine;
    procedure SetItemN(index : Integer; value : TFhirValueSetDefine);
  public
    {!script hide}
    function Link : TFhirValueSetDefineList; Overload;
    function Clone : TFhirValueSetDefineList; Overload;
    function GetEnumerator : TFhirValueSetDefineListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirValueSetDefine to the end of the list.
    }
    function Append : TFhirValueSetDefine;

    
    {@member AddItem
      Add an already existing FhirValueSetDefine to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetDefine); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetDefine) : Integer;
    

    {@member Insert
      Insert FhirValueSetDefine before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetDefine;
    

    {@member InsertItem
       Insert an existing FhirValueSetDefine before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetDefine);
    
    {@member Item
       Get the iIndexth FhirValueSetDefine. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetDefine. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetDefine);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetDefine;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetDefines[index : Integer] : TFhirValueSetDefine read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetDefineConcept : TFhirElement
    Concepts in the code system.
  }
  {!.Net HL7Connect.Fhir.ValueSetDefineConcept}
  TFhirValueSetDefineConcept = class (TFhirBackboneElement)
  private
    FCode : TFhirCode;
    FAbstract : TFhirBoolean;
    FDisplay : TFhirString;
    FDefinition : TFhirString;
    FconceptList : TFhirValueSetDefineConceptList;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetAbstract(value : TFhirBoolean);
    Function GetAbstractST : Boolean;
    Procedure SetAbstractST(value : Boolean);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetDefinition(value : TFhirString);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetDefineConcept; overload;
    function Clone : TFhirValueSetDefineConcept; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member code
      Code that identifies concept.
    }
    {@member code
      Typed access to Code that identifies concept.
    }
    property code : String read GetCodeST write SetCodeST;
    property codeObject : TFhirCode read FCode write SetCode;

    {@member abstract
      If this code is not for use as a real concept.
    }
    {@member abstract
      Typed access to If this code is not for use as a real concept.
    }
    property abstract : Boolean read GetAbstractST write SetAbstractST;
    property abstractObject : TFhirBoolean read FAbstract write SetAbstract;

    {@member display
      Text to Display to the user.
    }
    {@member display
      Typed access to Text to Display to the user.
    }
    property display : String read GetDisplayST write SetDisplayST;
    property displayObject : TFhirString read FDisplay write SetDisplay;

    {@member definition
      The formal definition of the concept. Formal definitions are not required, because of the prevalence of legacy systems without them, but they are highly recommended, as without them there is no formal meaning associated with the concept.
    }
    {@member definition
      Typed access to The formal definition of the concept. Formal definitions are not required, because of the prevalence of legacy systems without them, but they are highly recommended, as without them there is no formal meaning associated with the concept.
    }
    property definition : String read GetDefinitionST write SetDefinitionST;
    property definitionObject : TFhirString read FDefinition write SetDefinition;

    {@member conceptList
      Child Concepts (is-a / contains).
    }
    property conceptList : TFhirValueSetDefineConceptList read FConceptList;

  end;


  TFhirValueSetDefineConceptListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirValueSetDefineConceptList;
    function GetCurrent : TFhirValueSetDefineConcept;
  public
    Constructor Create(list : TFhirValueSetDefineConceptList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetDefineConcept read GetCurrent;
  end;


  {@Class TFhirValueSetDefineConceptList
    A list of FhirValueSetDefineConcept
  }
  {!.Net HL7Connect.Fhir.ValueSetDefineConceptList}
  TFhirValueSetDefineConceptList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetDefineConcept;
    procedure SetItemN(index : Integer; value : TFhirValueSetDefineConcept);
  public
    {!script hide}
    function Link : TFhirValueSetDefineConceptList; Overload;
    function Clone : TFhirValueSetDefineConceptList; Overload;
    function GetEnumerator : TFhirValueSetDefineConceptListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirValueSetDefineConcept to the end of the list.
    }
    function Append : TFhirValueSetDefineConcept;

    
    {@member AddItem
      Add an already existing FhirValueSetDefineConcept to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetDefineConcept); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetDefineConcept) : Integer;
    

    {@member Insert
      Insert FhirValueSetDefineConcept before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetDefineConcept;
    

    {@member InsertItem
       Insert an existing FhirValueSetDefineConcept before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetDefineConcept);
    
    {@member Item
       Get the iIndexth FhirValueSetDefineConcept. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetDefineConcept. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetDefineConcept);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetDefineConcept;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetDefineConcepts[index : Integer] : TFhirValueSetDefineConcept read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetCompose : TFhirElement
    When value set includes codes from elsewhere.
  }
  {!.Net HL7Connect.Fhir.ValueSetCompose}
  TFhirValueSetCompose = class (TFhirBackboneElement)
  private
    FimportList : TFhirUriList;
    FincludeList : TFhirValueSetComposeIncludeList;
    FexcludeList : TFhirValueSetComposeIncludeList;
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetCompose; overload;
    function Clone : TFhirValueSetCompose; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member importList
      Includes the contents of the referenced value set as a part of the contents of this value set.
    }
    property importList : TFhirUriList read FImportList;

    {@member includeList
      Include one or more codes from a code system.
    }
    property includeList : TFhirValueSetComposeIncludeList read FIncludeList;

    {@member excludeList
      Exclude one or more codes from the value set.
    }
    property excludeList : TFhirValueSetComposeIncludeList read FExcludeList;

  end;


  TFhirValueSetComposeListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeList;
    function GetCurrent : TFhirValueSetCompose;
  public
    Constructor Create(list : TFhirValueSetComposeList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetCompose read GetCurrent;
  end;


  {@Class TFhirValueSetComposeList
    A list of FhirValueSetCompose
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeList}
  TFhirValueSetComposeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetCompose;
    procedure SetItemN(index : Integer; value : TFhirValueSetCompose);
  public
    {!script hide}
    function Link : TFhirValueSetComposeList; Overload;
    function Clone : TFhirValueSetComposeList; Overload;
    function GetEnumerator : TFhirValueSetComposeListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirValueSetCompose to the end of the list.
    }
    function Append : TFhirValueSetCompose;

    
    {@member AddItem
      Add an already existing FhirValueSetCompose to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetCompose); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetCompose) : Integer;
    

    {@member Insert
      Insert FhirValueSetCompose before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetCompose;
    

    {@member InsertItem
       Insert an existing FhirValueSetCompose before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetCompose);
    
    {@member Item
       Get the iIndexth FhirValueSetCompose. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetCompose. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetCompose);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetCompose;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetComposes[index : Integer] : TFhirValueSetCompose read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetComposeInclude : TFhirElement
    Include one or more codes from a code system.
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeInclude}
  TFhirValueSetComposeInclude = class (TFhirBackboneElement)
  private
    FSystem : TFhirUri;
    FVersion : TFhirString;
    FcodeList : TFhirCodeList;
    FfilterList : TFhirValueSetComposeIncludeFilterList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetComposeInclude; overload;
    function Clone : TFhirValueSetComposeInclude; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member system
      The code system from which the selected codes come from.
    }
    {@member system
      Typed access to The code system from which the selected codes come from.
    }
    property system : String read GetSystemST write SetSystemST;
    property systemObject : TFhirUri read FSystem write SetSystem;

    {@member version
      The version of the code system that the codes are selected from.
    }
    {@member version
      Typed access to The version of the code system that the codes are selected from.
    }
    property version : String read GetVersionST write SetVersionST;
    property versionObject : TFhirString read FVersion write SetVersion;

    {@member codeList
      Specifies a code or concept to be included or excluded. The list of codes is considered ordered, though the order may not have any particular significance.
    }
    property codeList : TFhirCodeList read FCodeList;

    {@member filterList
      Select concepts by specify a matching criteria based on the properties (including relationships) defined by the system. If multiple filters are specified, they SHALL all be true.
    }
    property filterList : TFhirValueSetComposeIncludeFilterList read FFilterList;

  end;


  TFhirValueSetComposeIncludeListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeIncludeList;
    function GetCurrent : TFhirValueSetComposeInclude;
  public
    Constructor Create(list : TFhirValueSetComposeIncludeList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetComposeInclude read GetCurrent;
  end;


  {@Class TFhirValueSetComposeIncludeList
    A list of FhirValueSetComposeInclude
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeIncludeList}
  TFhirValueSetComposeIncludeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetComposeInclude;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeInclude);
  public
    {!script hide}
    function Link : TFhirValueSetComposeIncludeList; Overload;
    function Clone : TFhirValueSetComposeIncludeList; Overload;
    function GetEnumerator : TFhirValueSetComposeIncludeListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirValueSetComposeInclude to the end of the list.
    }
    function Append : TFhirValueSetComposeInclude;

    
    {@member AddItem
      Add an already existing FhirValueSetComposeInclude to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetComposeInclude); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetComposeInclude) : Integer;
    

    {@member Insert
      Insert FhirValueSetComposeInclude before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetComposeInclude;
    

    {@member InsertItem
       Insert an existing FhirValueSetComposeInclude before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeInclude);
    
    {@member Item
       Get the iIndexth FhirValueSetComposeInclude. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetComposeInclude. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeInclude);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetComposeInclude;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetComposeIncludes[index : Integer] : TFhirValueSetComposeInclude read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetComposeIncludeFilter : TFhirElement
    Select concepts by specify a matching criteria based on the properties (including relationships) defined by the system. If multiple filters are specified, they SHALL all be true.
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeIncludeFilter}
  TFhirValueSetComposeIncludeFilter = class (TFhirBackboneElement)
  private
    FProperty_ : TFhirCode;
    FOp : TFhirEnum;
    FValue : TFhirCode;
    Procedure SetProperty_(value : TFhirCode);
    Function GetProperty_ST : String;
    Procedure SetProperty_ST(value : String);
    Procedure SetOp(value : TFhirEnum);
    Function GetOpST : TFhirFilterOperator;
    Procedure SetOpST(value : TFhirFilterOperator);
    Procedure SetValue(value : TFhirCode);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetComposeIncludeFilter; overload;
    function Clone : TFhirValueSetComposeIncludeFilter; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member property_
      A code that identifies a property defined in the code system.
    }
    {@member property_
      Typed access to A code that identifies a property defined in the code system.
    }
    property property_ : String read GetProperty_ST write SetProperty_ST;
    property property_Object : TFhirCode read FProperty_ write SetProperty_;

    {@member op
      The kind of operation to perform as a part of the filter criteria.
    }
    property op : TFhirFilterOperator read GetOpST write SetOpST;
    property opObject : TFhirEnum read FOp write SetOp;

    {@member value
      The match value may be either a code defined by the system, or a string value which is used a regex match on the literal string of the property value.
    }
    {@member value
      Typed access to The match value may be either a code defined by the system, or a string value which is used a regex match on the literal string of the property value.
    }
    property value : String read GetValueST write SetValueST;
    property valueObject : TFhirCode read FValue write SetValue;

  end;


  TFhirValueSetComposeIncludeFilterListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeIncludeFilterList;
    function GetCurrent : TFhirValueSetComposeIncludeFilter;
  public
    Constructor Create(list : TFhirValueSetComposeIncludeFilterList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetComposeIncludeFilter read GetCurrent;
  end;


  {@Class TFhirValueSetComposeIncludeFilterList
    A list of FhirValueSetComposeIncludeFilter
  }
  {!.Net HL7Connect.Fhir.ValueSetComposeIncludeFilterList}
  TFhirValueSetComposeIncludeFilterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetComposeIncludeFilter;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeIncludeFilter);
  public
    {!script hide}
    function Link : TFhirValueSetComposeIncludeFilterList; Overload;
    function Clone : TFhirValueSetComposeIncludeFilterList; Overload;
    function GetEnumerator : TFhirValueSetComposeIncludeFilterListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirValueSetComposeIncludeFilter to the end of the list.
    }
    function Append : TFhirValueSetComposeIncludeFilter;

    
    {@member AddItem
      Add an already existing FhirValueSetComposeIncludeFilter to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetComposeIncludeFilter); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetComposeIncludeFilter) : Integer;
    

    {@member Insert
      Insert FhirValueSetComposeIncludeFilter before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetComposeIncludeFilter;
    

    {@member InsertItem
       Insert an existing FhirValueSetComposeIncludeFilter before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeIncludeFilter);
    
    {@member Item
       Get the iIndexth FhirValueSetComposeIncludeFilter. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetComposeIncludeFilter. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeIncludeFilter);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetComposeIncludeFilter;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetComposeIncludeFilters[index : Integer] : TFhirValueSetComposeIncludeFilter read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetExpansion : TFhirElement
    When value set is an expansion.
  }
  {!.Net HL7Connect.Fhir.ValueSetExpansion}
  TFhirValueSetExpansion = class (TFhirBackboneElement)
  private
    FIdentifier : TFhirIdentifier;
    FTimestamp : TFhirInstant;
    FcontainsList : TFhirValueSetExpansionContainsList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetTimestamp(value : TFhirInstant);
    Function GetTimestampST : TDateTimeEx;
    Procedure SetTimestampST(value : TDateTimeEx);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetExpansion; overload;
    function Clone : TFhirValueSetExpansion; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member identifier
      An identifier that uniquely identifies this expansion of the valueset. Systems may re-use the same identifier as long as the expansion and the definition remain the same, but are not required to do so.
    }
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    property identifierObject : TFhirIdentifier read FIdentifier write SetIdentifier;

    {@member timestamp
      Time valueset expansion happened.
    }
    {@member timestamp
      Typed access to Time valueset expansion happened.
    }
    property timestamp : TDateTimeEx read GetTimestampST write SetTimestampST;
    property timestampObject : TFhirInstant read FTimestamp write SetTimestamp;

    {@member containsList
      Codes in the value set.
    }
    property containsList : TFhirValueSetExpansionContainsList read FContainsList;

  end;


  TFhirValueSetExpansionListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirValueSetExpansionList;
    function GetCurrent : TFhirValueSetExpansion;
  public
    Constructor Create(list : TFhirValueSetExpansionList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetExpansion read GetCurrent;
  end;


  {@Class TFhirValueSetExpansionList
    A list of FhirValueSetExpansion
  }
  {!.Net HL7Connect.Fhir.ValueSetExpansionList}
  TFhirValueSetExpansionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetExpansion;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansion);
  public
    {!script hide}
    function Link : TFhirValueSetExpansionList; Overload;
    function Clone : TFhirValueSetExpansionList; Overload;
    function GetEnumerator : TFhirValueSetExpansionListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirValueSetExpansion to the end of the list.
    }
    function Append : TFhirValueSetExpansion;

    
    {@member AddItem
      Add an already existing FhirValueSetExpansion to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetExpansion); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetExpansion) : Integer;
    

    {@member Insert
      Insert FhirValueSetExpansion before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetExpansion;
    

    {@member InsertItem
       Insert an existing FhirValueSetExpansion before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansion);
    
    {@member Item
       Get the iIndexth FhirValueSetExpansion. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetExpansion. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansion);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetExpansion;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetExpansions[index : Integer] : TFhirValueSetExpansion read GetItemN write SetItemN; default;
  End;


  {@Class TFhirValueSetExpansionContains : TFhirElement
    Codes in the value set.
  }
  {!.Net HL7Connect.Fhir.ValueSetExpansionContains}
  TFhirValueSetExpansionContains = class (TFhirBackboneElement)
  private
    FSystem : TFhirUri;
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FcontainsList : TFhirValueSetExpansionContainsList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRObjectList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    {!script hide}
    procedure Assign(oSource : TAdvObject); override;
    function Link : TFhirValueSetExpansionContains; overload;
    function Clone : TFhirValueSetExpansionContains; overload;
    procedure setProperty(propName : string; propValue : TFHIRObject); override;
    function FhirType : string; override;
    {!script show}
  published
    {@member system
      System value for the code.
    }
    {@member system
      Typed access to System value for the code.
    }
    property system : String read GetSystemST write SetSystemST;
    property systemObject : TFhirUri read FSystem write SetSystem;

    {@member code
      Code - if blank, this is not a choosable code.
    }
    {@member code
      Typed access to Code - if blank, this is not a choosable code.
    }
    property code : String read GetCodeST write SetCodeST;
    property codeObject : TFhirCode read FCode write SetCode;

    {@member display
      User display for the concept.
    }
    {@member display
      Typed access to User display for the concept.
    }
    property display : String read GetDisplayST write SetDisplayST;
    property displayObject : TFhirString read FDisplay write SetDisplay;

    {@member containsList
      Codes contained in this concept.
    }
    property containsList : TFhirValueSetExpansionContainsList read FContainsList;

  end;


  TFhirValueSetExpansionContainsListEnumerator = class (TAdvObject)
  private
    FIndex : integer;
    FList : TFhirValueSetExpansionContainsList;
    function GetCurrent : TFhirValueSetExpansionContains;
  public
    Constructor Create(list : TFhirValueSetExpansionContainsList);
    Destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetExpansionContains read GetCurrent;
  end;


  {@Class TFhirValueSetExpansionContainsList
    A list of FhirValueSetExpansionContains
  }
  {!.Net HL7Connect.Fhir.ValueSetExpansionContainsList}
  TFhirValueSetExpansionContainsList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirValueSetExpansionContains;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansionContains);
  public
    {!script hide}
    function Link : TFhirValueSetExpansionContainsList; Overload;
    function Clone : TFhirValueSetExpansionContainsList; Overload;
    function GetEnumerator : TFhirValueSetExpansionContainsListEnumerator;
    {!script show}
    

    {@member Append
      Add a FhirValueSetExpansionContains to the end of the list.
    }
    function Append : TFhirValueSetExpansionContains;

    
    {@member AddItem
      Add an already existing FhirValueSetExpansionContains to the end of the list.
    }
    procedure AddItem(value : TFhirValueSetExpansionContains); overload;

    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    
    {@member IndexOf
      See if an item is already in the list. returns -1 if not in the list
    }
    function IndexOf(value : TFhirValueSetExpansionContains) : Integer;
    

    {@member Insert
      Insert FhirValueSetExpansionContains before the designated index (0 = first item)
    }
    function Insert(index : Integer) : TFhirValueSetExpansionContains;
    

    {@member InsertItem
       Insert an existing FhirValueSetExpansionContains before the designated index (0 = first item)
    }
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansionContains);
    
    {@member Item
       Get the iIndexth FhirValueSetExpansionContains. (0 = first item)
    }
    
    {@member Item
       Get the iIndexth FhirValueSetExpansionContains. (0 = first item)
    }
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansionContains);
    
    {@member Count
      The number of items in the collection
    }
    function Item(index : Integer) : TFhirValueSetExpansionContains;
    
    {@member Count
      The number of items in the collection
    }
    function Count : Integer; Overload;
    
    {@member remove
      Remove the indexth item. The first item is index 0.
    }
    procedure Remove(index : Integer);
    {@member ClearItems
      Remove All Items from the list
    }
    procedure ClearItems;
    
    Property FhirValueSetExpansionContains[index : Integer] : TFhirValueSetExpansionContains read GetItemN write SetItemN; default;
  End;


implementation

{ TFhirAdverseReactionSymptom }

constructor TFhirAdverseReactionSymptom.Create;
begin
  inherited;
end;

destructor TFhirAdverseReactionSymptom.Destroy;
begin
  FCode.free;
  FSeverity.free;
  inherited;
end;

procedure TFhirAdverseReactionSymptom.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirAdverseReactionSymptom(oSource).code.Clone;
  FSeverity := TFhirAdverseReactionSymptom(oSource).FSeverity.Link;
end;

procedure TFhirAdverseReactionSymptom.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'severity') Then
     list.add(FSeverity.Link);
end;

procedure TFhirAdverseReactionSymptom.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'severity', 'code', FSeverity.Link));{1}
end;

procedure TFhirAdverseReactionSymptom.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then Code := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'severity') then SeverityObject := propValue as TFHIREnum
  else inherited;
end;

function TFhirAdverseReactionSymptom.FhirType : string;
begin
  result := 'symptom';
end;

function TFhirAdverseReactionSymptom.Link : TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom(inherited Link);
end;

function TFhirAdverseReactionSymptom.Clone : TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom(inherited Clone);
end;

{ TFhirAdverseReactionSymptom }

Procedure TFhirAdverseReactionSymptom.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirAdverseReactionSymptom.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirAdverseReactionSymptom.GetSeverityST : TFhirReactionSeverity;
begin
  if FSeverity = nil then
    result := TFhirReactionSeverity(0)
  else
    result := TFhirReactionSeverity(StringArrayIndexOfSensitive(CODES_TFhirReactionSeverity, FSeverity.value));
end;

Procedure TFhirAdverseReactionSymptom.SetSeverityST(value : TFhirReactionSeverity);
begin
  if ord(value) = 0 then
    SeverityObject := nil
  else
    SeverityObject := TFhirEnum.create(CODES_TFhirReactionSeverity[value]);
end;


{ TFhirAdverseReactionSymptomListEnumerator }

Constructor TFhirAdverseReactionSymptomListEnumerator.Create(list : TFhirAdverseReactionSymptomList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirAdverseReactionSymptomListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseReactionSymptomListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirAdverseReactionSymptomListEnumerator.GetCurrent : TFhirAdverseReactionSymptom;
begin
  Result := FList[FIndex];
end;


{ TFhirAdverseReactionSymptomList }
procedure TFhirAdverseReactionSymptomList.AddItem(value: TFhirAdverseReactionSymptom);
begin
  assert(value.ClassName = 'TFhirAdverseReactionSymptom', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseReactionSymptom');
  add(value);
end;


function TFhirAdverseReactionSymptomList.Append: TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirAdverseReactionSymptomList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseReactionSymptomList.GetEnumerator : TFhirAdverseReactionSymptomListEnumerator;
begin
  result := TFhirAdverseReactionSymptomListEnumerator.Create(self.link);
end;

function TFhirAdverseReactionSymptomList.Clone: TFhirAdverseReactionSymptomList;
begin
  result := TFhirAdverseReactionSymptomList(inherited Clone);
end;

function TFhirAdverseReactionSymptomList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseReactionSymptomList.GetItemN(index: Integer): TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom(ObjectByIndex[index]);
end;

function TFhirAdverseReactionSymptomList.IndexOf(value: TFhirAdverseReactionSymptom): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirAdverseReactionSymptomList.Insert(index: Integer): TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirAdverseReactionSymptomList.InsertItem(index: Integer; value: TFhirAdverseReactionSymptom);
begin
  assert(value is TFhirAdverseReactionSymptom);
  Inherited Insert(index, value);
end;

function TFhirAdverseReactionSymptomList.Item(index: Integer): TFhirAdverseReactionSymptom;
begin
  result := TFhirAdverseReactionSymptom(ObjectByIndex[index]);
end;

function TFhirAdverseReactionSymptomList.Link: TFhirAdverseReactionSymptomList;
begin
  result := TFhirAdverseReactionSymptomList(inherited Link);
end;

procedure TFhirAdverseReactionSymptomList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseReactionSymptomList.SetItemByIndex(index: Integer; value: TFhirAdverseReactionSymptom);
begin
  assert(value is TFhirAdverseReactionSymptom);
  FhirAdverseReactionSymptoms[index] := value;
end;

procedure TFhirAdverseReactionSymptomList.SetItemN(index: Integer; value: TFhirAdverseReactionSymptom);
begin
  assert(value is TFhirAdverseReactionSymptom);
  ObjectByIndex[index] := value;
end;

{ TFhirAdverseReactionExposure }

constructor TFhirAdverseReactionExposure.Create;
begin
  inherited;
end;

destructor TFhirAdverseReactionExposure.Destroy;
begin
  FDate.free;
  FType_.free;
  FCausalityExpectation.free;
  FSubstance.free;
  inherited;
end;

procedure TFhirAdverseReactionExposure.Assign(oSource : TAdvObject);
begin
  inherited;
  dateObject := TFhirAdverseReactionExposure(oSource).dateObject.Clone;
  FType_ := TFhirAdverseReactionExposure(oSource).FType_.Link;
  FCausalityExpectation := TFhirAdverseReactionExposure(oSource).FCausalityExpectation.Link;
  substance := TFhirAdverseReactionExposure(oSource).substance.Clone;
end;

procedure TFhirAdverseReactionExposure.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(FDate.Link);
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'causalityExpectation') Then
     list.add(FCausalityExpectation.Link);
  if (child_name = 'substance') Then
     list.add(FSubstance.Link);
end;

procedure TFhirAdverseReactionExposure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'causalityExpectation', 'code', FCausalityExpectation.Link));{1}
  oList.add(TFHIRProperty.create(self, 'substance', 'Resource(Substance)', FSubstance.Link));{2}
end;

procedure TFhirAdverseReactionExposure.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'date') then DateObject := propValue as TFhirDateTime{5a}
  else if (propName = 'type') then Type_Object := propValue as TFHIREnum
  else if (propName = 'causalityExpectation') then CausalityExpectationObject := propValue as TFHIREnum
  else if (propName = 'substance') then Substance := propValue as TFhirResourceReference{TFhirSubstance}{4b}
  else inherited;
end;

function TFhirAdverseReactionExposure.FhirType : string;
begin
  result := 'exposure';
end;

function TFhirAdverseReactionExposure.Link : TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure(inherited Link);
end;

function TFhirAdverseReactionExposure.Clone : TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure(inherited Clone);
end;

{ TFhirAdverseReactionExposure }

Procedure TFhirAdverseReactionExposure.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirAdverseReactionExposure.GetDateST : TDateTimeEx;
begin
  if FDate = nil then
    result := nil
  else
    result := FDate.value;
end;

Procedure TFhirAdverseReactionExposure.SetDateST(value : TDateTimeEx);
begin
  if value <> nil then
  begin
    if FDate = nil then
      FDate := TFhirDateTime.create;
    FDate.value := value
  end
  else if FDate <> nil then
    FDate.value := nil;
end;

Procedure TFhirAdverseReactionExposure.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAdverseReactionExposure.GetType_ST : TFhirExposureType;
begin
  if FType_ = nil then
    result := TFhirExposureType(0)
  else
    result := TFhirExposureType(StringArrayIndexOfSensitive(CODES_TFhirExposureType, FType_.value));
end;

Procedure TFhirAdverseReactionExposure.SetType_ST(value : TFhirExposureType);
begin
  if ord(value) = 0 then
    Type_Object := nil
  else
    Type_Object := TFhirEnum.create(CODES_TFhirExposureType[value]);
end;

Procedure TFhirAdverseReactionExposure.SetCausalityExpectation(value : TFhirEnum);
begin
  FCausalityExpectation.free;
  FCausalityExpectation := value;
end;

Function TFhirAdverseReactionExposure.GetCausalityExpectationST : TFhirCausalityExpectation;
begin
  if FCausalityExpectation = nil then
    result := TFhirCausalityExpectation(0)
  else
    result := TFhirCausalityExpectation(StringArrayIndexOfSensitive(CODES_TFhirCausalityExpectation, FCausalityExpectation.value));
end;

Procedure TFhirAdverseReactionExposure.SetCausalityExpectationST(value : TFhirCausalityExpectation);
begin
  if ord(value) = 0 then
    CausalityExpectationObject := nil
  else
    CausalityExpectationObject := TFhirEnum.create(CODES_TFhirCausalityExpectation[value]);
end;

Procedure TFhirAdverseReactionExposure.SetSubstance(value : TFhirResourceReference{TFhirSubstance});
begin
  FSubstance.free;
  FSubstance := value;
end;


{ TFhirAdverseReactionExposureListEnumerator }

Constructor TFhirAdverseReactionExposureListEnumerator.Create(list : TFhirAdverseReactionExposureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirAdverseReactionExposureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseReactionExposureListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirAdverseReactionExposureListEnumerator.GetCurrent : TFhirAdverseReactionExposure;
begin
  Result := FList[FIndex];
end;


{ TFhirAdverseReactionExposureList }
procedure TFhirAdverseReactionExposureList.AddItem(value: TFhirAdverseReactionExposure);
begin
  assert(value.ClassName = 'TFhirAdverseReactionExposure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseReactionExposure');
  add(value);
end;


function TFhirAdverseReactionExposureList.Append: TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirAdverseReactionExposureList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseReactionExposureList.GetEnumerator : TFhirAdverseReactionExposureListEnumerator;
begin
  result := TFhirAdverseReactionExposureListEnumerator.Create(self.link);
end;

function TFhirAdverseReactionExposureList.Clone: TFhirAdverseReactionExposureList;
begin
  result := TFhirAdverseReactionExposureList(inherited Clone);
end;

function TFhirAdverseReactionExposureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseReactionExposureList.GetItemN(index: Integer): TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure(ObjectByIndex[index]);
end;

function TFhirAdverseReactionExposureList.IndexOf(value: TFhirAdverseReactionExposure): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirAdverseReactionExposureList.Insert(index: Integer): TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirAdverseReactionExposureList.InsertItem(index: Integer; value: TFhirAdverseReactionExposure);
begin
  assert(value is TFhirAdverseReactionExposure);
  Inherited Insert(index, value);
end;

function TFhirAdverseReactionExposureList.Item(index: Integer): TFhirAdverseReactionExposure;
begin
  result := TFhirAdverseReactionExposure(ObjectByIndex[index]);
end;

function TFhirAdverseReactionExposureList.Link: TFhirAdverseReactionExposureList;
begin
  result := TFhirAdverseReactionExposureList(inherited Link);
end;

procedure TFhirAdverseReactionExposureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseReactionExposureList.SetItemByIndex(index: Integer; value: TFhirAdverseReactionExposure);
begin
  assert(value is TFhirAdverseReactionExposure);
  FhirAdverseReactionExposures[index] := value;
end;

procedure TFhirAdverseReactionExposureList.SetItemN(index: Integer; value: TFhirAdverseReactionExposure);
begin
  assert(value is TFhirAdverseReactionExposure);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanParticipant }

constructor TFhirCarePlanParticipant.Create;
begin
  inherited;
end;

destructor TFhirCarePlanParticipant.Destroy;
begin
  FRole.free;
  FMember.free;
  inherited;
end;

procedure TFhirCarePlanParticipant.Assign(oSource : TAdvObject);
begin
  inherited;
  role := TFhirCarePlanParticipant(oSource).role.Clone;
  member := TFhirCarePlanParticipant(oSource).member.Clone;
end;

procedure TFhirCarePlanParticipant.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(FRole.Link);
  if (child_name = 'member') Then
     list.add(FMember.Link);
end;

procedure TFhirCarePlanParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'member', 'Resource(Practitioner|RelatedPerson|Patient|Organization)', FMember.Link));{2}
end;

procedure TFhirCarePlanParticipant.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'role') then Role := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'member') then Member := propValue as TFhirResourceReference{Resource}{4b}
  else inherited;
end;

function TFhirCarePlanParticipant.FhirType : string;
begin
  result := 'participant';
end;

function TFhirCarePlanParticipant.Link : TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(inherited Link);
end;

function TFhirCarePlanParticipant.Clone : TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(inherited Clone);
end;

{ TFhirCarePlanParticipant }

Procedure TFhirCarePlanParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirCarePlanParticipant.SetMember(value : TFhirResourceReference{Resource});
begin
  FMember.free;
  FMember := value;
end;


{ TFhirCarePlanParticipantListEnumerator }

Constructor TFhirCarePlanParticipantListEnumerator.Create(list : TFhirCarePlanParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirCarePlanParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanParticipantListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirCarePlanParticipantListEnumerator.GetCurrent : TFhirCarePlanParticipant;
begin
  Result := FList[FIndex];
end;


{ TFhirCarePlanParticipantList }
procedure TFhirCarePlanParticipantList.AddItem(value: TFhirCarePlanParticipant);
begin
  assert(value.ClassName = 'TFhirCarePlanParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanParticipant');
  add(value);
end;


function TFhirCarePlanParticipantList.Append: TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanParticipantList.GetEnumerator : TFhirCarePlanParticipantListEnumerator;
begin
  result := TFhirCarePlanParticipantListEnumerator.Create(self.link);
end;

function TFhirCarePlanParticipantList.Clone: TFhirCarePlanParticipantList;
begin
  result := TFhirCarePlanParticipantList(inherited Clone);
end;

function TFhirCarePlanParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanParticipantList.GetItemN(index: Integer): TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(ObjectByIndex[index]);
end;

function TFhirCarePlanParticipantList.IndexOf(value: TFhirCarePlanParticipant): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCarePlanParticipantList.Insert(index: Integer): TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanParticipantList.InsertItem(index: Integer; value: TFhirCarePlanParticipant);
begin
  assert(value is TFhirCarePlanParticipant);
  Inherited Insert(index, value);
end;

function TFhirCarePlanParticipantList.Item(index: Integer): TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(ObjectByIndex[index]);
end;

function TFhirCarePlanParticipantList.Link: TFhirCarePlanParticipantList;
begin
  result := TFhirCarePlanParticipantList(inherited Link);
end;

procedure TFhirCarePlanParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanParticipantList.SetItemByIndex(index: Integer; value: TFhirCarePlanParticipant);
begin
  assert(value is TFhirCarePlanParticipant);
  FhirCarePlanParticipants[index] := value;
end;

procedure TFhirCarePlanParticipantList.SetItemN(index: Integer; value: TFhirCarePlanParticipant);
begin
  assert(value is TFhirCarePlanParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanGoal }

constructor TFhirCarePlanGoal.Create;
begin
  inherited;
  FConcernList := TFhirResourceReferenceList{TFhirCondition}.Create;
end;

destructor TFhirCarePlanGoal.Destroy;
begin
  FDescription.free;
  FStatus.free;
  FNotes.free;
  FConcernList.Free;
  inherited;
end;

procedure TFhirCarePlanGoal.Assign(oSource : TAdvObject);
begin
  inherited;
  descriptionObject := TFhirCarePlanGoal(oSource).descriptionObject.Clone;
  FStatus := TFhirCarePlanGoal(oSource).FStatus.Link;
  notesObject := TFhirCarePlanGoal(oSource).notesObject.Clone;
  FConcernList.Assign(TFhirCarePlanGoal(oSource).FConcernList);
end;

procedure TFhirCarePlanGoal.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(FDescription.Link);
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'notes') Then
     list.add(FNotes.Link);
  if (child_name = 'concern') Then
     list.addAll(FConcernList);
end;

procedure TFhirCarePlanGoal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'notes', 'string', FNotes.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concern', 'Resource(Condition)', FConcernList.Link)){3};
end;

procedure TFhirCarePlanGoal.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'description') then DescriptionObject := propValue as TFhirString{5a}
  else if (propName = 'status') then StatusObject := propValue as TFHIREnum
  else if (propName = 'notes') then NotesObject := propValue as TFhirString{5a}
  else if (propName = 'concern') then ConcernList.add(propValue as TFhirResourceReference{TFhirCondition}){2}
  else inherited;
end;

function TFhirCarePlanGoal.FhirType : string;
begin
  result := 'goal';
end;

function TFhirCarePlanGoal.Link : TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal(inherited Link);
end;

function TFhirCarePlanGoal.Clone : TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal(inherited Clone);
end;

{ TFhirCarePlanGoal }

Procedure TFhirCarePlanGoal.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirCarePlanGoal.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirCarePlanGoal.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirCarePlanGoal.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCarePlanGoal.GetStatusST : TFhirCarePlanGoalStatus;
begin
  if FStatus = nil then
    result := TFhirCarePlanGoalStatus(0)
  else
    result := TFhirCarePlanGoalStatus(StringArrayIndexOfSensitive(CODES_TFhirCarePlanGoalStatus, FStatus.value));
end;

Procedure TFhirCarePlanGoal.SetStatusST(value : TFhirCarePlanGoalStatus);
begin
  if ord(value) = 0 then
    StatusObject := nil
  else
    StatusObject := TFhirEnum.create(CODES_TFhirCarePlanGoalStatus[value]);
end;

Procedure TFhirCarePlanGoal.SetNotes(value : TFhirString);
begin
  FNotes.free;
  FNotes := value;
end;

Function TFhirCarePlanGoal.GetNotesST : String;
begin
  if FNotes = nil then
    result := ''
  else
    result := FNotes.value;
end;

Procedure TFhirCarePlanGoal.SetNotesST(value : String);
begin
  if value <> '' then
  begin
    if FNotes = nil then
      FNotes := TFhirString.create;
    FNotes.value := value
  end
  else if FNotes <> nil then
    FNotes.value := '';
end;


{ TFhirCarePlanGoalListEnumerator }

Constructor TFhirCarePlanGoalListEnumerator.Create(list : TFhirCarePlanGoalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirCarePlanGoalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanGoalListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirCarePlanGoalListEnumerator.GetCurrent : TFhirCarePlanGoal;
begin
  Result := FList[FIndex];
end;


{ TFhirCarePlanGoalList }
procedure TFhirCarePlanGoalList.AddItem(value: TFhirCarePlanGoal);
begin
  assert(value.ClassName = 'TFhirCarePlanGoal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanGoal');
  add(value);
end;


function TFhirCarePlanGoalList.Append: TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanGoalList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanGoalList.GetEnumerator : TFhirCarePlanGoalListEnumerator;
begin
  result := TFhirCarePlanGoalListEnumerator.Create(self.link);
end;

function TFhirCarePlanGoalList.Clone: TFhirCarePlanGoalList;
begin
  result := TFhirCarePlanGoalList(inherited Clone);
end;

function TFhirCarePlanGoalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanGoalList.GetItemN(index: Integer): TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal(ObjectByIndex[index]);
end;

function TFhirCarePlanGoalList.IndexOf(value: TFhirCarePlanGoal): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCarePlanGoalList.Insert(index: Integer): TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanGoalList.InsertItem(index: Integer; value: TFhirCarePlanGoal);
begin
  assert(value is TFhirCarePlanGoal);
  Inherited Insert(index, value);
end;

function TFhirCarePlanGoalList.Item(index: Integer): TFhirCarePlanGoal;
begin
  result := TFhirCarePlanGoal(ObjectByIndex[index]);
end;

function TFhirCarePlanGoalList.Link: TFhirCarePlanGoalList;
begin
  result := TFhirCarePlanGoalList(inherited Link);
end;

procedure TFhirCarePlanGoalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanGoalList.SetItemByIndex(index: Integer; value: TFhirCarePlanGoal);
begin
  assert(value is TFhirCarePlanGoal);
  FhirCarePlanGoals[index] := value;
end;

procedure TFhirCarePlanGoalList.SetItemN(index: Integer; value: TFhirCarePlanGoal);
begin
  assert(value is TFhirCarePlanGoal);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanActivity }

constructor TFhirCarePlanActivity.Create;
begin
  inherited;
  FGoalList := TFhirStringList.Create;
  FActionResultingList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirCarePlanActivity.Destroy;
begin
  FGoalList.Free;
  FStatus.free;
  FProhibited.free;
  FActionResultingList.Free;
  FNotes.free;
  FDetail.free;
  FSimple.free;
  inherited;
end;

procedure TFhirCarePlanActivity.Assign(oSource : TAdvObject);
begin
  inherited;
  FGoalList.Assign(TFhirCarePlanActivity(oSource).FGoalList);
  FStatus := TFhirCarePlanActivity(oSource).FStatus.Link;
  prohibitedObject := TFhirCarePlanActivity(oSource).prohibitedObject.Clone;
  FActionResultingList.Assign(TFhirCarePlanActivity(oSource).FActionResultingList);
  notesObject := TFhirCarePlanActivity(oSource).notesObject.Clone;
  detail := TFhirCarePlanActivity(oSource).detail.Clone;
  simple := TFhirCarePlanActivity(oSource).simple.Clone;
end;

procedure TFhirCarePlanActivity.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'goal') Then
     list.addAll(FGoalList);
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'prohibited') Then
     list.add(FProhibited.Link);
  if (child_name = 'actionResulting') Then
     list.addAll(FActionResultingList);
  if (child_name = 'notes') Then
     list.add(FNotes.Link);
  if (child_name = 'detail') Then
     list.add(FDetail.Link);
  if (child_name = 'simple') Then
     list.add(FSimple.Link);
end;

procedure TFhirCarePlanActivity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'goal', 'idref', FGoalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'prohibited', 'boolean', FProhibited.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actionResulting', 'Resource(Any)', FActionResultingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'notes', 'string', FNotes.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Resource(Procedure|MedicationPrescription|DiagnosticOrder|Encounter)', FDetail.Link));{2}
  oList.add(TFHIRProperty.create(self, 'simple', '', FSimple.Link));{2}
end;

procedure TFhirCarePlanActivity.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'goal') then GoalList.add(propValue as TFhirString){2}
  else if (propName = 'status') then StatusObject := propValue as TFHIREnum
  else if (propName = 'prohibited') then ProhibitedObject := propValue as TFhirBoolean{5a}
  else if (propName = 'actionResulting') then ActionResultingList.add(propValue as TFhirResourceReference{Resource}){2}
  else if (propName = 'notes') then NotesObject := propValue as TFhirString{5a}
  else if (propName = 'detail') then Detail := propValue as TFhirResourceReference{Resource}{4b}
  else if (propName = 'simple') then Simple := propValue as TFhirCarePlanActivitySimple{4b}
  else inherited;
end;

function TFhirCarePlanActivity.FhirType : string;
begin
  result := 'activity';
end;

function TFhirCarePlanActivity.Link : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(inherited Link);
end;

function TFhirCarePlanActivity.Clone : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(inherited Clone);
end;

{ TFhirCarePlanActivity }

Procedure TFhirCarePlanActivity.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCarePlanActivity.GetStatusST : TFhirCarePlanActivityStatus;
begin
  if FStatus = nil then
    result := TFhirCarePlanActivityStatus(0)
  else
    result := TFhirCarePlanActivityStatus(StringArrayIndexOfSensitive(CODES_TFhirCarePlanActivityStatus, FStatus.value));
end;

Procedure TFhirCarePlanActivity.SetStatusST(value : TFhirCarePlanActivityStatus);
begin
  if ord(value) = 0 then
    StatusObject := nil
  else
    StatusObject := TFhirEnum.create(CODES_TFhirCarePlanActivityStatus[value]);
end;

Procedure TFhirCarePlanActivity.SetProhibited(value : TFhirBoolean);
begin
  FProhibited.free;
  FProhibited := value;
end;

Function TFhirCarePlanActivity.GetProhibitedST : Boolean;
begin
  if FProhibited = nil then
    result := false
  else
    result := FProhibited.value;
end;

Procedure TFhirCarePlanActivity.SetProhibitedST(value : Boolean);
begin
  if FProhibited = nil then
    FProhibited := TFhirBoolean.create;
  FProhibited.value := value
end;

Procedure TFhirCarePlanActivity.SetNotes(value : TFhirString);
begin
  FNotes.free;
  FNotes := value;
end;

Function TFhirCarePlanActivity.GetNotesST : String;
begin
  if FNotes = nil then
    result := ''
  else
    result := FNotes.value;
end;

Procedure TFhirCarePlanActivity.SetNotesST(value : String);
begin
  if value <> '' then
  begin
    if FNotes = nil then
      FNotes := TFhirString.create;
    FNotes.value := value
  end
  else if FNotes <> nil then
    FNotes.value := '';
end;

Procedure TFhirCarePlanActivity.SetDetail(value : TFhirResourceReference{Resource});
begin
  FDetail.free;
  FDetail := value;
end;

Procedure TFhirCarePlanActivity.SetSimple(value : TFhirCarePlanActivitySimple);
begin
  FSimple.free;
  FSimple := value;
end;


{ TFhirCarePlanActivityListEnumerator }

Constructor TFhirCarePlanActivityListEnumerator.Create(list : TFhirCarePlanActivityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirCarePlanActivityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanActivityListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirCarePlanActivityListEnumerator.GetCurrent : TFhirCarePlanActivity;
begin
  Result := FList[FIndex];
end;


{ TFhirCarePlanActivityList }
procedure TFhirCarePlanActivityList.AddItem(value: TFhirCarePlanActivity);
begin
  assert(value.ClassName = 'TFhirCarePlanActivity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanActivity');
  add(value);
end;


function TFhirCarePlanActivityList.Append: TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanActivityList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanActivityList.GetEnumerator : TFhirCarePlanActivityListEnumerator;
begin
  result := TFhirCarePlanActivityListEnumerator.Create(self.link);
end;

function TFhirCarePlanActivityList.Clone: TFhirCarePlanActivityList;
begin
  result := TFhirCarePlanActivityList(inherited Clone);
end;

function TFhirCarePlanActivityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanActivityList.GetItemN(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityList.IndexOf(value: TFhirCarePlanActivity): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCarePlanActivityList.Insert(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanActivityList.InsertItem(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  Inherited Insert(index, value);
end;

function TFhirCarePlanActivityList.Item(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityList.Link: TFhirCarePlanActivityList;
begin
  result := TFhirCarePlanActivityList(inherited Link);
end;

procedure TFhirCarePlanActivityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanActivityList.SetItemByIndex(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  FhirCarePlanActivities[index] := value;
end;

procedure TFhirCarePlanActivityList.SetItemN(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanActivitySimple }

constructor TFhirCarePlanActivitySimple.Create;
begin
  inherited;
  FPerformerList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirCarePlanActivitySimple.Destroy;
begin
  FCategory.free;
  FCode.free;
  FTiming.free;
  FLocation.free;
  FPerformerList.Free;
  FProduct.free;
  FDailyAmount.free;
  FQuantity.free;
  FDetails.free;
  inherited;
end;

procedure TFhirCarePlanActivitySimple.Assign(oSource : TAdvObject);
begin
  inherited;
  FCategory := TFhirCarePlanActivitySimple(oSource).FCategory.Link;
  code := TFhirCarePlanActivitySimple(oSource).code.Clone;
  timing := TFhirCarePlanActivitySimple(oSource).timing.Clone;
  location := TFhirCarePlanActivitySimple(oSource).location.Clone;
  FPerformerList.Assign(TFhirCarePlanActivitySimple(oSource).FPerformerList);
  product := TFhirCarePlanActivitySimple(oSource).product.Clone;
  dailyAmount := TFhirCarePlanActivitySimple(oSource).dailyAmount.Clone;
  quantity := TFhirCarePlanActivitySimple(oSource).quantity.Clone;
  detailsObject := TFhirCarePlanActivitySimple(oSource).detailsObject.Clone;
end;

procedure TFhirCarePlanActivitySimple.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(FCategory.Link);
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'timing[x]') Then
     list.add(FTiming.Link);
  if (child_name = 'location') Then
     list.add(FLocation.Link);
  if (child_name = 'performer') Then
     list.addAll(FPerformerList);
  if (child_name = 'product') Then
     list.add(FProduct.Link);
  if (child_name = 'dailyAmount') Then
     list.add(FDailyAmount.Link);
  if (child_name = 'quantity') Then
     list.add(FQuantity.Link);
  if (child_name = 'details') Then
     list.add(FDetails.Link);
end;

procedure TFhirCarePlanActivitySimple.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'code', FCategory.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'Schedule|Period|string', FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'Resource(Location)', FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Resource(Practitioner|Organization|RelatedPerson|Patient)', FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'product', 'Resource(Medication|Substance)', FProduct.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dailyAmount', 'Quantity', FDailyAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'details', 'string', FDetails.Link));{2}
end;

procedure TFhirCarePlanActivitySimple.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'category') then CategoryObject := propValue as TFHIREnum
  else if (propName = 'code') then Code := propValue as TFhirCodeableConcept{4b}
  else if (propName.startsWith('timing')) then Timing := propValue as TFhirType{4}
  else if (propName = 'location') then Location := propValue as TFhirResourceReference{TFhirLocation}{4b}
  else if (propName = 'performer') then PerformerList.add(propValue as TFhirResourceReference{Resource}){2}
  else if (propName = 'product') then Product := propValue as TFhirResourceReference{Resource}{4b}
  else if (propName = 'dailyAmount') then DailyAmount := propValue as TFhirQuantity{4b}
  else if (propName = 'quantity') then Quantity := propValue as TFhirQuantity{4b}
  else if (propName = 'details') then DetailsObject := propValue as TFhirString{5a}
  else inherited;
end;

function TFhirCarePlanActivitySimple.FhirType : string;
begin
  result := 'simple';
end;

function TFhirCarePlanActivitySimple.Link : TFhirCarePlanActivitySimple;
begin
  result := TFhirCarePlanActivitySimple(inherited Link);
end;

function TFhirCarePlanActivitySimple.Clone : TFhirCarePlanActivitySimple;
begin
  result := TFhirCarePlanActivitySimple(inherited Clone);
end;

{ TFhirCarePlanActivitySimple }

Procedure TFhirCarePlanActivitySimple.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

Function TFhirCarePlanActivitySimple.GetCategoryST : TFhirCarePlanActivityCategory;
begin
  if FCategory = nil then
    result := TFhirCarePlanActivityCategory(0)
  else
    result := TFhirCarePlanActivityCategory(StringArrayIndexOfSensitive(CODES_TFhirCarePlanActivityCategory, FCategory.value));
end;

Procedure TFhirCarePlanActivitySimple.SetCategoryST(value : TFhirCarePlanActivityCategory);
begin
  if ord(value) = 0 then
    CategoryObject := nil
  else
    CategoryObject := TFhirEnum.create(CODES_TFhirCarePlanActivityCategory[value]);
end;

Procedure TFhirCarePlanActivitySimple.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirCarePlanActivitySimple.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirCarePlanActivitySimple.SetLocation(value : TFhirResourceReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirCarePlanActivitySimple.SetProduct(value : TFhirResourceReference{Resource});
begin
  FProduct.free;
  FProduct := value;
end;

Procedure TFhirCarePlanActivitySimple.SetDailyAmount(value : TFhirQuantity);
begin
  FDailyAmount.free;
  FDailyAmount := value;
end;

Procedure TFhirCarePlanActivitySimple.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirCarePlanActivitySimple.SetDetails(value : TFhirString);
begin
  FDetails.free;
  FDetails := value;
end;

Function TFhirCarePlanActivitySimple.GetDetailsST : String;
begin
  if FDetails = nil then
    result := ''
  else
    result := FDetails.value;
end;

Procedure TFhirCarePlanActivitySimple.SetDetailsST(value : String);
begin
  if value <> '' then
  begin
    if FDetails = nil then
      FDetails := TFhirString.create;
    FDetails.value := value
  end
  else if FDetails <> nil then
    FDetails.value := '';
end;


{ TFhirCarePlanActivitySimpleListEnumerator }

Constructor TFhirCarePlanActivitySimpleListEnumerator.Create(list : TFhirCarePlanActivitySimpleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirCarePlanActivitySimpleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanActivitySimpleListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirCarePlanActivitySimpleListEnumerator.GetCurrent : TFhirCarePlanActivitySimple;
begin
  Result := FList[FIndex];
end;


{ TFhirCarePlanActivitySimpleList }
procedure TFhirCarePlanActivitySimpleList.AddItem(value: TFhirCarePlanActivitySimple);
begin
  assert(value.ClassName = 'TFhirCarePlanActivitySimple', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanActivitySimple');
  add(value);
end;


function TFhirCarePlanActivitySimpleList.Append: TFhirCarePlanActivitySimple;
begin
  result := TFhirCarePlanActivitySimple.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanActivitySimpleList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanActivitySimpleList.GetEnumerator : TFhirCarePlanActivitySimpleListEnumerator;
begin
  result := TFhirCarePlanActivitySimpleListEnumerator.Create(self.link);
end;

function TFhirCarePlanActivitySimpleList.Clone: TFhirCarePlanActivitySimpleList;
begin
  result := TFhirCarePlanActivitySimpleList(inherited Clone);
end;

function TFhirCarePlanActivitySimpleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanActivitySimpleList.GetItemN(index: Integer): TFhirCarePlanActivitySimple;
begin
  result := TFhirCarePlanActivitySimple(ObjectByIndex[index]);
end;

function TFhirCarePlanActivitySimpleList.IndexOf(value: TFhirCarePlanActivitySimple): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCarePlanActivitySimpleList.Insert(index: Integer): TFhirCarePlanActivitySimple;
begin
  result := TFhirCarePlanActivitySimple.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCarePlanActivitySimpleList.InsertItem(index: Integer; value: TFhirCarePlanActivitySimple);
begin
  assert(value is TFhirCarePlanActivitySimple);
  Inherited Insert(index, value);
end;

function TFhirCarePlanActivitySimpleList.Item(index: Integer): TFhirCarePlanActivitySimple;
begin
  result := TFhirCarePlanActivitySimple(ObjectByIndex[index]);
end;

function TFhirCarePlanActivitySimpleList.Link: TFhirCarePlanActivitySimpleList;
begin
  result := TFhirCarePlanActivitySimpleList(inherited Link);
end;

procedure TFhirCarePlanActivitySimpleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanActivitySimpleList.SetItemByIndex(index: Integer; value: TFhirCarePlanActivitySimple);
begin
  assert(value is TFhirCarePlanActivitySimple);
  FhirCarePlanActivitySimples[index] := value;
end;

procedure TFhirCarePlanActivitySimpleList.SetItemN(index: Integer; value: TFhirCarePlanActivitySimple);
begin
  assert(value is TFhirCarePlanActivitySimple);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionAttester }

constructor TFhirCompositionAttester.Create;
begin
  inherited;
  FMode := TFHIREnumList.Create;
end;

destructor TFhirCompositionAttester.Destroy;
begin
  FMode.Free;
  FTime.free;
  FParty.free;
  inherited;
end;

procedure TFhirCompositionAttester.Assign(oSource : TAdvObject);
begin
  inherited;
  FMode.Assign(TFhirCompositionAttester(oSource).FMode);
  timeObject := TFhirCompositionAttester(oSource).timeObject.Clone;
  party := TFhirCompositionAttester(oSource).party.Clone;
end;

procedure TFhirCompositionAttester.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.addAll(FMode);
  if (child_name = 'time') Then
     list.add(FTime.Link);
  if (child_name = 'party') Then
     list.add(FParty.Link);
end;

procedure TFhirCompositionAttester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', FMode.Link)){3};
  oList.add(TFHIRProperty.create(self, 'time', 'dateTime', FTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'party', 'Resource(Patient|Practitioner|Organization)', FParty.Link));{2}
end;

procedure TFhirCompositionAttester.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'mode') then FMode.add(propValue as TFHIREnum) {1}
  else if (propName = 'time') then TimeObject := propValue as TFhirDateTime{5a}
  else if (propName = 'party') then Party := propValue as TFhirResourceReference{Resource}{4b}
  else inherited;
end;

function TFhirCompositionAttester.FhirType : string;
begin
  result := 'attester';
end;

function TFhirCompositionAttester.Link : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(inherited Link);
end;

function TFhirCompositionAttester.Clone : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(inherited Clone);
end;

{ TFhirCompositionAttester }

Function TFhirCompositionAttester.GetModeST : TFhirCompositionAttestationModeList;
  var i : integer;
begin
  result := [];
  for i := 0 to Fmode.count - 1 do
    result := result + [TFhirCompositionAttestationMode(StringArrayIndexOfSensitive(CODES_TFhirCompositionAttestationMode, Fmode[i].value))];
end;

Procedure TFhirCompositionAttester.SetModeST(value : TFhirCompositionAttestationModeList);
var a : TFhirCompositionAttestationMode;
begin
  Fmode.clear;
  for a := low(TFhirCompositionAttestationMode) to high(TFhirCompositionAttestationMode) do
    if a in value then
      Fmode.add(TFhirEnum.create(CODES_TFhirCompositionAttestationMode[a]));
end;

Procedure TFhirCompositionAttester.SetTime(value : TFhirDateTime);
begin
  FTime.free;
  FTime := value;
end;

Function TFhirCompositionAttester.GetTimeST : TDateTimeEx;
begin
  if FTime = nil then
    result := nil
  else
    result := FTime.value;
end;

Procedure TFhirCompositionAttester.SetTimeST(value : TDateTimeEx);
begin
  if value <> nil then
  begin
    if FTime = nil then
      FTime := TFhirDateTime.create;
    FTime.value := value
  end
  else if FTime <> nil then
    FTime.value := nil;
end;

Procedure TFhirCompositionAttester.SetParty(value : TFhirResourceReference{Resource});
begin
  FParty.free;
  FParty := value;
end;


{ TFhirCompositionAttesterListEnumerator }

Constructor TFhirCompositionAttesterListEnumerator.Create(list : TFhirCompositionAttesterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirCompositionAttesterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionAttesterListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirCompositionAttesterListEnumerator.GetCurrent : TFhirCompositionAttester;
begin
  Result := FList[FIndex];
end;


{ TFhirCompositionAttesterList }
procedure TFhirCompositionAttesterList.AddItem(value: TFhirCompositionAttester);
begin
  assert(value.ClassName = 'TFhirCompositionAttester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionAttester');
  add(value);
end;


function TFhirCompositionAttesterList.Append: TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCompositionAttesterList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionAttesterList.GetEnumerator : TFhirCompositionAttesterListEnumerator;
begin
  result := TFhirCompositionAttesterListEnumerator.Create(self.link);
end;

function TFhirCompositionAttesterList.Clone: TFhirCompositionAttesterList;
begin
  result := TFhirCompositionAttesterList(inherited Clone);
end;

function TFhirCompositionAttesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionAttesterList.GetItemN(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(ObjectByIndex[index]);
end;

function TFhirCompositionAttesterList.IndexOf(value: TFhirCompositionAttester): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCompositionAttesterList.Insert(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCompositionAttesterList.InsertItem(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  Inherited Insert(index, value);
end;

function TFhirCompositionAttesterList.Item(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(ObjectByIndex[index]);
end;

function TFhirCompositionAttesterList.Link: TFhirCompositionAttesterList;
begin
  result := TFhirCompositionAttesterList(inherited Link);
end;

procedure TFhirCompositionAttesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionAttesterList.SetItemByIndex(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  FhirCompositionAttesters[index] := value;
end;

procedure TFhirCompositionAttesterList.SetItemN(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionEvent }

constructor TFhirCompositionEvent.Create;
begin
  inherited;
  FCodeList := TFhirCodeableConceptList.Create;
  FDetailList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirCompositionEvent.Destroy;
begin
  FCodeList.Free;
  FPeriod.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirCompositionEvent.Assign(oSource : TAdvObject);
begin
  inherited;
  FCodeList.Assign(TFhirCompositionEvent(oSource).FCodeList);
  period := TFhirCompositionEvent(oSource).period.Clone;
  FDetailList.Assign(TFhirCompositionEvent(oSource).FDetailList);
end;

procedure TFhirCompositionEvent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.addAll(FCodeList);
  if (child_name = 'period') Then
     list.add(FPeriod.Link);
  if (child_name = 'detail') Then
     list.addAll(FDetailList);
end;

procedure TFhirCompositionEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Resource(Any)', FDetailList.Link)){3};
end;

procedure TFhirCompositionEvent.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then CodeList.add(propValue as TFhirCodeableConcept){2}
  else if (propName = 'period') then Period := propValue as TFhirPeriod{4b}
  else if (propName = 'detail') then DetailList.add(propValue as TFhirResourceReference{Resource}){2}
  else inherited;
end;

function TFhirCompositionEvent.FhirType : string;
begin
  result := 'event';
end;

function TFhirCompositionEvent.Link : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(inherited Link);
end;

function TFhirCompositionEvent.Clone : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(inherited Clone);
end;

{ TFhirCompositionEvent }

Procedure TFhirCompositionEvent.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;


{ TFhirCompositionEventListEnumerator }

Constructor TFhirCompositionEventListEnumerator.Create(list : TFhirCompositionEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirCompositionEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionEventListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirCompositionEventListEnumerator.GetCurrent : TFhirCompositionEvent;
begin
  Result := FList[FIndex];
end;


{ TFhirCompositionEventList }
procedure TFhirCompositionEventList.AddItem(value: TFhirCompositionEvent);
begin
  assert(value.ClassName = 'TFhirCompositionEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionEvent');
  add(value);
end;


function TFhirCompositionEventList.Append: TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCompositionEventList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionEventList.GetEnumerator : TFhirCompositionEventListEnumerator;
begin
  result := TFhirCompositionEventListEnumerator.Create(self.link);
end;

function TFhirCompositionEventList.Clone: TFhirCompositionEventList;
begin
  result := TFhirCompositionEventList(inherited Clone);
end;

function TFhirCompositionEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionEventList.GetItemN(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(ObjectByIndex[index]);
end;

function TFhirCompositionEventList.IndexOf(value: TFhirCompositionEvent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCompositionEventList.Insert(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCompositionEventList.InsertItem(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  Inherited Insert(index, value);
end;

function TFhirCompositionEventList.Item(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(ObjectByIndex[index]);
end;

function TFhirCompositionEventList.Link: TFhirCompositionEventList;
begin
  result := TFhirCompositionEventList(inherited Link);
end;

procedure TFhirCompositionEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionEventList.SetItemByIndex(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  FhirCompositionEvents[index] := value;
end;

procedure TFhirCompositionEventList.SetItemN(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionSection }

constructor TFhirCompositionSection.Create;
begin
  inherited;
  FSectionList := TFhirCompositionSectionList.Create;
end;

destructor TFhirCompositionSection.Destroy;
begin
  FTitle.free;
  FCode.free;
  FSubject.free;
  FContent.free;
  FSectionList.Free;
  inherited;
end;

procedure TFhirCompositionSection.Assign(oSource : TAdvObject);
begin
  inherited;
  titleObject := TFhirCompositionSection(oSource).titleObject.Clone;
  code := TFhirCompositionSection(oSource).code.Clone;
  subject := TFhirCompositionSection(oSource).subject.Clone;
  content := TFhirCompositionSection(oSource).content.Clone;
  FSectionList.Assign(TFhirCompositionSection(oSource).FSectionList);
end;

procedure TFhirCompositionSection.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(FTitle.Link);
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'subject') Then
     list.add(FSubject.Link);
  if (child_name = 'content') Then
     list.add(FContent.Link);
  if (child_name = 'section') Then
     list.addAll(FSectionList);
end;

procedure TFhirCompositionSection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Resource(Patient|Group|Device)', FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', 'Resource(Any)', FContent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'section', '@Composition.section', FSectionList.Link)){3};
end;

procedure TFhirCompositionSection.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'title') then TitleObject := propValue as TFhirString{5a}
  else if (propName = 'code') then Code := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'subject') then Subject := propValue as TFhirResourceReference{Resource}{4b}
  else if (propName = 'content') then Content := propValue as TFhirResourceReference{Resource}{4b}
  else if (propName = 'section') then SectionList.add(propValue as TFhirCompositionSection){2}
  else inherited;
end;

function TFhirCompositionSection.FhirType : string;
begin
  result := 'section';
end;

function TFhirCompositionSection.Link : TFhirCompositionSection;
begin
  result := TFhirCompositionSection(inherited Link);
end;

function TFhirCompositionSection.Clone : TFhirCompositionSection;
begin
  result := TFhirCompositionSection(inherited Clone);
end;

{ TFhirCompositionSection }

Procedure TFhirCompositionSection.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirCompositionSection.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirCompositionSection.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirCompositionSection.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirCompositionSection.SetSubject(value : TFhirResourceReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirCompositionSection.SetContent(value : TFhirResourceReference{Resource});
begin
  FContent.free;
  FContent := value;
end;


{ TFhirCompositionSectionListEnumerator }

Constructor TFhirCompositionSectionListEnumerator.Create(list : TFhirCompositionSectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirCompositionSectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionSectionListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirCompositionSectionListEnumerator.GetCurrent : TFhirCompositionSection;
begin
  Result := FList[FIndex];
end;


{ TFhirCompositionSectionList }
procedure TFhirCompositionSectionList.AddItem(value: TFhirCompositionSection);
begin
  assert(value.ClassName = 'TFhirCompositionSection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionSection');
  add(value);
end;


function TFhirCompositionSectionList.Append: TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirCompositionSectionList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionSectionList.GetEnumerator : TFhirCompositionSectionListEnumerator;
begin
  result := TFhirCompositionSectionListEnumerator.Create(self.link);
end;

function TFhirCompositionSectionList.Clone: TFhirCompositionSectionList;
begin
  result := TFhirCompositionSectionList(inherited Clone);
end;

function TFhirCompositionSectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionSectionList.GetItemN(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection(ObjectByIndex[index]);
end;

function TFhirCompositionSectionList.IndexOf(value: TFhirCompositionSection): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirCompositionSectionList.Insert(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirCompositionSectionList.InsertItem(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  Inherited Insert(index, value);
end;

function TFhirCompositionSectionList.Item(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection(ObjectByIndex[index]);
end;

function TFhirCompositionSectionList.Link: TFhirCompositionSectionList;
begin
  result := TFhirCompositionSectionList(inherited Link);
end;

procedure TFhirCompositionSectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionSectionList.SetItemByIndex(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  FhirCompositionSections[index] := value;
end;

procedure TFhirCompositionSectionList.SetItemN(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapConcept }

constructor TFhirConceptMapConcept.Create;
begin
  inherited;
  FDependsOnList := TFhirConceptMapConceptDependsOnList.Create;
  FMapList := TFhirConceptMapConceptMapList.Create;
end;

destructor TFhirConceptMapConcept.Destroy;
begin
  FSystem.free;
  FCode.free;
  FDependsOnList.Free;
  FMapList.Free;
  inherited;
end;

procedure TFhirConceptMapConcept.Assign(oSource : TAdvObject);
begin
  inherited;
  systemObject := TFhirConceptMapConcept(oSource).systemObject.Clone;
  codeObject := TFhirConceptMapConcept(oSource).codeObject.Clone;
  FDependsOnList.Assign(TFhirConceptMapConcept(oSource).FDependsOnList);
  FMapList.Assign(TFhirConceptMapConcept(oSource).FMapList);
end;

procedure TFhirConceptMapConcept.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(FSystem.Link);
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'dependsOn') Then
     list.addAll(FDependsOnList);
  if (child_name = 'map') Then
     list.addAll(FMapList);
end;

procedure TFhirConceptMapConcept.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dependsOn', '', FDependsOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'map', '', FMapList.Link)){3};
end;

procedure TFhirConceptMapConcept.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'system') then SystemObject := propValue as TFhirUri{5a}
  else if (propName = 'code') then
    if propValue is TFHIRCode then
      CodeObject := propValue as TFhirCode{5}
    else if propValue is TFHIREnum then
      CodeObject := TFHIRCode.create(TFHIREnum(propValue).value)
    else
      raise Exception.Create('Type mismatch: cannot convert from "'+propValue.className+'" to "TFHIRCode"'){5a}
  else if (propName = 'dependsOn') then DependsOnList.add(propValue as TFhirConceptMapConceptDependsOn){2}
  else if (propName = 'map') then MapList.add(propValue as TFhirConceptMapConceptMap){2}
  else inherited;
end;

function TFhirConceptMapConcept.FhirType : string;
begin
  result := 'concept';
end;

function TFhirConceptMapConcept.Link : TFhirConceptMapConcept;
begin
  result := TFhirConceptMapConcept(inherited Link);
end;

function TFhirConceptMapConcept.Clone : TFhirConceptMapConcept;
begin
  result := TFhirConceptMapConcept(inherited Clone);
end;

{ TFhirConceptMapConcept }

Procedure TFhirConceptMapConcept.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirConceptMapConcept.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirConceptMapConcept.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirConceptMapConcept.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConceptMapConcept.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirConceptMapConcept.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;


{ TFhirConceptMapConceptListEnumerator }

Constructor TFhirConceptMapConceptListEnumerator.Create(list : TFhirConceptMapConceptList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConceptMapConceptListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapConceptListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConceptMapConceptListEnumerator.GetCurrent : TFhirConceptMapConcept;
begin
  Result := FList[FIndex];
end;


{ TFhirConceptMapConceptList }
procedure TFhirConceptMapConceptList.AddItem(value: TFhirConceptMapConcept);
begin
  assert(value.ClassName = 'TFhirConceptMapConcept', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapConcept');
  add(value);
end;


function TFhirConceptMapConceptList.Append: TFhirConceptMapConcept;
begin
  result := TFhirConceptMapConcept.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConceptMapConceptList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapConceptList.GetEnumerator : TFhirConceptMapConceptListEnumerator;
begin
  result := TFhirConceptMapConceptListEnumerator.Create(self.link);
end;

function TFhirConceptMapConceptList.Clone: TFhirConceptMapConceptList;
begin
  result := TFhirConceptMapConceptList(inherited Clone);
end;

function TFhirConceptMapConceptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapConceptList.GetItemN(index: Integer): TFhirConceptMapConcept;
begin
  result := TFhirConceptMapConcept(ObjectByIndex[index]);
end;

function TFhirConceptMapConceptList.IndexOf(value: TFhirConceptMapConcept): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConceptMapConceptList.Insert(index: Integer): TFhirConceptMapConcept;
begin
  result := TFhirConceptMapConcept.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConceptMapConceptList.InsertItem(index: Integer; value: TFhirConceptMapConcept);
begin
  assert(value is TFhirConceptMapConcept);
  Inherited Insert(index, value);
end;

function TFhirConceptMapConceptList.Item(index: Integer): TFhirConceptMapConcept;
begin
  result := TFhirConceptMapConcept(ObjectByIndex[index]);
end;

function TFhirConceptMapConceptList.Link: TFhirConceptMapConceptList;
begin
  result := TFhirConceptMapConceptList(inherited Link);
end;

procedure TFhirConceptMapConceptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapConceptList.SetItemByIndex(index: Integer; value: TFhirConceptMapConcept);
begin
  assert(value is TFhirConceptMapConcept);
  FhirConceptMapConcepts[index] := value;
end;

procedure TFhirConceptMapConceptList.SetItemN(index: Integer; value: TFhirConceptMapConcept);
begin
  assert(value is TFhirConceptMapConcept);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapConceptDependsOn }

constructor TFhirConceptMapConceptDependsOn.Create;
begin
  inherited;
end;

destructor TFhirConceptMapConceptDependsOn.Destroy;
begin
  FConcept.free;
  FSystem.free;
  FCode.free;
  inherited;
end;

procedure TFhirConceptMapConceptDependsOn.Assign(oSource : TAdvObject);
begin
  inherited;
  conceptObject := TFhirConceptMapConceptDependsOn(oSource).conceptObject.Clone;
  systemObject := TFhirConceptMapConceptDependsOn(oSource).systemObject.Clone;
  codeObject := TFhirConceptMapConceptDependsOn(oSource).codeObject.Clone;
end;

procedure TFhirConceptMapConceptDependsOn.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'concept') Then
     list.add(FConcept.Link);
  if (child_name = 'system') Then
     list.add(FSystem.Link);
  if (child_name = 'code') Then
     list.add(FCode.Link);
end;

procedure TFhirConceptMapConceptDependsOn.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'concept', 'uri', FConcept.Link));{2}
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{2}
end;

procedure TFhirConceptMapConceptDependsOn.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'concept') then ConceptObject := propValue as TFhirUri{5a}
  else if (propName = 'system') then SystemObject := propValue as TFhirUri{5a}
  else if (propName = 'code') then
    if propValue is TFHIRCode then
      CodeObject := propValue as TFhirCode{5}
    else if propValue is TFHIREnum then
      CodeObject := TFHIRCode.create(TFHIREnum(propValue).value)
    else
      raise Exception.Create('Type mismatch: cannot convert from "'+propValue.className+'" to "TFHIRCode"'){5a}
  else inherited;
end;

function TFhirConceptMapConceptDependsOn.FhirType : string;
begin
  result := 'dependsOn';
end;

function TFhirConceptMapConceptDependsOn.Link : TFhirConceptMapConceptDependsOn;
begin
  result := TFhirConceptMapConceptDependsOn(inherited Link);
end;

function TFhirConceptMapConceptDependsOn.Clone : TFhirConceptMapConceptDependsOn;
begin
  result := TFhirConceptMapConceptDependsOn(inherited Clone);
end;

{ TFhirConceptMapConceptDependsOn }

Procedure TFhirConceptMapConceptDependsOn.SetConcept(value : TFhirUri);
begin
  FConcept.free;
  FConcept := value;
end;

Function TFhirConceptMapConceptDependsOn.GetConceptST : String;
begin
  if FConcept = nil then
    result := ''
  else
    result := FConcept.value;
end;

Procedure TFhirConceptMapConceptDependsOn.SetConceptST(value : String);
begin
  if value <> '' then
  begin
    if FConcept = nil then
      FConcept := TFhirUri.create;
    FConcept.value := value
  end
  else if FConcept <> nil then
    FConcept.value := '';
end;

Procedure TFhirConceptMapConceptDependsOn.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirConceptMapConceptDependsOn.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirConceptMapConceptDependsOn.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirConceptMapConceptDependsOn.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConceptMapConceptDependsOn.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirConceptMapConceptDependsOn.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;


{ TFhirConceptMapConceptDependsOnListEnumerator }

Constructor TFhirConceptMapConceptDependsOnListEnumerator.Create(list : TFhirConceptMapConceptDependsOnList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConceptMapConceptDependsOnListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapConceptDependsOnListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConceptMapConceptDependsOnListEnumerator.GetCurrent : TFhirConceptMapConceptDependsOn;
begin
  Result := FList[FIndex];
end;


{ TFhirConceptMapConceptDependsOnList }
procedure TFhirConceptMapConceptDependsOnList.AddItem(value: TFhirConceptMapConceptDependsOn);
begin
  assert(value.ClassName = 'TFhirConceptMapConceptDependsOn', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapConceptDependsOn');
  add(value);
end;


function TFhirConceptMapConceptDependsOnList.Append: TFhirConceptMapConceptDependsOn;
begin
  result := TFhirConceptMapConceptDependsOn.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConceptMapConceptDependsOnList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapConceptDependsOnList.GetEnumerator : TFhirConceptMapConceptDependsOnListEnumerator;
begin
  result := TFhirConceptMapConceptDependsOnListEnumerator.Create(self.link);
end;

function TFhirConceptMapConceptDependsOnList.Clone: TFhirConceptMapConceptDependsOnList;
begin
  result := TFhirConceptMapConceptDependsOnList(inherited Clone);
end;

function TFhirConceptMapConceptDependsOnList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapConceptDependsOnList.GetItemN(index: Integer): TFhirConceptMapConceptDependsOn;
begin
  result := TFhirConceptMapConceptDependsOn(ObjectByIndex[index]);
end;

function TFhirConceptMapConceptDependsOnList.IndexOf(value: TFhirConceptMapConceptDependsOn): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConceptMapConceptDependsOnList.Insert(index: Integer): TFhirConceptMapConceptDependsOn;
begin
  result := TFhirConceptMapConceptDependsOn.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConceptMapConceptDependsOnList.InsertItem(index: Integer; value: TFhirConceptMapConceptDependsOn);
begin
  assert(value is TFhirConceptMapConceptDependsOn);
  Inherited Insert(index, value);
end;

function TFhirConceptMapConceptDependsOnList.Item(index: Integer): TFhirConceptMapConceptDependsOn;
begin
  result := TFhirConceptMapConceptDependsOn(ObjectByIndex[index]);
end;

function TFhirConceptMapConceptDependsOnList.Link: TFhirConceptMapConceptDependsOnList;
begin
  result := TFhirConceptMapConceptDependsOnList(inherited Link);
end;

procedure TFhirConceptMapConceptDependsOnList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapConceptDependsOnList.SetItemByIndex(index: Integer; value: TFhirConceptMapConceptDependsOn);
begin
  assert(value is TFhirConceptMapConceptDependsOn);
  FhirConceptMapConceptDependsOns[index] := value;
end;

procedure TFhirConceptMapConceptDependsOnList.SetItemN(index: Integer; value: TFhirConceptMapConceptDependsOn);
begin
  assert(value is TFhirConceptMapConceptDependsOn);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapConceptMap }

constructor TFhirConceptMapConceptMap.Create;
begin
  inherited;
  FProductList := TFhirConceptMapConceptDependsOnList.Create;
end;

destructor TFhirConceptMapConceptMap.Destroy;
begin
  FSystem.free;
  FCode.free;
  FEquivalence.free;
  FComments.free;
  FProductList.Free;
  inherited;
end;

procedure TFhirConceptMapConceptMap.Assign(oSource : TAdvObject);
begin
  inherited;
  systemObject := TFhirConceptMapConceptMap(oSource).systemObject.Clone;
  codeObject := TFhirConceptMapConceptMap(oSource).codeObject.Clone;
  FEquivalence := TFhirConceptMapConceptMap(oSource).FEquivalence.Link;
  commentsObject := TFhirConceptMapConceptMap(oSource).commentsObject.Clone;
  FProductList.Assign(TFhirConceptMapConceptMap(oSource).FProductList);
end;

procedure TFhirConceptMapConceptMap.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(FSystem.Link);
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'equivalence') Then
     list.add(FEquivalence.Link);
  if (child_name = 'comments') Then
     list.add(FComments.Link);
  if (child_name = 'product') Then
     list.addAll(FProductList);
end;

procedure TFhirConceptMapConceptMap.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'equivalence', 'code', FEquivalence.Link));{1}
  oList.add(TFHIRProperty.create(self, 'comments', 'string', FComments.Link));{2}
  oList.add(TFHIRProperty.create(self, 'product', '@ConceptMap.concept.dependsOn', FProductList.Link)){3};
end;

procedure TFhirConceptMapConceptMap.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'system') then SystemObject := propValue as TFhirUri{5a}
  else if (propName = 'code') then
    if propValue is TFHIRCode then
      CodeObject := propValue as TFhirCode{5}
    else if propValue is TFHIREnum then
      CodeObject := TFHIRCode.create(TFHIREnum(propValue).value)
    else
      raise Exception.Create('Type mismatch: cannot convert from "'+propValue.className+'" to "TFHIRCode"'){5a}
  else if (propName = 'equivalence') then EquivalenceObject := propValue as TFHIREnum
  else if (propName = 'comments') then CommentsObject := propValue as TFhirString{5a}
  else if (propName = 'product') then ProductList.add(propValue as TFhirConceptMapConceptDependsOn){2}
  else inherited;
end;

function TFhirConceptMapConceptMap.FhirType : string;
begin
  result := 'map';
end;

function TFhirConceptMapConceptMap.Link : TFhirConceptMapConceptMap;
begin
  result := TFhirConceptMapConceptMap(inherited Link);
end;

function TFhirConceptMapConceptMap.Clone : TFhirConceptMapConceptMap;
begin
  result := TFhirConceptMapConceptMap(inherited Clone);
end;

{ TFhirConceptMapConceptMap }

Procedure TFhirConceptMapConceptMap.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirConceptMapConceptMap.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirConceptMapConceptMap.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirConceptMapConceptMap.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConceptMapConceptMap.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirConceptMapConceptMap.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirConceptMapConceptMap.SetEquivalence(value : TFhirEnum);
begin
  FEquivalence.free;
  FEquivalence := value;
end;

Function TFhirConceptMapConceptMap.GetEquivalenceST : TFhirConceptEquivalence;
begin
  if FEquivalence = nil then
    result := TFhirConceptEquivalence(0)
  else
    result := TFhirConceptEquivalence(StringArrayIndexOfSensitive(CODES_TFhirConceptEquivalence, FEquivalence.value));
end;

Procedure TFhirConceptMapConceptMap.SetEquivalenceST(value : TFhirConceptEquivalence);
begin
  if ord(value) = 0 then
    EquivalenceObject := nil
  else
    EquivalenceObject := TFhirEnum.create(CODES_TFhirConceptEquivalence[value]);
end;

Procedure TFhirConceptMapConceptMap.SetComments(value : TFhirString);
begin
  FComments.free;
  FComments := value;
end;

Function TFhirConceptMapConceptMap.GetCommentsST : String;
begin
  if FComments = nil then
    result := ''
  else
    result := FComments.value;
end;

Procedure TFhirConceptMapConceptMap.SetCommentsST(value : String);
begin
  if value <> '' then
  begin
    if FComments = nil then
      FComments := TFhirString.create;
    FComments.value := value
  end
  else if FComments <> nil then
    FComments.value := '';
end;


{ TFhirConceptMapConceptMapListEnumerator }

Constructor TFhirConceptMapConceptMapListEnumerator.Create(list : TFhirConceptMapConceptMapList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConceptMapConceptMapListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapConceptMapListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConceptMapConceptMapListEnumerator.GetCurrent : TFhirConceptMapConceptMap;
begin
  Result := FList[FIndex];
end;


{ TFhirConceptMapConceptMapList }
procedure TFhirConceptMapConceptMapList.AddItem(value: TFhirConceptMapConceptMap);
begin
  assert(value.ClassName = 'TFhirConceptMapConceptMap', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapConceptMap');
  add(value);
end;


function TFhirConceptMapConceptMapList.Append: TFhirConceptMapConceptMap;
begin
  result := TFhirConceptMapConceptMap.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConceptMapConceptMapList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapConceptMapList.GetEnumerator : TFhirConceptMapConceptMapListEnumerator;
begin
  result := TFhirConceptMapConceptMapListEnumerator.Create(self.link);
end;

function TFhirConceptMapConceptMapList.Clone: TFhirConceptMapConceptMapList;
begin
  result := TFhirConceptMapConceptMapList(inherited Clone);
end;

function TFhirConceptMapConceptMapList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapConceptMapList.GetItemN(index: Integer): TFhirConceptMapConceptMap;
begin
  result := TFhirConceptMapConceptMap(ObjectByIndex[index]);
end;

function TFhirConceptMapConceptMapList.IndexOf(value: TFhirConceptMapConceptMap): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConceptMapConceptMapList.Insert(index: Integer): TFhirConceptMapConceptMap;
begin
  result := TFhirConceptMapConceptMap.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConceptMapConceptMapList.InsertItem(index: Integer; value: TFhirConceptMapConceptMap);
begin
  assert(value is TFhirConceptMapConceptMap);
  Inherited Insert(index, value);
end;

function TFhirConceptMapConceptMapList.Item(index: Integer): TFhirConceptMapConceptMap;
begin
  result := TFhirConceptMapConceptMap(ObjectByIndex[index]);
end;

function TFhirConceptMapConceptMapList.Link: TFhirConceptMapConceptMapList;
begin
  result := TFhirConceptMapConceptMapList(inherited Link);
end;

procedure TFhirConceptMapConceptMapList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapConceptMapList.SetItemByIndex(index: Integer; value: TFhirConceptMapConceptMap);
begin
  assert(value is TFhirConceptMapConceptMap);
  FhirConceptMapConceptMaps[index] := value;
end;

procedure TFhirConceptMapConceptMapList.SetItemN(index: Integer; value: TFhirConceptMapConceptMap);
begin
  assert(value is TFhirConceptMapConceptMap);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionStage }

constructor TFhirConditionStage.Create;
begin
  inherited;
  FAssessmentList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirConditionStage.Destroy;
begin
  FSummary.free;
  FAssessmentList.Free;
  inherited;
end;

procedure TFhirConditionStage.Assign(oSource : TAdvObject);
begin
  inherited;
  summary := TFhirConditionStage(oSource).summary.Clone;
  FAssessmentList.Assign(TFhirConditionStage(oSource).FAssessmentList);
end;

procedure TFhirConditionStage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'summary') Then
     list.add(FSummary.Link);
  if (child_name = 'assessment') Then
     list.addAll(FAssessmentList);
end;

procedure TFhirConditionStage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'summary', 'CodeableConcept', FSummary.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assessment', 'Resource(Any)', FAssessmentList.Link)){3};
end;

procedure TFhirConditionStage.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'summary') then Summary := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'assessment') then AssessmentList.add(propValue as TFhirResourceReference{Resource}){2}
  else inherited;
end;

function TFhirConditionStage.FhirType : string;
begin
  result := 'stage';
end;

function TFhirConditionStage.Link : TFhirConditionStage;
begin
  result := TFhirConditionStage(inherited Link);
end;

function TFhirConditionStage.Clone : TFhirConditionStage;
begin
  result := TFhirConditionStage(inherited Clone);
end;

{ TFhirConditionStage }

Procedure TFhirConditionStage.SetSummary(value : TFhirCodeableConcept);
begin
  FSummary.free;
  FSummary := value;
end;


{ TFhirConditionStageListEnumerator }

Constructor TFhirConditionStageListEnumerator.Create(list : TFhirConditionStageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConditionStageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionStageListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConditionStageListEnumerator.GetCurrent : TFhirConditionStage;
begin
  Result := FList[FIndex];
end;


{ TFhirConditionStageList }
procedure TFhirConditionStageList.AddItem(value: TFhirConditionStage);
begin
  assert(value.ClassName = 'TFhirConditionStage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionStage');
  add(value);
end;


function TFhirConditionStageList.Append: TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConditionStageList.ClearItems;
begin
  Clear;
end;

function TFhirConditionStageList.GetEnumerator : TFhirConditionStageListEnumerator;
begin
  result := TFhirConditionStageListEnumerator.Create(self.link);
end;

function TFhirConditionStageList.Clone: TFhirConditionStageList;
begin
  result := TFhirConditionStageList(inherited Clone);
end;

function TFhirConditionStageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionStageList.GetItemN(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage(ObjectByIndex[index]);
end;

function TFhirConditionStageList.IndexOf(value: TFhirConditionStage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConditionStageList.Insert(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConditionStageList.InsertItem(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  Inherited Insert(index, value);
end;

function TFhirConditionStageList.Item(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage(ObjectByIndex[index]);
end;

function TFhirConditionStageList.Link: TFhirConditionStageList;
begin
  result := TFhirConditionStageList(inherited Link);
end;

procedure TFhirConditionStageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionStageList.SetItemByIndex(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  FhirConditionStages[index] := value;
end;

procedure TFhirConditionStageList.SetItemN(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionEvidence }

constructor TFhirConditionEvidence.Create;
begin
  inherited;
  FDetailList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirConditionEvidence.Destroy;
begin
  FCode.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirConditionEvidence.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirConditionEvidence(oSource).code.Clone;
  FDetailList.Assign(TFhirConditionEvidence(oSource).FDetailList);
end;

procedure TFhirConditionEvidence.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'detail') Then
     list.addAll(FDetailList);
end;

procedure TFhirConditionEvidence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Resource(Any)', FDetailList.Link)){3};
end;

procedure TFhirConditionEvidence.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then Code := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'detail') then DetailList.add(propValue as TFhirResourceReference{Resource}){2}
  else inherited;
end;

function TFhirConditionEvidence.FhirType : string;
begin
  result := 'evidence';
end;

function TFhirConditionEvidence.Link : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(inherited Link);
end;

function TFhirConditionEvidence.Clone : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(inherited Clone);
end;

{ TFhirConditionEvidence }

Procedure TFhirConditionEvidence.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;


{ TFhirConditionEvidenceListEnumerator }

Constructor TFhirConditionEvidenceListEnumerator.Create(list : TFhirConditionEvidenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConditionEvidenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionEvidenceListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConditionEvidenceListEnumerator.GetCurrent : TFhirConditionEvidence;
begin
  Result := FList[FIndex];
end;


{ TFhirConditionEvidenceList }
procedure TFhirConditionEvidenceList.AddItem(value: TFhirConditionEvidence);
begin
  assert(value.ClassName = 'TFhirConditionEvidence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionEvidence');
  add(value);
end;


function TFhirConditionEvidenceList.Append: TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConditionEvidenceList.ClearItems;
begin
  Clear;
end;

function TFhirConditionEvidenceList.GetEnumerator : TFhirConditionEvidenceListEnumerator;
begin
  result := TFhirConditionEvidenceListEnumerator.Create(self.link);
end;

function TFhirConditionEvidenceList.Clone: TFhirConditionEvidenceList;
begin
  result := TFhirConditionEvidenceList(inherited Clone);
end;

function TFhirConditionEvidenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionEvidenceList.GetItemN(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(ObjectByIndex[index]);
end;

function TFhirConditionEvidenceList.IndexOf(value: TFhirConditionEvidence): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConditionEvidenceList.Insert(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConditionEvidenceList.InsertItem(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  Inherited Insert(index, value);
end;

function TFhirConditionEvidenceList.Item(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(ObjectByIndex[index]);
end;

function TFhirConditionEvidenceList.Link: TFhirConditionEvidenceList;
begin
  result := TFhirConditionEvidenceList(inherited Link);
end;

procedure TFhirConditionEvidenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionEvidenceList.SetItemByIndex(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  FhirConditionEvidences[index] := value;
end;

procedure TFhirConditionEvidenceList.SetItemN(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionLocation }

constructor TFhirConditionLocation.Create;
begin
  inherited;
end;

destructor TFhirConditionLocation.Destroy;
begin
  FCode.free;
  FDetail.free;
  inherited;
end;

procedure TFhirConditionLocation.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirConditionLocation(oSource).code.Clone;
  detailObject := TFhirConditionLocation(oSource).detailObject.Clone;
end;

procedure TFhirConditionLocation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'detail') Then
     list.add(FDetail.Link);
end;

procedure TFhirConditionLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'string', FDetail.Link));{2}
end;

procedure TFhirConditionLocation.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then Code := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'detail') then DetailObject := propValue as TFhirString{5a}
  else inherited;
end;

function TFhirConditionLocation.FhirType : string;
begin
  result := 'location';
end;

function TFhirConditionLocation.Link : TFhirConditionLocation;
begin
  result := TFhirConditionLocation(inherited Link);
end;

function TFhirConditionLocation.Clone : TFhirConditionLocation;
begin
  result := TFhirConditionLocation(inherited Clone);
end;

{ TFhirConditionLocation }

Procedure TFhirConditionLocation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirConditionLocation.SetDetail(value : TFhirString);
begin
  FDetail.free;
  FDetail := value;
end;

Function TFhirConditionLocation.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := FDetail.value;
end;

Procedure TFhirConditionLocation.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirString.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;


{ TFhirConditionLocationListEnumerator }

Constructor TFhirConditionLocationListEnumerator.Create(list : TFhirConditionLocationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConditionLocationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionLocationListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConditionLocationListEnumerator.GetCurrent : TFhirConditionLocation;
begin
  Result := FList[FIndex];
end;


{ TFhirConditionLocationList }
procedure TFhirConditionLocationList.AddItem(value: TFhirConditionLocation);
begin
  assert(value.ClassName = 'TFhirConditionLocation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionLocation');
  add(value);
end;


function TFhirConditionLocationList.Append: TFhirConditionLocation;
begin
  result := TFhirConditionLocation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConditionLocationList.ClearItems;
begin
  Clear;
end;

function TFhirConditionLocationList.GetEnumerator : TFhirConditionLocationListEnumerator;
begin
  result := TFhirConditionLocationListEnumerator.Create(self.link);
end;

function TFhirConditionLocationList.Clone: TFhirConditionLocationList;
begin
  result := TFhirConditionLocationList(inherited Clone);
end;

function TFhirConditionLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionLocationList.GetItemN(index: Integer): TFhirConditionLocation;
begin
  result := TFhirConditionLocation(ObjectByIndex[index]);
end;

function TFhirConditionLocationList.IndexOf(value: TFhirConditionLocation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConditionLocationList.Insert(index: Integer): TFhirConditionLocation;
begin
  result := TFhirConditionLocation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConditionLocationList.InsertItem(index: Integer; value: TFhirConditionLocation);
begin
  assert(value is TFhirConditionLocation);
  Inherited Insert(index, value);
end;

function TFhirConditionLocationList.Item(index: Integer): TFhirConditionLocation;
begin
  result := TFhirConditionLocation(ObjectByIndex[index]);
end;

function TFhirConditionLocationList.Link: TFhirConditionLocationList;
begin
  result := TFhirConditionLocationList(inherited Link);
end;

procedure TFhirConditionLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionLocationList.SetItemByIndex(index: Integer; value: TFhirConditionLocation);
begin
  assert(value is TFhirConditionLocation);
  FhirConditionLocations[index] := value;
end;

procedure TFhirConditionLocationList.SetItemN(index: Integer; value: TFhirConditionLocation);
begin
  assert(value is TFhirConditionLocation);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionRelatedItem }

constructor TFhirConditionRelatedItem.Create;
begin
  inherited;
end;

destructor TFhirConditionRelatedItem.Destroy;
begin
  FType_.free;
  FCode.free;
  FTarget.free;
  inherited;
end;

procedure TFhirConditionRelatedItem.Assign(oSource : TAdvObject);
begin
  inherited;
  FType_ := TFhirConditionRelatedItem(oSource).FType_.Link;
  code := TFhirConditionRelatedItem(oSource).code.Clone;
  target := TFhirConditionRelatedItem(oSource).target.Clone;
end;

procedure TFhirConditionRelatedItem.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'target') Then
     list.add(FTarget.Link);
end;

procedure TFhirConditionRelatedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(Condition|Procedure|MedicationAdministration|Immunization|MedicationStatement)', FTarget.Link));{2}
end;

procedure TFhirConditionRelatedItem.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'type') then Type_Object := propValue as TFHIREnum
  else if (propName = 'code') then Code := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'target') then Target := propValue as TFhirResourceReference{Resource}{4b}
  else inherited;
end;

function TFhirConditionRelatedItem.FhirType : string;
begin
  result := 'relatedItem';
end;

function TFhirConditionRelatedItem.Link : TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem(inherited Link);
end;

function TFhirConditionRelatedItem.Clone : TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem(inherited Clone);
end;

{ TFhirConditionRelatedItem }

Procedure TFhirConditionRelatedItem.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConditionRelatedItem.GetType_ST : TFhirConditionRelationshipType;
begin
  if FType_ = nil then
    result := TFhirConditionRelationshipType(0)
  else
    result := TFhirConditionRelationshipType(StringArrayIndexOfSensitive(CODES_TFhirConditionRelationshipType, FType_.value));
end;

Procedure TFhirConditionRelatedItem.SetType_ST(value : TFhirConditionRelationshipType);
begin
  if ord(value) = 0 then
    Type_Object := nil
  else
    Type_Object := TFhirEnum.create(CODES_TFhirConditionRelationshipType[value]);
end;

Procedure TFhirConditionRelatedItem.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirConditionRelatedItem.SetTarget(value : TFhirResourceReference{Resource});
begin
  FTarget.free;
  FTarget := value;
end;


{ TFhirConditionRelatedItemListEnumerator }

Constructor TFhirConditionRelatedItemListEnumerator.Create(list : TFhirConditionRelatedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConditionRelatedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionRelatedItemListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConditionRelatedItemListEnumerator.GetCurrent : TFhirConditionRelatedItem;
begin
  Result := FList[FIndex];
end;


{ TFhirConditionRelatedItemList }
procedure TFhirConditionRelatedItemList.AddItem(value: TFhirConditionRelatedItem);
begin
  assert(value.ClassName = 'TFhirConditionRelatedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionRelatedItem');
  add(value);
end;


function TFhirConditionRelatedItemList.Append: TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConditionRelatedItemList.ClearItems;
begin
  Clear;
end;

function TFhirConditionRelatedItemList.GetEnumerator : TFhirConditionRelatedItemListEnumerator;
begin
  result := TFhirConditionRelatedItemListEnumerator.Create(self.link);
end;

function TFhirConditionRelatedItemList.Clone: TFhirConditionRelatedItemList;
begin
  result := TFhirConditionRelatedItemList(inherited Clone);
end;

function TFhirConditionRelatedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionRelatedItemList.GetItemN(index: Integer): TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem(ObjectByIndex[index]);
end;

function TFhirConditionRelatedItemList.IndexOf(value: TFhirConditionRelatedItem): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConditionRelatedItemList.Insert(index: Integer): TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConditionRelatedItemList.InsertItem(index: Integer; value: TFhirConditionRelatedItem);
begin
  assert(value is TFhirConditionRelatedItem);
  Inherited Insert(index, value);
end;

function TFhirConditionRelatedItemList.Item(index: Integer): TFhirConditionRelatedItem;
begin
  result := TFhirConditionRelatedItem(ObjectByIndex[index]);
end;

function TFhirConditionRelatedItemList.Link: TFhirConditionRelatedItemList;
begin
  result := TFhirConditionRelatedItemList(inherited Link);
end;

procedure TFhirConditionRelatedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionRelatedItemList.SetItemByIndex(index: Integer; value: TFhirConditionRelatedItem);
begin
  assert(value is TFhirConditionRelatedItem);
  FhirConditionRelatedItems[index] := value;
end;

procedure TFhirConditionRelatedItemList.SetItemN(index: Integer; value: TFhirConditionRelatedItem);
begin
  assert(value is TFhirConditionRelatedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceSoftware }

constructor TFhirConformanceSoftware.Create;
begin
  inherited;
end;

destructor TFhirConformanceSoftware.Destroy;
begin
  FName.free;
  FVersion.free;
  FReleaseDate.free;
  inherited;
end;

procedure TFhirConformanceSoftware.Assign(oSource : TAdvObject);
begin
  inherited;
  nameObject := TFhirConformanceSoftware(oSource).nameObject.Clone;
  versionObject := TFhirConformanceSoftware(oSource).versionObject.Clone;
  releaseDateObject := TFhirConformanceSoftware(oSource).releaseDateObject.Clone;
end;

procedure TFhirConformanceSoftware.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'version') Then
     list.add(FVersion.Link);
  if (child_name = 'releaseDate') Then
     list.add(FReleaseDate.Link);
end;

procedure TFhirConformanceSoftware.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'releaseDate', 'dateTime', FReleaseDate.Link));{2}
end;

procedure TFhirConformanceSoftware.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'version') then VersionObject := propValue as TFhirString{5a}
  else if (propName = 'releaseDate') then ReleaseDateObject := propValue as TFhirDateTime{5a}
  else inherited;
end;

function TFhirConformanceSoftware.FhirType : string;
begin
  result := 'software';
end;

function TFhirConformanceSoftware.Link : TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(inherited Link);
end;

function TFhirConformanceSoftware.Clone : TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(inherited Clone);
end;

{ TFhirConformanceSoftware }

Procedure TFhirConformanceSoftware.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConformanceSoftware.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirConformanceSoftware.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirConformanceSoftware.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirConformanceSoftware.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirConformanceSoftware.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirConformanceSoftware.SetReleaseDate(value : TFhirDateTime);
begin
  FReleaseDate.free;
  FReleaseDate := value;
end;

Function TFhirConformanceSoftware.GetReleaseDateST : TDateTimeEx;
begin
  if FReleaseDate = nil then
    result := nil
  else
    result := FReleaseDate.value;
end;

Procedure TFhirConformanceSoftware.SetReleaseDateST(value : TDateTimeEx);
begin
  if value <> nil then
  begin
    if FReleaseDate = nil then
      FReleaseDate := TFhirDateTime.create;
    FReleaseDate.value := value
  end
  else if FReleaseDate <> nil then
    FReleaseDate.value := nil;
end;


{ TFhirConformanceSoftwareListEnumerator }

Constructor TFhirConformanceSoftwareListEnumerator.Create(list : TFhirConformanceSoftwareList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConformanceSoftwareListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceSoftwareListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConformanceSoftwareListEnumerator.GetCurrent : TFhirConformanceSoftware;
begin
  Result := FList[FIndex];
end;


{ TFhirConformanceSoftwareList }
procedure TFhirConformanceSoftwareList.AddItem(value: TFhirConformanceSoftware);
begin
  assert(value.ClassName = 'TFhirConformanceSoftware', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceSoftware');
  add(value);
end;


function TFhirConformanceSoftwareList.Append: TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceSoftwareList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceSoftwareList.GetEnumerator : TFhirConformanceSoftwareListEnumerator;
begin
  result := TFhirConformanceSoftwareListEnumerator.Create(self.link);
end;

function TFhirConformanceSoftwareList.Clone: TFhirConformanceSoftwareList;
begin
  result := TFhirConformanceSoftwareList(inherited Clone);
end;

function TFhirConformanceSoftwareList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceSoftwareList.GetItemN(index: Integer): TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(ObjectByIndex[index]);
end;

function TFhirConformanceSoftwareList.IndexOf(value: TFhirConformanceSoftware): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceSoftwareList.Insert(index: Integer): TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceSoftwareList.InsertItem(index: Integer; value: TFhirConformanceSoftware);
begin
  assert(value is TFhirConformanceSoftware);
  Inherited Insert(index, value);
end;

function TFhirConformanceSoftwareList.Item(index: Integer): TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(ObjectByIndex[index]);
end;

function TFhirConformanceSoftwareList.Link: TFhirConformanceSoftwareList;
begin
  result := TFhirConformanceSoftwareList(inherited Link);
end;

procedure TFhirConformanceSoftwareList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceSoftwareList.SetItemByIndex(index: Integer; value: TFhirConformanceSoftware);
begin
  assert(value is TFhirConformanceSoftware);
  FhirConformanceSoftwares[index] := value;
end;

procedure TFhirConformanceSoftwareList.SetItemN(index: Integer; value: TFhirConformanceSoftware);
begin
  assert(value is TFhirConformanceSoftware);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceImplementation }

constructor TFhirConformanceImplementation.Create;
begin
  inherited;
end;

destructor TFhirConformanceImplementation.Destroy;
begin
  FDescription.free;
  FUrl.free;
  inherited;
end;

procedure TFhirConformanceImplementation.Assign(oSource : TAdvObject);
begin
  inherited;
  descriptionObject := TFhirConformanceImplementation(oSource).descriptionObject.Clone;
  urlObject := TFhirConformanceImplementation(oSource).urlObject.Clone;
end;

procedure TFhirConformanceImplementation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(FDescription.Link);
  if (child_name = 'url') Then
     list.add(FUrl.Link);
end;

procedure TFhirConformanceImplementation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', FUrl.Link));{2}
end;

procedure TFhirConformanceImplementation.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'description') then DescriptionObject := propValue as TFhirString{5a}
  else if (propName = 'url') then UrlObject := propValue as TFhirUri{5a}
  else inherited;
end;

function TFhirConformanceImplementation.FhirType : string;
begin
  result := 'implementation';
end;

function TFhirConformanceImplementation.Link : TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(inherited Link);
end;

function TFhirConformanceImplementation.Clone : TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(inherited Clone);
end;

{ TFhirConformanceImplementation }

Procedure TFhirConformanceImplementation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirConformanceImplementation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirConformanceImplementation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirConformanceImplementation.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirConformanceImplementation.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirConformanceImplementation.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;


{ TFhirConformanceImplementationListEnumerator }

Constructor TFhirConformanceImplementationListEnumerator.Create(list : TFhirConformanceImplementationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConformanceImplementationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceImplementationListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConformanceImplementationListEnumerator.GetCurrent : TFhirConformanceImplementation;
begin
  Result := FList[FIndex];
end;


{ TFhirConformanceImplementationList }
procedure TFhirConformanceImplementationList.AddItem(value: TFhirConformanceImplementation);
begin
  assert(value.ClassName = 'TFhirConformanceImplementation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceImplementation');
  add(value);
end;


function TFhirConformanceImplementationList.Append: TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceImplementationList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceImplementationList.GetEnumerator : TFhirConformanceImplementationListEnumerator;
begin
  result := TFhirConformanceImplementationListEnumerator.Create(self.link);
end;

function TFhirConformanceImplementationList.Clone: TFhirConformanceImplementationList;
begin
  result := TFhirConformanceImplementationList(inherited Clone);
end;

function TFhirConformanceImplementationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceImplementationList.GetItemN(index: Integer): TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(ObjectByIndex[index]);
end;

function TFhirConformanceImplementationList.IndexOf(value: TFhirConformanceImplementation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceImplementationList.Insert(index: Integer): TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceImplementationList.InsertItem(index: Integer; value: TFhirConformanceImplementation);
begin
  assert(value is TFhirConformanceImplementation);
  Inherited Insert(index, value);
end;

function TFhirConformanceImplementationList.Item(index: Integer): TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(ObjectByIndex[index]);
end;

function TFhirConformanceImplementationList.Link: TFhirConformanceImplementationList;
begin
  result := TFhirConformanceImplementationList(inherited Link);
end;

procedure TFhirConformanceImplementationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceImplementationList.SetItemByIndex(index: Integer; value: TFhirConformanceImplementation);
begin
  assert(value is TFhirConformanceImplementation);
  FhirConformanceImplementations[index] := value;
end;

procedure TFhirConformanceImplementationList.SetItemN(index: Integer; value: TFhirConformanceImplementation);
begin
  assert(value is TFhirConformanceImplementation);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRest }

constructor TFhirConformanceRest.Create;
begin
  inherited;
  FResourceList := TFhirConformanceRestResourceList.Create;
  FOperationList := TFhirConformanceRestOperationList.Create;
  FQueryList := TFhirConformanceRestQueryList.Create;
  FDocumentMailboxList := TFhirUriList.Create;
end;

destructor TFhirConformanceRest.Destroy;
begin
  FMode.free;
  FDocumentation.free;
  FSecurity.free;
  FResourceList.Free;
  FOperationList.Free;
  FQueryList.Free;
  FDocumentMailboxList.Free;
  inherited;
end;

procedure TFhirConformanceRest.Assign(oSource : TAdvObject);
begin
  inherited;
  FMode := TFhirConformanceRest(oSource).FMode.Link;
  documentationObject := TFhirConformanceRest(oSource).documentationObject.Clone;
  security := TFhirConformanceRest(oSource).security.Clone;
  FResourceList.Assign(TFhirConformanceRest(oSource).FResourceList);
  FOperationList.Assign(TFhirConformanceRest(oSource).FOperationList);
  FQueryList.Assign(TFhirConformanceRest(oSource).FQueryList);
  FDocumentMailboxList.Assign(TFhirConformanceRest(oSource).FDocumentMailboxList);
end;

procedure TFhirConformanceRest.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(FMode.Link);
  if (child_name = 'documentation') Then
     list.add(FDocumentation.Link);
  if (child_name = 'security') Then
     list.add(FSecurity.Link);
  if (child_name = 'resource') Then
     list.addAll(FResourceList);
  if (child_name = 'operation') Then
     list.addAll(FOperationList);
  if (child_name = 'query') Then
     list.addAll(FQueryList);
  if (child_name = 'documentMailbox') Then
     list.addAll(FDocumentMailboxList);
end;

procedure TFhirConformanceRest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'security', '', FSecurity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', '', FResourceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'operation', '', FOperationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'query', '', FQueryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'documentMailbox', 'uri', FDocumentMailboxList.Link)){3};
end;

procedure TFhirConformanceRest.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'mode') then ModeObject := propValue as TFHIREnum
  else if (propName = 'documentation') then DocumentationObject := propValue as TFhirString{5a}
  else if (propName = 'security') then Security := propValue as TFhirConformanceRestSecurity{4b}
  else if (propName = 'resource') then ResourceList.add(propValue as TFhirConformanceRestResource){2}
  else if (propName = 'operation') then OperationList.add(propValue as TFhirConformanceRestOperation){2}
  else if (propName = 'query') then QueryList.add(propValue as TFhirConformanceRestQuery){2}
  else if (propName = 'documentMailbox') then DocumentMailboxList.add(propValue as TFhirUri){2}
  else inherited;
end;

function TFhirConformanceRest.FhirType : string;
begin
  result := 'rest';
end;

function TFhirConformanceRest.Link : TFhirConformanceRest;
begin
  result := TFhirConformanceRest(inherited Link);
end;

function TFhirConformanceRest.Clone : TFhirConformanceRest;
begin
  result := TFhirConformanceRest(inherited Clone);
end;

{ TFhirConformanceRest }

Procedure TFhirConformanceRest.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirConformanceRest.GetModeST : TFhirRestfulConformanceMode;
begin
  if FMode = nil then
    result := TFhirRestfulConformanceMode(0)
  else
    result := TFhirRestfulConformanceMode(StringArrayIndexOfSensitive(CODES_TFhirRestfulConformanceMode, FMode.value));
end;

Procedure TFhirConformanceRest.SetModeST(value : TFhirRestfulConformanceMode);
begin
  if ord(value) = 0 then
    ModeObject := nil
  else
    ModeObject := TFhirEnum.create(CODES_TFhirRestfulConformanceMode[value]);
end;

Procedure TFhirConformanceRest.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRest.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceRest.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirConformanceRest.SetSecurity(value : TFhirConformanceRestSecurity);
begin
  FSecurity.free;
  FSecurity := value;
end;


{ TFhirConformanceRestListEnumerator }

Constructor TFhirConformanceRestListEnumerator.Create(list : TFhirConformanceRestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConformanceRestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConformanceRestListEnumerator.GetCurrent : TFhirConformanceRest;
begin
  Result := FList[FIndex];
end;


{ TFhirConformanceRestList }
procedure TFhirConformanceRestList.AddItem(value: TFhirConformanceRest);
begin
  assert(value.ClassName = 'TFhirConformanceRest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRest');
  add(value);
end;


function TFhirConformanceRestList.Append: TFhirConformanceRest;
begin
  result := TFhirConformanceRest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestList.GetEnumerator : TFhirConformanceRestListEnumerator;
begin
  result := TFhirConformanceRestListEnumerator.Create(self.link);
end;

function TFhirConformanceRestList.Clone: TFhirConformanceRestList;
begin
  result := TFhirConformanceRestList(inherited Clone);
end;

function TFhirConformanceRestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestList.GetItemN(index: Integer): TFhirConformanceRest;
begin
  result := TFhirConformanceRest(ObjectByIndex[index]);
end;

function TFhirConformanceRestList.IndexOf(value: TFhirConformanceRest): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestList.Insert(index: Integer): TFhirConformanceRest;
begin
  result := TFhirConformanceRest.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestList.InsertItem(index: Integer; value: TFhirConformanceRest);
begin
  assert(value is TFhirConformanceRest);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestList.Item(index: Integer): TFhirConformanceRest;
begin
  result := TFhirConformanceRest(ObjectByIndex[index]);
end;

function TFhirConformanceRestList.Link: TFhirConformanceRestList;
begin
  result := TFhirConformanceRestList(inherited Link);
end;

procedure TFhirConformanceRestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestList.SetItemByIndex(index: Integer; value: TFhirConformanceRest);
begin
  assert(value is TFhirConformanceRest);
  FhirConformanceRests[index] := value;
end;

procedure TFhirConformanceRestList.SetItemN(index: Integer; value: TFhirConformanceRest);
begin
  assert(value is TFhirConformanceRest);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestSecurity }

constructor TFhirConformanceRestSecurity.Create;
begin
  inherited;
  FServiceList := TFhirCodeableConceptList.Create;
  FCertificateList := TFhirConformanceRestSecurityCertificateList.Create;
end;

destructor TFhirConformanceRestSecurity.Destroy;
begin
  FCors.free;
  FServiceList.Free;
  FDescription.free;
  FCertificateList.Free;
  inherited;
end;

procedure TFhirConformanceRestSecurity.Assign(oSource : TAdvObject);
begin
  inherited;
  corsObject := TFhirConformanceRestSecurity(oSource).corsObject.Clone;
  FServiceList.Assign(TFhirConformanceRestSecurity(oSource).FServiceList);
  descriptionObject := TFhirConformanceRestSecurity(oSource).descriptionObject.Clone;
  FCertificateList.Assign(TFhirConformanceRestSecurity(oSource).FCertificateList);
end;

procedure TFhirConformanceRestSecurity.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'cors') Then
     list.add(FCors.Link);
  if (child_name = 'service') Then
     list.addAll(FServiceList);
  if (child_name = 'description') Then
     list.add(FDescription.Link);
  if (child_name = 'certificate') Then
     list.addAll(FCertificateList);
end;

procedure TFhirConformanceRestSecurity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'cors', 'boolean', FCors.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', FServiceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'certificate', '', FCertificateList.Link)){3};
end;

procedure TFhirConformanceRestSecurity.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'cors') then CorsObject := propValue as TFhirBoolean{5a}
  else if (propName = 'service') then ServiceList.add(propValue as TFhirCodeableConcept){2}
  else if (propName = 'description') then DescriptionObject := propValue as TFhirString{5a}
  else if (propName = 'certificate') then CertificateList.add(propValue as TFhirConformanceRestSecurityCertificate){2}
  else inherited;
end;

function TFhirConformanceRestSecurity.FhirType : string;
begin
  result := 'security';
end;

function TFhirConformanceRestSecurity.Link : TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(inherited Link);
end;

function TFhirConformanceRestSecurity.Clone : TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(inherited Clone);
end;

{ TFhirConformanceRestSecurity }

Procedure TFhirConformanceRestSecurity.SetCors(value : TFhirBoolean);
begin
  FCors.free;
  FCors := value;
end;

Function TFhirConformanceRestSecurity.GetCorsST : Boolean;
begin
  if FCors = nil then
    result := false
  else
    result := FCors.value;
end;

Procedure TFhirConformanceRestSecurity.SetCorsST(value : Boolean);
begin
  if FCors = nil then
    FCors := TFhirBoolean.create;
  FCors.value := value
end;

Procedure TFhirConformanceRestSecurity.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirConformanceRestSecurity.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirConformanceRestSecurity.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;


{ TFhirConformanceRestSecurityListEnumerator }

Constructor TFhirConformanceRestSecurityListEnumerator.Create(list : TFhirConformanceRestSecurityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConformanceRestSecurityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestSecurityListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConformanceRestSecurityListEnumerator.GetCurrent : TFhirConformanceRestSecurity;
begin
  Result := FList[FIndex];
end;


{ TFhirConformanceRestSecurityList }
procedure TFhirConformanceRestSecurityList.AddItem(value: TFhirConformanceRestSecurity);
begin
  assert(value.ClassName = 'TFhirConformanceRestSecurity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestSecurity');
  add(value);
end;


function TFhirConformanceRestSecurityList.Append: TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestSecurityList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestSecurityList.GetEnumerator : TFhirConformanceRestSecurityListEnumerator;
begin
  result := TFhirConformanceRestSecurityListEnumerator.Create(self.link);
end;

function TFhirConformanceRestSecurityList.Clone: TFhirConformanceRestSecurityList;
begin
  result := TFhirConformanceRestSecurityList(inherited Clone);
end;

function TFhirConformanceRestSecurityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestSecurityList.GetItemN(index: Integer): TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityList.IndexOf(value: TFhirConformanceRestSecurity): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestSecurityList.Insert(index: Integer): TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestSecurityList.InsertItem(index: Integer; value: TFhirConformanceRestSecurity);
begin
  assert(value is TFhirConformanceRestSecurity);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestSecurityList.Item(index: Integer): TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityList.Link: TFhirConformanceRestSecurityList;
begin
  result := TFhirConformanceRestSecurityList(inherited Link);
end;

procedure TFhirConformanceRestSecurityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestSecurityList.SetItemByIndex(index: Integer; value: TFhirConformanceRestSecurity);
begin
  assert(value is TFhirConformanceRestSecurity);
  FhirConformanceRestSecurities[index] := value;
end;

procedure TFhirConformanceRestSecurityList.SetItemN(index: Integer; value: TFhirConformanceRestSecurity);
begin
  assert(value is TFhirConformanceRestSecurity);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestSecurityCertificate }

constructor TFhirConformanceRestSecurityCertificate.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestSecurityCertificate.Destroy;
begin
  FType_.free;
  FBlob.free;
  inherited;
end;

procedure TFhirConformanceRestSecurityCertificate.Assign(oSource : TAdvObject);
begin
  inherited;
  type_Object := TFhirConformanceRestSecurityCertificate(oSource).type_Object.Clone;
  blobObject := TFhirConformanceRestSecurityCertificate(oSource).blobObject.Clone;
end;

procedure TFhirConformanceRestSecurityCertificate.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'blob') Then
     list.add(FBlob.Link);
end;

procedure TFhirConformanceRestSecurityCertificate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'blob', 'base64Binary', FBlob.Link));{2}
end;

procedure TFhirConformanceRestSecurityCertificate.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'type') then
    if propValue is TFHIRCode then
      Type_Object := propValue as TFhirCode{5}
    else if propValue is TFHIREnum then
      Type_Object := TFHIRCode.create(TFHIREnum(propValue).value)
    else
      raise Exception.Create('Type mismatch: cannot convert from "'+propValue.className+'" to "TFHIRCode"'){5a}
  else if (propName = 'blob') then BlobObject := propValue as TFhirBase64Binary{5a}
  else inherited;
end;

function TFhirConformanceRestSecurityCertificate.FhirType : string;
begin
  result := 'certificate';
end;

function TFhirConformanceRestSecurityCertificate.Link : TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(inherited Link);
end;

function TFhirConformanceRestSecurityCertificate.Clone : TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(inherited Clone);
end;

{ TFhirConformanceRestSecurityCertificate }

Procedure TFhirConformanceRestSecurityCertificate.SetType_(value : TFhirCode);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConformanceRestSecurityCertificate.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirConformanceRestSecurityCertificate.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirCode.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirConformanceRestSecurityCertificate.SetBlob(value : TFhirBase64Binary);
begin
  FBlob.free;
  FBlob := value;
end;

Function TFhirConformanceRestSecurityCertificate.GetBlobST : String;
begin
  if FBlob = nil then
    result := ''
  else
    result := FBlob.value;
end;

Procedure TFhirConformanceRestSecurityCertificate.SetBlobST(value : String);
begin
  if value <> '' then
  begin
    if FBlob = nil then
      FBlob := TFhirBase64Binary.create;
    FBlob.value := value
  end
  else if FBlob <> nil then
    FBlob.value := '';
end;


{ TFhirConformanceRestSecurityCertificateListEnumerator }

Constructor TFhirConformanceRestSecurityCertificateListEnumerator.Create(list : TFhirConformanceRestSecurityCertificateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConformanceRestSecurityCertificateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestSecurityCertificateListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConformanceRestSecurityCertificateListEnumerator.GetCurrent : TFhirConformanceRestSecurityCertificate;
begin
  Result := FList[FIndex];
end;


{ TFhirConformanceRestSecurityCertificateList }
procedure TFhirConformanceRestSecurityCertificateList.AddItem(value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value.ClassName = 'TFhirConformanceRestSecurityCertificate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestSecurityCertificate');
  add(value);
end;


function TFhirConformanceRestSecurityCertificateList.Append: TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestSecurityCertificateList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestSecurityCertificateList.GetEnumerator : TFhirConformanceRestSecurityCertificateListEnumerator;
begin
  result := TFhirConformanceRestSecurityCertificateListEnumerator.Create(self.link);
end;

function TFhirConformanceRestSecurityCertificateList.Clone: TFhirConformanceRestSecurityCertificateList;
begin
  result := TFhirConformanceRestSecurityCertificateList(inherited Clone);
end;

function TFhirConformanceRestSecurityCertificateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestSecurityCertificateList.GetItemN(index: Integer): TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityCertificateList.IndexOf(value: TFhirConformanceRestSecurityCertificate): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestSecurityCertificateList.Insert(index: Integer): TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestSecurityCertificateList.InsertItem(index: Integer; value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value is TFhirConformanceRestSecurityCertificate);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestSecurityCertificateList.Item(index: Integer): TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityCertificateList.Link: TFhirConformanceRestSecurityCertificateList;
begin
  result := TFhirConformanceRestSecurityCertificateList(inherited Link);
end;

procedure TFhirConformanceRestSecurityCertificateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestSecurityCertificateList.SetItemByIndex(index: Integer; value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value is TFhirConformanceRestSecurityCertificate);
  FhirConformanceRestSecurityCertificates[index] := value;
end;

procedure TFhirConformanceRestSecurityCertificateList.SetItemN(index: Integer; value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value is TFhirConformanceRestSecurityCertificate);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestResource }

constructor TFhirConformanceRestResource.Create;
begin
  inherited;
  FOperationList := TFhirConformanceRestResourceOperationList.Create;
  FSearchIncludeList := TFhirStringList.Create;
  FSearchParamList := TFhirConformanceRestResourceSearchParamList.Create;
end;

destructor TFhirConformanceRestResource.Destroy;
begin
  FType_.free;
  FProfile.free;
  FOperationList.Free;
  FReadHistory.free;
  FUpdateCreate.free;
  FSearchIncludeList.Free;
  FSearchParamList.Free;
  inherited;
end;

procedure TFhirConformanceRestResource.Assign(oSource : TAdvObject);
begin
  inherited;
  type_Object := TFhirConformanceRestResource(oSource).type_Object.Clone;
  profile := TFhirConformanceRestResource(oSource).profile.Clone;
  FOperationList.Assign(TFhirConformanceRestResource(oSource).FOperationList);
  readHistoryObject := TFhirConformanceRestResource(oSource).readHistoryObject.Clone;
  updateCreateObject := TFhirConformanceRestResource(oSource).updateCreateObject.Clone;
  FSearchIncludeList.Assign(TFhirConformanceRestResource(oSource).FSearchIncludeList);
  FSearchParamList.Assign(TFhirConformanceRestResource(oSource).FSearchParamList);
end;

procedure TFhirConformanceRestResource.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'profile') Then
     list.add(FProfile.Link);
  if (child_name = 'operation') Then
     list.addAll(FOperationList);
  if (child_name = 'readHistory') Then
     list.add(FReadHistory.Link);
  if (child_name = 'updateCreate') Then
     list.add(FUpdateCreate.Link);
  if (child_name = 'searchInclude') Then
     list.addAll(FSearchIncludeList);
  if (child_name = 'searchParam') Then
     list.addAll(FSearchParamList);
end;

procedure TFhirConformanceRestResource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'Resource(Profile)', FProfile.Link));{2}
  oList.add(TFHIRProperty.create(self, 'operation', '', FOperationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'readHistory', 'boolean', FReadHistory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'updateCreate', 'boolean', FUpdateCreate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'searchInclude', 'string', FSearchIncludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'searchParam', '', FSearchParamList.Link)){3};
end;

procedure TFhirConformanceRestResource.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'type') then
    if propValue is TFHIRCode then
      Type_Object := propValue as TFhirCode{5}
    else if propValue is TFHIREnum then
      Type_Object := TFHIRCode.create(TFHIREnum(propValue).value)
    else
      raise Exception.Create('Type mismatch: cannot convert from "'+propValue.className+'" to "TFHIRCode"'){5a}
  else if (propName = 'profile') then Profile := propValue as TFhirResourceReference{TFhirProfile}{4b}
  else if (propName = 'operation') then OperationList.add(propValue as TFhirConformanceRestResourceOperation){2}
  else if (propName = 'readHistory') then ReadHistoryObject := propValue as TFhirBoolean{5a}
  else if (propName = 'updateCreate') then UpdateCreateObject := propValue as TFhirBoolean{5a}
  else if (propName = 'searchInclude') then SearchIncludeList.add(propValue as TFhirString){2}
  else if (propName = 'searchParam') then SearchParamList.add(propValue as TFhirConformanceRestResourceSearchParam){2}
  else inherited;
end;

function TFhirConformanceRestResource.FhirType : string;
begin
  result := 'resource';
end;

function TFhirConformanceRestResource.Link : TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(inherited Link);
end;

function TFhirConformanceRestResource.Clone : TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(inherited Clone);
end;

{ TFhirConformanceRestResource }

Procedure TFhirConformanceRestResource.SetType_(value : TFhirCode);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConformanceRestResource.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirConformanceRestResource.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirCode.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirConformanceRestResource.SetProfile(value : TFhirResourceReference{TFhirProfile});
begin
  FProfile.free;
  FProfile := value;
end;

Procedure TFhirConformanceRestResource.SetReadHistory(value : TFhirBoolean);
begin
  FReadHistory.free;
  FReadHistory := value;
end;

Function TFhirConformanceRestResource.GetReadHistoryST : Boolean;
begin
  if FReadHistory = nil then
    result := false
  else
    result := FReadHistory.value;
end;

Procedure TFhirConformanceRestResource.SetReadHistoryST(value : Boolean);
begin
  if FReadHistory = nil then
    FReadHistory := TFhirBoolean.create;
  FReadHistory.value := value
end;

Procedure TFhirConformanceRestResource.SetUpdateCreate(value : TFhirBoolean);
begin
  FUpdateCreate.free;
  FUpdateCreate := value;
end;

Function TFhirConformanceRestResource.GetUpdateCreateST : Boolean;
begin
  if FUpdateCreate = nil then
    result := false
  else
    result := FUpdateCreate.value;
end;

Procedure TFhirConformanceRestResource.SetUpdateCreateST(value : Boolean);
begin
  if FUpdateCreate = nil then
    FUpdateCreate := TFhirBoolean.create;
  FUpdateCreate.value := value
end;


{ TFhirConformanceRestResourceListEnumerator }

Constructor TFhirConformanceRestResourceListEnumerator.Create(list : TFhirConformanceRestResourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConformanceRestResourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestResourceListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConformanceRestResourceListEnumerator.GetCurrent : TFhirConformanceRestResource;
begin
  Result := FList[FIndex];
end;


{ TFhirConformanceRestResourceList }
procedure TFhirConformanceRestResourceList.AddItem(value: TFhirConformanceRestResource);
begin
  assert(value.ClassName = 'TFhirConformanceRestResource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestResource');
  add(value);
end;


function TFhirConformanceRestResourceList.Append: TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestResourceList.GetEnumerator : TFhirConformanceRestResourceListEnumerator;
begin
  result := TFhirConformanceRestResourceListEnumerator.Create(self.link);
end;

function TFhirConformanceRestResourceList.Clone: TFhirConformanceRestResourceList;
begin
  result := TFhirConformanceRestResourceList(inherited Clone);
end;

function TFhirConformanceRestResourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestResourceList.GetItemN(index: Integer): TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceList.IndexOf(value: TFhirConformanceRestResource): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestResourceList.Insert(index: Integer): TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceList.InsertItem(index: Integer; value: TFhirConformanceRestResource);
begin
  assert(value is TFhirConformanceRestResource);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestResourceList.Item(index: Integer): TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceList.Link: TFhirConformanceRestResourceList;
begin
  result := TFhirConformanceRestResourceList(inherited Link);
end;

procedure TFhirConformanceRestResourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestResourceList.SetItemByIndex(index: Integer; value: TFhirConformanceRestResource);
begin
  assert(value is TFhirConformanceRestResource);
  FhirConformanceRestResources[index] := value;
end;

procedure TFhirConformanceRestResourceList.SetItemN(index: Integer; value: TFhirConformanceRestResource);
begin
  assert(value is TFhirConformanceRestResource);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestResourceOperation }

constructor TFhirConformanceRestResourceOperation.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestResourceOperation.Destroy;
begin
  FCode.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirConformanceRestResourceOperation.Assign(oSource : TAdvObject);
begin
  inherited;
  FCode := TFhirConformanceRestResourceOperation(oSource).FCode.Link;
  documentationObject := TFhirConformanceRestResourceOperation(oSource).documentationObject.Clone;
end;

procedure TFhirConformanceRestResourceOperation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'documentation') Then
     list.add(FDocumentation.Link);
end;

procedure TFhirConformanceRestResourceOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link));{2}
end;

procedure TFhirConformanceRestResourceOperation.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then CodeObject := propValue as TFHIREnum
  else if (propName = 'documentation') then DocumentationObject := propValue as TFhirString{5a}
  else inherited;
end;

function TFhirConformanceRestResourceOperation.FhirType : string;
begin
  result := 'operation';
end;

function TFhirConformanceRestResourceOperation.Link : TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation(inherited Link);
end;

function TFhirConformanceRestResourceOperation.Clone : TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation(inherited Clone);
end;

{ TFhirConformanceRestResourceOperation }

Procedure TFhirConformanceRestResourceOperation.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConformanceRestResourceOperation.GetCodeST : TFhirTypeRestfulOperation;
begin
  if FCode = nil then
    result := TFhirTypeRestfulOperation(0)
  else
    result := TFhirTypeRestfulOperation(StringArrayIndexOfSensitive(CODES_TFhirTypeRestfulOperation, FCode.value));
end;

Procedure TFhirConformanceRestResourceOperation.SetCodeST(value : TFhirTypeRestfulOperation);
begin
  if ord(value) = 0 then
    CodeObject := nil
  else
    CodeObject := TFhirEnum.create(CODES_TFhirTypeRestfulOperation[value]);
end;

Procedure TFhirConformanceRestResourceOperation.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRestResourceOperation.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceRestResourceOperation.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceRestResourceOperationListEnumerator }

Constructor TFhirConformanceRestResourceOperationListEnumerator.Create(list : TFhirConformanceRestResourceOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConformanceRestResourceOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestResourceOperationListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConformanceRestResourceOperationListEnumerator.GetCurrent : TFhirConformanceRestResourceOperation;
begin
  Result := FList[FIndex];
end;


{ TFhirConformanceRestResourceOperationList }
procedure TFhirConformanceRestResourceOperationList.AddItem(value: TFhirConformanceRestResourceOperation);
begin
  assert(value.ClassName = 'TFhirConformanceRestResourceOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestResourceOperation');
  add(value);
end;


function TFhirConformanceRestResourceOperationList.Append: TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceOperationList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestResourceOperationList.GetEnumerator : TFhirConformanceRestResourceOperationListEnumerator;
begin
  result := TFhirConformanceRestResourceOperationListEnumerator.Create(self.link);
end;

function TFhirConformanceRestResourceOperationList.Clone: TFhirConformanceRestResourceOperationList;
begin
  result := TFhirConformanceRestResourceOperationList(inherited Clone);
end;

function TFhirConformanceRestResourceOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestResourceOperationList.GetItemN(index: Integer): TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceOperationList.IndexOf(value: TFhirConformanceRestResourceOperation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestResourceOperationList.Insert(index: Integer): TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceOperationList.InsertItem(index: Integer; value: TFhirConformanceRestResourceOperation);
begin
  assert(value is TFhirConformanceRestResourceOperation);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestResourceOperationList.Item(index: Integer): TFhirConformanceRestResourceOperation;
begin
  result := TFhirConformanceRestResourceOperation(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceOperationList.Link: TFhirConformanceRestResourceOperationList;
begin
  result := TFhirConformanceRestResourceOperationList(inherited Link);
end;

procedure TFhirConformanceRestResourceOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestResourceOperationList.SetItemByIndex(index: Integer; value: TFhirConformanceRestResourceOperation);
begin
  assert(value is TFhirConformanceRestResourceOperation);
  FhirConformanceRestResourceOperations[index] := value;
end;

procedure TFhirConformanceRestResourceOperationList.SetItemN(index: Integer; value: TFhirConformanceRestResourceOperation);
begin
  assert(value is TFhirConformanceRestResourceOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestResourceSearchParam }

constructor TFhirConformanceRestResourceSearchParam.Create;
begin
  inherited;
  FTargetList := TFhirCodeList.Create;
  FChainList := TFhirStringList.Create;
end;

destructor TFhirConformanceRestResourceSearchParam.Destroy;
begin
  FName.free;
  FDefinition.free;
  FType_.free;
  FDocumentation.free;
  FTargetList.Free;
  FChainList.Free;
  inherited;
end;

procedure TFhirConformanceRestResourceSearchParam.Assign(oSource : TAdvObject);
begin
  inherited;
  nameObject := TFhirConformanceRestResourceSearchParam(oSource).nameObject.Clone;
  definitionObject := TFhirConformanceRestResourceSearchParam(oSource).definitionObject.Clone;
  FType_ := TFhirConformanceRestResourceSearchParam(oSource).FType_.Link;
  documentationObject := TFhirConformanceRestResourceSearchParam(oSource).documentationObject.Clone;
  FTargetList.Assign(TFhirConformanceRestResourceSearchParam(oSource).FTargetList);
  FChainList.Assign(TFhirConformanceRestResourceSearchParam(oSource).FChainList);
end;

procedure TFhirConformanceRestResourceSearchParam.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'definition') Then
     list.add(FDefinition.Link);
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'documentation') Then
     list.add(FDocumentation.Link);
  if (child_name = 'target') Then
     list.addAll(FTargetList);
  if (child_name = 'chain') Then
     list.addAll(FChainList);
end;

procedure TFhirConformanceRestResourceSearchParam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'uri', FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'code', FTargetList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'chain', 'string', FChainList.Link)){3};
end;

procedure TFhirConformanceRestResourceSearchParam.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'definition') then DefinitionObject := propValue as TFhirUri{5a}
  else if (propName = 'type') then Type_Object := propValue as TFHIREnum
  else if (propName = 'documentation') then DocumentationObject := propValue as TFhirString{5a}
  else if (propName = 'target') then TargetList.add(propValue as TFhirCode){2}
  else if (propName = 'chain') then ChainList.add(propValue as TFhirString){2}
  else inherited;
end;

function TFhirConformanceRestResourceSearchParam.FhirType : string;
begin
  result := 'searchParam';
end;

function TFhirConformanceRestResourceSearchParam.Link : TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(inherited Link);
end;

function TFhirConformanceRestResourceSearchParam.Clone : TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(inherited Clone);
end;

{ TFhirConformanceRestResourceSearchParam }

Procedure TFhirConformanceRestResourceSearchParam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirConformanceRestResourceSearchParam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirConformanceRestResourceSearchParam.SetDefinition(value : TFhirUri);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

Procedure TFhirConformanceRestResourceSearchParam.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirUri.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

Procedure TFhirConformanceRestResourceSearchParam.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetType_ST : TFhirSearchParamType;
begin
  if FType_ = nil then
    result := TFhirSearchParamType(0)
  else
    result := TFhirSearchParamType(StringArrayIndexOfSensitive(CODES_TFhirSearchParamType, FType_.value));
end;

Procedure TFhirConformanceRestResourceSearchParam.SetType_ST(value : TFhirSearchParamType);
begin
  if ord(value) = 0 then
    Type_Object := nil
  else
    Type_Object := TFhirEnum.create(CODES_TFhirSearchParamType[value]);
end;

Procedure TFhirConformanceRestResourceSearchParam.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceRestResourceSearchParam.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceRestResourceSearchParamListEnumerator }

Constructor TFhirConformanceRestResourceSearchParamListEnumerator.Create(list : TFhirConformanceRestResourceSearchParamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConformanceRestResourceSearchParamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestResourceSearchParamListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConformanceRestResourceSearchParamListEnumerator.GetCurrent : TFhirConformanceRestResourceSearchParam;
begin
  Result := FList[FIndex];
end;


{ TFhirConformanceRestResourceSearchParamList }
procedure TFhirConformanceRestResourceSearchParamList.AddItem(value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value.ClassName = 'TFhirConformanceRestResourceSearchParam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestResourceSearchParam');
  add(value);
end;


function TFhirConformanceRestResourceSearchParamList.Append: TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceSearchParamList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestResourceSearchParamList.GetEnumerator : TFhirConformanceRestResourceSearchParamListEnumerator;
begin
  result := TFhirConformanceRestResourceSearchParamListEnumerator.Create(self.link);
end;

function TFhirConformanceRestResourceSearchParamList.Clone: TFhirConformanceRestResourceSearchParamList;
begin
  result := TFhirConformanceRestResourceSearchParamList(inherited Clone);
end;

function TFhirConformanceRestResourceSearchParamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestResourceSearchParamList.GetItemN(index: Integer): TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceSearchParamList.IndexOf(value: TFhirConformanceRestResourceSearchParam): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestResourceSearchParamList.Insert(index: Integer): TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestResourceSearchParamList.InsertItem(index: Integer; value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value is TFhirConformanceRestResourceSearchParam);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestResourceSearchParamList.Item(index: Integer): TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceSearchParamList.Link: TFhirConformanceRestResourceSearchParamList;
begin
  result := TFhirConformanceRestResourceSearchParamList(inherited Link);
end;

procedure TFhirConformanceRestResourceSearchParamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestResourceSearchParamList.SetItemByIndex(index: Integer; value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value is TFhirConformanceRestResourceSearchParam);
  FhirConformanceRestResourceSearchParams[index] := value;
end;

procedure TFhirConformanceRestResourceSearchParamList.SetItemN(index: Integer; value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value is TFhirConformanceRestResourceSearchParam);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestOperation }

constructor TFhirConformanceRestOperation.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestOperation.Destroy;
begin
  FCode.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirConformanceRestOperation.Assign(oSource : TAdvObject);
begin
  inherited;
  FCode := TFhirConformanceRestOperation(oSource).FCode.Link;
  documentationObject := TFhirConformanceRestOperation(oSource).documentationObject.Clone;
end;

procedure TFhirConformanceRestOperation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'documentation') Then
     list.add(FDocumentation.Link);
end;

procedure TFhirConformanceRestOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link));{2}
end;

procedure TFhirConformanceRestOperation.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then CodeObject := propValue as TFHIREnum
  else if (propName = 'documentation') then DocumentationObject := propValue as TFhirString{5a}
  else inherited;
end;

function TFhirConformanceRestOperation.FhirType : string;
begin
  result := 'operation';
end;

function TFhirConformanceRestOperation.Link : TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation(inherited Link);
end;

function TFhirConformanceRestOperation.Clone : TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation(inherited Clone);
end;

{ TFhirConformanceRestOperation }

Procedure TFhirConformanceRestOperation.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConformanceRestOperation.GetCodeST : TFhirSystemRestfulOperation;
begin
  if FCode = nil then
    result := TFhirSystemRestfulOperation(0)
  else
    result := TFhirSystemRestfulOperation(StringArrayIndexOfSensitive(CODES_TFhirSystemRestfulOperation, FCode.value));
end;

Procedure TFhirConformanceRestOperation.SetCodeST(value : TFhirSystemRestfulOperation);
begin
  if ord(value) = 0 then
    CodeObject := nil
  else
    CodeObject := TFhirEnum.create(CODES_TFhirSystemRestfulOperation[value]);
end;

Procedure TFhirConformanceRestOperation.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRestOperation.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceRestOperation.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceRestOperationListEnumerator }

Constructor TFhirConformanceRestOperationListEnumerator.Create(list : TFhirConformanceRestOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConformanceRestOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestOperationListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConformanceRestOperationListEnumerator.GetCurrent : TFhirConformanceRestOperation;
begin
  Result := FList[FIndex];
end;


{ TFhirConformanceRestOperationList }
procedure TFhirConformanceRestOperationList.AddItem(value: TFhirConformanceRestOperation);
begin
  assert(value.ClassName = 'TFhirConformanceRestOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestOperation');
  add(value);
end;


function TFhirConformanceRestOperationList.Append: TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestOperationList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestOperationList.GetEnumerator : TFhirConformanceRestOperationListEnumerator;
begin
  result := TFhirConformanceRestOperationListEnumerator.Create(self.link);
end;

function TFhirConformanceRestOperationList.Clone: TFhirConformanceRestOperationList;
begin
  result := TFhirConformanceRestOperationList(inherited Clone);
end;

function TFhirConformanceRestOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestOperationList.GetItemN(index: Integer): TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation(ObjectByIndex[index]);
end;

function TFhirConformanceRestOperationList.IndexOf(value: TFhirConformanceRestOperation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestOperationList.Insert(index: Integer): TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestOperationList.InsertItem(index: Integer; value: TFhirConformanceRestOperation);
begin
  assert(value is TFhirConformanceRestOperation);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestOperationList.Item(index: Integer): TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation(ObjectByIndex[index]);
end;

function TFhirConformanceRestOperationList.Link: TFhirConformanceRestOperationList;
begin
  result := TFhirConformanceRestOperationList(inherited Link);
end;

procedure TFhirConformanceRestOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestOperationList.SetItemByIndex(index: Integer; value: TFhirConformanceRestOperation);
begin
  assert(value is TFhirConformanceRestOperation);
  FhirConformanceRestOperations[index] := value;
end;

procedure TFhirConformanceRestOperationList.SetItemN(index: Integer; value: TFhirConformanceRestOperation);
begin
  assert(value is TFhirConformanceRestOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestQuery }

constructor TFhirConformanceRestQuery.Create;
begin
  inherited;
  FParameterList := TFhirConformanceRestResourceSearchParamList.Create;
end;

destructor TFhirConformanceRestQuery.Destroy;
begin
  FName.free;
  FDefinition.free;
  FDocumentation.free;
  FParameterList.Free;
  inherited;
end;

procedure TFhirConformanceRestQuery.Assign(oSource : TAdvObject);
begin
  inherited;
  nameObject := TFhirConformanceRestQuery(oSource).nameObject.Clone;
  definitionObject := TFhirConformanceRestQuery(oSource).definitionObject.Clone;
  documentationObject := TFhirConformanceRestQuery(oSource).documentationObject.Clone;
  FParameterList.Assign(TFhirConformanceRestQuery(oSource).FParameterList);
end;

procedure TFhirConformanceRestQuery.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'definition') Then
     list.add(FDefinition.Link);
  if (child_name = 'documentation') Then
     list.add(FDocumentation.Link);
  if (child_name = 'parameter') Then
     list.addAll(FParameterList);
end;

procedure TFhirConformanceRestQuery.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'uri', FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', '@Conformance.rest.resource.searchParam', FParameterList.Link)){3};
end;

procedure TFhirConformanceRestQuery.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'definition') then DefinitionObject := propValue as TFhirUri{5a}
  else if (propName = 'documentation') then DocumentationObject := propValue as TFhirString{5a}
  else if (propName = 'parameter') then ParameterList.add(propValue as TFhirConformanceRestResourceSearchParam){2}
  else inherited;
end;

function TFhirConformanceRestQuery.FhirType : string;
begin
  result := 'query';
end;

function TFhirConformanceRestQuery.Link : TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery(inherited Link);
end;

function TFhirConformanceRestQuery.Clone : TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery(inherited Clone);
end;

{ TFhirConformanceRestQuery }

Procedure TFhirConformanceRestQuery.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConformanceRestQuery.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirConformanceRestQuery.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirConformanceRestQuery.SetDefinition(value : TFhirUri);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirConformanceRestQuery.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

Procedure TFhirConformanceRestQuery.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirUri.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

Procedure TFhirConformanceRestQuery.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRestQuery.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceRestQuery.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceRestQueryListEnumerator }

Constructor TFhirConformanceRestQueryListEnumerator.Create(list : TFhirConformanceRestQueryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConformanceRestQueryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestQueryListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConformanceRestQueryListEnumerator.GetCurrent : TFhirConformanceRestQuery;
begin
  Result := FList[FIndex];
end;


{ TFhirConformanceRestQueryList }
procedure TFhirConformanceRestQueryList.AddItem(value: TFhirConformanceRestQuery);
begin
  assert(value.ClassName = 'TFhirConformanceRestQuery', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestQuery');
  add(value);
end;


function TFhirConformanceRestQueryList.Append: TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestQueryList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestQueryList.GetEnumerator : TFhirConformanceRestQueryListEnumerator;
begin
  result := TFhirConformanceRestQueryListEnumerator.Create(self.link);
end;

function TFhirConformanceRestQueryList.Clone: TFhirConformanceRestQueryList;
begin
  result := TFhirConformanceRestQueryList(inherited Clone);
end;

function TFhirConformanceRestQueryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestQueryList.GetItemN(index: Integer): TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery(ObjectByIndex[index]);
end;

function TFhirConformanceRestQueryList.IndexOf(value: TFhirConformanceRestQuery): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceRestQueryList.Insert(index: Integer): TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceRestQueryList.InsertItem(index: Integer; value: TFhirConformanceRestQuery);
begin
  assert(value is TFhirConformanceRestQuery);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestQueryList.Item(index: Integer): TFhirConformanceRestQuery;
begin
  result := TFhirConformanceRestQuery(ObjectByIndex[index]);
end;

function TFhirConformanceRestQueryList.Link: TFhirConformanceRestQueryList;
begin
  result := TFhirConformanceRestQueryList(inherited Link);
end;

procedure TFhirConformanceRestQueryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestQueryList.SetItemByIndex(index: Integer; value: TFhirConformanceRestQuery);
begin
  assert(value is TFhirConformanceRestQuery);
  FhirConformanceRestQueries[index] := value;
end;

procedure TFhirConformanceRestQueryList.SetItemN(index: Integer; value: TFhirConformanceRestQuery);
begin
  assert(value is TFhirConformanceRestQuery);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceMessaging }

constructor TFhirConformanceMessaging.Create;
begin
  inherited;
  FEventList := TFhirConformanceMessagingEventList.Create;
end;

destructor TFhirConformanceMessaging.Destroy;
begin
  FEndpoint.free;
  FReliableCache.free;
  FDocumentation.free;
  FEventList.Free;
  inherited;
end;

procedure TFhirConformanceMessaging.Assign(oSource : TAdvObject);
begin
  inherited;
  endpointObject := TFhirConformanceMessaging(oSource).endpointObject.Clone;
  reliableCacheObject := TFhirConformanceMessaging(oSource).reliableCacheObject.Clone;
  documentationObject := TFhirConformanceMessaging(oSource).documentationObject.Clone;
  FEventList.Assign(TFhirConformanceMessaging(oSource).FEventList);
end;

procedure TFhirConformanceMessaging.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'endpoint') Then
     list.add(FEndpoint.Link);
  if (child_name = 'reliableCache') Then
     list.add(FReliableCache.Link);
  if (child_name = 'documentation') Then
     list.add(FDocumentation.Link);
  if (child_name = 'event') Then
     list.addAll(FEventList);
end;

procedure TFhirConformanceMessaging.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', FEndpoint.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reliableCache', 'integer', FReliableCache.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'event', '', FEventList.Link)){3};
end;

procedure TFhirConformanceMessaging.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'endpoint') then EndpointObject := propValue as TFhirUri{5a}
  else if (propName = 'reliableCache') then ReliableCacheObject := propValue as TFhirInteger{5a}
  else if (propName = 'documentation') then DocumentationObject := propValue as TFhirString{5a}
  else if (propName = 'event') then EventList.add(propValue as TFhirConformanceMessagingEvent){2}
  else inherited;
end;

function TFhirConformanceMessaging.FhirType : string;
begin
  result := 'messaging';
end;

function TFhirConformanceMessaging.Link : TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(inherited Link);
end;

function TFhirConformanceMessaging.Clone : TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(inherited Clone);
end;

{ TFhirConformanceMessaging }

Procedure TFhirConformanceMessaging.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirConformanceMessaging.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

Procedure TFhirConformanceMessaging.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

Procedure TFhirConformanceMessaging.SetReliableCache(value : TFhirInteger);
begin
  FReliableCache.free;
  FReliableCache := value;
end;

Function TFhirConformanceMessaging.GetReliableCacheST : String;
begin
  if FReliableCache = nil then
    result := ''
  else
    result := FReliableCache.value;
end;

Procedure TFhirConformanceMessaging.SetReliableCacheST(value : String);
begin
  if value <> '' then
  begin
    if FReliableCache = nil then
      FReliableCache := TFhirInteger.create;
    FReliableCache.value := value
  end
  else if FReliableCache <> nil then
    FReliableCache.value := '';
end;

Procedure TFhirConformanceMessaging.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceMessaging.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceMessaging.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceMessagingListEnumerator }

Constructor TFhirConformanceMessagingListEnumerator.Create(list : TFhirConformanceMessagingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConformanceMessagingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceMessagingListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConformanceMessagingListEnumerator.GetCurrent : TFhirConformanceMessaging;
begin
  Result := FList[FIndex];
end;


{ TFhirConformanceMessagingList }
procedure TFhirConformanceMessagingList.AddItem(value: TFhirConformanceMessaging);
begin
  assert(value.ClassName = 'TFhirConformanceMessaging', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceMessaging');
  add(value);
end;


function TFhirConformanceMessagingList.Append: TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceMessagingList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceMessagingList.GetEnumerator : TFhirConformanceMessagingListEnumerator;
begin
  result := TFhirConformanceMessagingListEnumerator.Create(self.link);
end;

function TFhirConformanceMessagingList.Clone: TFhirConformanceMessagingList;
begin
  result := TFhirConformanceMessagingList(inherited Clone);
end;

function TFhirConformanceMessagingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceMessagingList.GetItemN(index: Integer): TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingList.IndexOf(value: TFhirConformanceMessaging): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceMessagingList.Insert(index: Integer): TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceMessagingList.InsertItem(index: Integer; value: TFhirConformanceMessaging);
begin
  assert(value is TFhirConformanceMessaging);
  Inherited Insert(index, value);
end;

function TFhirConformanceMessagingList.Item(index: Integer): TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingList.Link: TFhirConformanceMessagingList;
begin
  result := TFhirConformanceMessagingList(inherited Link);
end;

procedure TFhirConformanceMessagingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceMessagingList.SetItemByIndex(index: Integer; value: TFhirConformanceMessaging);
begin
  assert(value is TFhirConformanceMessaging);
  FhirConformanceMessagings[index] := value;
end;

procedure TFhirConformanceMessagingList.SetItemN(index: Integer; value: TFhirConformanceMessaging);
begin
  assert(value is TFhirConformanceMessaging);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceMessagingEvent }

constructor TFhirConformanceMessagingEvent.Create;
begin
  inherited;
  FProtocolList := TFhirCodingList.Create;
end;

destructor TFhirConformanceMessagingEvent.Destroy;
begin
  FCode.free;
  FCategory.free;
  FMode.free;
  FProtocolList.Free;
  FFocus.free;
  FRequest.free;
  FResponse.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirConformanceMessagingEvent.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirConformanceMessagingEvent(oSource).code.Clone;
  FCategory := TFhirConformanceMessagingEvent(oSource).FCategory.Link;
  FMode := TFhirConformanceMessagingEvent(oSource).FMode.Link;
  FProtocolList.Assign(TFhirConformanceMessagingEvent(oSource).FProtocolList);
  focusObject := TFhirConformanceMessagingEvent(oSource).focusObject.Clone;
  request := TFhirConformanceMessagingEvent(oSource).request.Clone;
  response := TFhirConformanceMessagingEvent(oSource).response.Clone;
  documentationObject := TFhirConformanceMessagingEvent(oSource).documentationObject.Clone;
end;

procedure TFhirConformanceMessagingEvent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'category') Then
     list.add(FCategory.Link);
  if (child_name = 'mode') Then
     list.add(FMode.Link);
  if (child_name = 'protocol') Then
     list.addAll(FProtocolList);
  if (child_name = 'focus') Then
     list.add(FFocus.Link);
  if (child_name = 'request') Then
     list.add(FRequest.Link);
  if (child_name = 'response') Then
     list.add(FResponse.Link);
  if (child_name = 'documentation') Then
     list.add(FDocumentation.Link);
end;

procedure TFhirConformanceMessagingEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'code', FCategory.Link));{1}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'protocol', 'Coding', FProtocolList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'focus', 'code', FFocus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Resource(Profile)', FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', 'Resource(Profile)', FResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link));{2}
end;

procedure TFhirConformanceMessagingEvent.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then Code := propValue as TFhirCoding{4b}
  else if (propName = 'category') then CategoryObject := propValue as TFHIREnum
  else if (propName = 'mode') then ModeObject := propValue as TFHIREnum
  else if (propName = 'protocol') then ProtocolList.add(propValue as TFhirCoding){2}
  else if (propName = 'focus') then
    if propValue is TFHIRCode then
      FocusObject := propValue as TFhirCode{5}
    else if propValue is TFHIREnum then
      FocusObject := TFHIRCode.create(TFHIREnum(propValue).value)
    else
      raise Exception.Create('Type mismatch: cannot convert from "'+propValue.className+'" to "TFHIRCode"'){5a}
  else if (propName = 'request') then Request := propValue as TFhirResourceReference{TFhirProfile}{4b}
  else if (propName = 'response') then Response := propValue as TFhirResourceReference{TFhirProfile}{4b}
  else if (propName = 'documentation') then DocumentationObject := propValue as TFhirString{5a}
  else inherited;
end;

function TFhirConformanceMessagingEvent.FhirType : string;
begin
  result := 'event';
end;

function TFhirConformanceMessagingEvent.Link : TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(inherited Link);
end;

function TFhirConformanceMessagingEvent.Clone : TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(inherited Clone);
end;

{ TFhirConformanceMessagingEvent }

Procedure TFhirConformanceMessagingEvent.SetCode(value : TFhirCoding);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirConformanceMessagingEvent.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

Function TFhirConformanceMessagingEvent.GetCategoryST : TFhirMessageSignificanceCategory;
begin
  if FCategory = nil then
    result := TFhirMessageSignificanceCategory(0)
  else
    result := TFhirMessageSignificanceCategory(StringArrayIndexOfSensitive(CODES_TFhirMessageSignificanceCategory, FCategory.value));
end;

Procedure TFhirConformanceMessagingEvent.SetCategoryST(value : TFhirMessageSignificanceCategory);
begin
  if ord(value) = 0 then
    CategoryObject := nil
  else
    CategoryObject := TFhirEnum.create(CODES_TFhirMessageSignificanceCategory[value]);
end;

Procedure TFhirConformanceMessagingEvent.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirConformanceMessagingEvent.GetModeST : TFhirMessageConformanceEventMode;
begin
  if FMode = nil then
    result := TFhirMessageConformanceEventMode(0)
  else
    result := TFhirMessageConformanceEventMode(StringArrayIndexOfSensitive(CODES_TFhirMessageConformanceEventMode, FMode.value));
end;

Procedure TFhirConformanceMessagingEvent.SetModeST(value : TFhirMessageConformanceEventMode);
begin
  if ord(value) = 0 then
    ModeObject := nil
  else
    ModeObject := TFhirEnum.create(CODES_TFhirMessageConformanceEventMode[value]);
end;

Procedure TFhirConformanceMessagingEvent.SetFocus(value : TFhirCode);
begin
  FFocus.free;
  FFocus := value;
end;

Function TFhirConformanceMessagingEvent.GetFocusST : String;
begin
  if FFocus = nil then
    result := ''
  else
    result := FFocus.value;
end;

Procedure TFhirConformanceMessagingEvent.SetFocusST(value : String);
begin
  if value <> '' then
  begin
    if FFocus = nil then
      FFocus := TFhirCode.create;
    FFocus.value := value
  end
  else if FFocus <> nil then
    FFocus.value := '';
end;

Procedure TFhirConformanceMessagingEvent.SetRequest(value : TFhirResourceReference{TFhirProfile});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirConformanceMessagingEvent.SetResponse(value : TFhirResourceReference{TFhirProfile});
begin
  FResponse.free;
  FResponse := value;
end;

Procedure TFhirConformanceMessagingEvent.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceMessagingEvent.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceMessagingEvent.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirConformanceMessagingEventListEnumerator }

Constructor TFhirConformanceMessagingEventListEnumerator.Create(list : TFhirConformanceMessagingEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConformanceMessagingEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceMessagingEventListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConformanceMessagingEventListEnumerator.GetCurrent : TFhirConformanceMessagingEvent;
begin
  Result := FList[FIndex];
end;


{ TFhirConformanceMessagingEventList }
procedure TFhirConformanceMessagingEventList.AddItem(value: TFhirConformanceMessagingEvent);
begin
  assert(value.ClassName = 'TFhirConformanceMessagingEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceMessagingEvent');
  add(value);
end;


function TFhirConformanceMessagingEventList.Append: TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceMessagingEventList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceMessagingEventList.GetEnumerator : TFhirConformanceMessagingEventListEnumerator;
begin
  result := TFhirConformanceMessagingEventListEnumerator.Create(self.link);
end;

function TFhirConformanceMessagingEventList.Clone: TFhirConformanceMessagingEventList;
begin
  result := TFhirConformanceMessagingEventList(inherited Clone);
end;

function TFhirConformanceMessagingEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceMessagingEventList.GetItemN(index: Integer): TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingEventList.IndexOf(value: TFhirConformanceMessagingEvent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceMessagingEventList.Insert(index: Integer): TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceMessagingEventList.InsertItem(index: Integer; value: TFhirConformanceMessagingEvent);
begin
  assert(value is TFhirConformanceMessagingEvent);
  Inherited Insert(index, value);
end;

function TFhirConformanceMessagingEventList.Item(index: Integer): TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingEventList.Link: TFhirConformanceMessagingEventList;
begin
  result := TFhirConformanceMessagingEventList(inherited Link);
end;

procedure TFhirConformanceMessagingEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceMessagingEventList.SetItemByIndex(index: Integer; value: TFhirConformanceMessagingEvent);
begin
  assert(value is TFhirConformanceMessagingEvent);
  FhirConformanceMessagingEvents[index] := value;
end;

procedure TFhirConformanceMessagingEventList.SetItemN(index: Integer; value: TFhirConformanceMessagingEvent);
begin
  assert(value is TFhirConformanceMessagingEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceDocument }

constructor TFhirConformanceDocument.Create;
begin
  inherited;
end;

destructor TFhirConformanceDocument.Destroy;
begin
  FMode.free;
  FDocumentation.free;
  FProfile.free;
  inherited;
end;

procedure TFhirConformanceDocument.Assign(oSource : TAdvObject);
begin
  inherited;
  FMode := TFhirConformanceDocument(oSource).FMode.Link;
  documentationObject := TFhirConformanceDocument(oSource).documentationObject.Clone;
  profile := TFhirConformanceDocument(oSource).profile.Clone;
end;

procedure TFhirConformanceDocument.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(FMode.Link);
  if (child_name = 'documentation') Then
     list.add(FDocumentation.Link);
  if (child_name = 'profile') Then
     list.add(FProfile.Link);
end;

procedure TFhirConformanceDocument.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'Resource(Profile)', FProfile.Link));{2}
end;

procedure TFhirConformanceDocument.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'mode') then ModeObject := propValue as TFHIREnum
  else if (propName = 'documentation') then DocumentationObject := propValue as TFhirString{5a}
  else if (propName = 'profile') then Profile := propValue as TFhirResourceReference{TFhirProfile}{4b}
  else inherited;
end;

function TFhirConformanceDocument.FhirType : string;
begin
  result := 'document';
end;

function TFhirConformanceDocument.Link : TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(inherited Link);
end;

function TFhirConformanceDocument.Clone : TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(inherited Clone);
end;

{ TFhirConformanceDocument }

Procedure TFhirConformanceDocument.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirConformanceDocument.GetModeST : TFhirDocumentMode;
begin
  if FMode = nil then
    result := TFhirDocumentMode(0)
  else
    result := TFhirDocumentMode(StringArrayIndexOfSensitive(CODES_TFhirDocumentMode, FMode.value));
end;

Procedure TFhirConformanceDocument.SetModeST(value : TFhirDocumentMode);
begin
  if ord(value) = 0 then
    ModeObject := nil
  else
    ModeObject := TFhirEnum.create(CODES_TFhirDocumentMode[value]);
end;

Procedure TFhirConformanceDocument.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceDocument.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceDocument.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirConformanceDocument.SetProfile(value : TFhirResourceReference{TFhirProfile});
begin
  FProfile.free;
  FProfile := value;
end;


{ TFhirConformanceDocumentListEnumerator }

Constructor TFhirConformanceDocumentListEnumerator.Create(list : TFhirConformanceDocumentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirConformanceDocumentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceDocumentListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirConformanceDocumentListEnumerator.GetCurrent : TFhirConformanceDocument;
begin
  Result := FList[FIndex];
end;


{ TFhirConformanceDocumentList }
procedure TFhirConformanceDocumentList.AddItem(value: TFhirConformanceDocument);
begin
  assert(value.ClassName = 'TFhirConformanceDocument', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceDocument');
  add(value);
end;


function TFhirConformanceDocumentList.Append: TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceDocumentList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceDocumentList.GetEnumerator : TFhirConformanceDocumentListEnumerator;
begin
  result := TFhirConformanceDocumentListEnumerator.Create(self.link);
end;

function TFhirConformanceDocumentList.Clone: TFhirConformanceDocumentList;
begin
  result := TFhirConformanceDocumentList(inherited Clone);
end;

function TFhirConformanceDocumentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceDocumentList.GetItemN(index: Integer): TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(ObjectByIndex[index]);
end;

function TFhirConformanceDocumentList.IndexOf(value: TFhirConformanceDocument): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirConformanceDocumentList.Insert(index: Integer): TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirConformanceDocumentList.InsertItem(index: Integer; value: TFhirConformanceDocument);
begin
  assert(value is TFhirConformanceDocument);
  Inherited Insert(index, value);
end;

function TFhirConformanceDocumentList.Item(index: Integer): TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(ObjectByIndex[index]);
end;

function TFhirConformanceDocumentList.Link: TFhirConformanceDocumentList;
begin
  result := TFhirConformanceDocumentList(inherited Link);
end;

procedure TFhirConformanceDocumentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceDocumentList.SetItemByIndex(index: Integer; value: TFhirConformanceDocument);
begin
  assert(value is TFhirConformanceDocument);
  FhirConformanceDocuments[index] := value;
end;

procedure TFhirConformanceDocumentList.SetItemN(index: Integer; value: TFhirConformanceDocument);
begin
  assert(value is TFhirConformanceDocument);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceObservationReportVirtualDevice }

constructor TFhirDeviceObservationReportVirtualDevice.Create;
begin
  inherited;
  FChannelList := TFhirDeviceObservationReportVirtualDeviceChannelList.Create;
end;

destructor TFhirDeviceObservationReportVirtualDevice.Destroy;
begin
  FCode.free;
  FChannelList.Free;
  inherited;
end;

procedure TFhirDeviceObservationReportVirtualDevice.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirDeviceObservationReportVirtualDevice(oSource).code.Clone;
  FChannelList.Assign(TFhirDeviceObservationReportVirtualDevice(oSource).FChannelList);
end;

procedure TFhirDeviceObservationReportVirtualDevice.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'channel') Then
     list.addAll(FChannelList);
end;

procedure TFhirDeviceObservationReportVirtualDevice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'channel', '', FChannelList.Link)){3};
end;

procedure TFhirDeviceObservationReportVirtualDevice.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then Code := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'channel') then ChannelList.add(propValue as TFhirDeviceObservationReportVirtualDeviceChannel){2}
  else inherited;
end;

function TFhirDeviceObservationReportVirtualDevice.FhirType : string;
begin
  result := 'virtualDevice';
end;

function TFhirDeviceObservationReportVirtualDevice.Link : TFhirDeviceObservationReportVirtualDevice;
begin
  result := TFhirDeviceObservationReportVirtualDevice(inherited Link);
end;

function TFhirDeviceObservationReportVirtualDevice.Clone : TFhirDeviceObservationReportVirtualDevice;
begin
  result := TFhirDeviceObservationReportVirtualDevice(inherited Clone);
end;

{ TFhirDeviceObservationReportVirtualDevice }

Procedure TFhirDeviceObservationReportVirtualDevice.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;


{ TFhirDeviceObservationReportVirtualDeviceListEnumerator }

Constructor TFhirDeviceObservationReportVirtualDeviceListEnumerator.Create(list : TFhirDeviceObservationReportVirtualDeviceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirDeviceObservationReportVirtualDeviceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceObservationReportVirtualDeviceListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirDeviceObservationReportVirtualDeviceListEnumerator.GetCurrent : TFhirDeviceObservationReportVirtualDevice;
begin
  Result := FList[FIndex];
end;


{ TFhirDeviceObservationReportVirtualDeviceList }
procedure TFhirDeviceObservationReportVirtualDeviceList.AddItem(value: TFhirDeviceObservationReportVirtualDevice);
begin
  assert(value.ClassName = 'TFhirDeviceObservationReportVirtualDevice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceObservationReportVirtualDevice');
  add(value);
end;


function TFhirDeviceObservationReportVirtualDeviceList.Append: TFhirDeviceObservationReportVirtualDevice;
begin
  result := TFhirDeviceObservationReportVirtualDevice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceObservationReportVirtualDeviceList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceObservationReportVirtualDeviceList.GetEnumerator : TFhirDeviceObservationReportVirtualDeviceListEnumerator;
begin
  result := TFhirDeviceObservationReportVirtualDeviceListEnumerator.Create(self.link);
end;

function TFhirDeviceObservationReportVirtualDeviceList.Clone: TFhirDeviceObservationReportVirtualDeviceList;
begin
  result := TFhirDeviceObservationReportVirtualDeviceList(inherited Clone);
end;

function TFhirDeviceObservationReportVirtualDeviceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceObservationReportVirtualDeviceList.GetItemN(index: Integer): TFhirDeviceObservationReportVirtualDevice;
begin
  result := TFhirDeviceObservationReportVirtualDevice(ObjectByIndex[index]);
end;

function TFhirDeviceObservationReportVirtualDeviceList.IndexOf(value: TFhirDeviceObservationReportVirtualDevice): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDeviceObservationReportVirtualDeviceList.Insert(index: Integer): TFhirDeviceObservationReportVirtualDevice;
begin
  result := TFhirDeviceObservationReportVirtualDevice.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceObservationReportVirtualDeviceList.InsertItem(index: Integer; value: TFhirDeviceObservationReportVirtualDevice);
begin
  assert(value is TFhirDeviceObservationReportVirtualDevice);
  Inherited Insert(index, value);
end;

function TFhirDeviceObservationReportVirtualDeviceList.Item(index: Integer): TFhirDeviceObservationReportVirtualDevice;
begin
  result := TFhirDeviceObservationReportVirtualDevice(ObjectByIndex[index]);
end;

function TFhirDeviceObservationReportVirtualDeviceList.Link: TFhirDeviceObservationReportVirtualDeviceList;
begin
  result := TFhirDeviceObservationReportVirtualDeviceList(inherited Link);
end;

procedure TFhirDeviceObservationReportVirtualDeviceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceObservationReportVirtualDeviceList.SetItemByIndex(index: Integer; value: TFhirDeviceObservationReportVirtualDevice);
begin
  assert(value is TFhirDeviceObservationReportVirtualDevice);
  FhirDeviceObservationReportVirtualDevices[index] := value;
end;

procedure TFhirDeviceObservationReportVirtualDeviceList.SetItemN(index: Integer; value: TFhirDeviceObservationReportVirtualDevice);
begin
  assert(value is TFhirDeviceObservationReportVirtualDevice);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceObservationReportVirtualDeviceChannel }

constructor TFhirDeviceObservationReportVirtualDeviceChannel.Create;
begin
  inherited;
  FMetricList := TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Create;
end;

destructor TFhirDeviceObservationReportVirtualDeviceChannel.Destroy;
begin
  FCode.free;
  FMetricList.Free;
  inherited;
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannel.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirDeviceObservationReportVirtualDeviceChannel(oSource).code.Clone;
  FMetricList.Assign(TFhirDeviceObservationReportVirtualDeviceChannel(oSource).FMetricList);
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannel.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'metric') Then
     list.addAll(FMetricList);
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannel.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'metric', '', FMetricList.Link)){3};
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannel.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then Code := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'metric') then MetricList.add(propValue as TFhirDeviceObservationReportVirtualDeviceChannelMetric){2}
  else inherited;
end;

function TFhirDeviceObservationReportVirtualDeviceChannel.FhirType : string;
begin
  result := 'channel';
end;

function TFhirDeviceObservationReportVirtualDeviceChannel.Link : TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel(inherited Link);
end;

function TFhirDeviceObservationReportVirtualDeviceChannel.Clone : TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel(inherited Clone);
end;

{ TFhirDeviceObservationReportVirtualDeviceChannel }

Procedure TFhirDeviceObservationReportVirtualDeviceChannel.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;


{ TFhirDeviceObservationReportVirtualDeviceChannelListEnumerator }

Constructor TFhirDeviceObservationReportVirtualDeviceChannelListEnumerator.Create(list : TFhirDeviceObservationReportVirtualDeviceChannelList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirDeviceObservationReportVirtualDeviceChannelListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceObservationReportVirtualDeviceChannelListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelListEnumerator.GetCurrent : TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  Result := FList[FIndex];
end;


{ TFhirDeviceObservationReportVirtualDeviceChannelList }
procedure TFhirDeviceObservationReportVirtualDeviceChannelList.AddItem(value: TFhirDeviceObservationReportVirtualDeviceChannel);
begin
  assert(value.ClassName = 'TFhirDeviceObservationReportVirtualDeviceChannel', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceObservationReportVirtualDeviceChannel');
  add(value);
end;


function TFhirDeviceObservationReportVirtualDeviceChannelList.Append: TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceObservationReportVirtualDeviceChannelList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceObservationReportVirtualDeviceChannelList.GetEnumerator : TFhirDeviceObservationReportVirtualDeviceChannelListEnumerator;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelListEnumerator.Create(self.link);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelList.Clone: TFhirDeviceObservationReportVirtualDeviceChannelList;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelList(inherited Clone);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceObservationReportVirtualDeviceChannelList.GetItemN(index: Integer): TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel(ObjectByIndex[index]);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelList.IndexOf(value: TFhirDeviceObservationReportVirtualDeviceChannel): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDeviceObservationReportVirtualDeviceChannelList.Insert(index: Integer): TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceObservationReportVirtualDeviceChannelList.InsertItem(index: Integer; value: TFhirDeviceObservationReportVirtualDeviceChannel);
begin
  assert(value is TFhirDeviceObservationReportVirtualDeviceChannel);
  Inherited Insert(index, value);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelList.Item(index: Integer): TFhirDeviceObservationReportVirtualDeviceChannel;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannel(ObjectByIndex[index]);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelList.Link: TFhirDeviceObservationReportVirtualDeviceChannelList;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelList(inherited Link);
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelList.SetItemByIndex(index: Integer; value: TFhirDeviceObservationReportVirtualDeviceChannel);
begin
  assert(value is TFhirDeviceObservationReportVirtualDeviceChannel);
  FhirDeviceObservationReportVirtualDeviceChannels[index] := value;
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelList.SetItemN(index: Integer; value: TFhirDeviceObservationReportVirtualDeviceChannel);
begin
  assert(value is TFhirDeviceObservationReportVirtualDeviceChannel);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceObservationReportVirtualDeviceChannelMetric }

constructor TFhirDeviceObservationReportVirtualDeviceChannelMetric.Create;
begin
  inherited;
end;

destructor TFhirDeviceObservationReportVirtualDeviceChannelMetric.Destroy;
begin
  FObservation.free;
  inherited;
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelMetric.Assign(oSource : TAdvObject);
begin
  inherited;
  observation := TFhirDeviceObservationReportVirtualDeviceChannelMetric(oSource).observation.Clone;
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelMetric.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'observation') Then
     list.add(FObservation.Link);
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelMetric.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'observation', 'Resource(Observation)', FObservation.Link));{2}
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelMetric.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'observation') then Observation := propValue as TFhirResourceReference{TFhirObservation}{4b}
  else inherited;
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetric.FhirType : string;
begin
  result := 'metric';
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetric.Link : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric(inherited Link);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetric.Clone : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric(inherited Clone);
end;

{ TFhirDeviceObservationReportVirtualDeviceChannelMetric }

Procedure TFhirDeviceObservationReportVirtualDeviceChannelMetric.SetObservation(value : TFhirResourceReference{TFhirObservation});
begin
  FObservation.free;
  FObservation := value;
end;


{ TFhirDeviceObservationReportVirtualDeviceChannelMetricListEnumerator }

Constructor TFhirDeviceObservationReportVirtualDeviceChannelMetricListEnumerator.Create(list : TFhirDeviceObservationReportVirtualDeviceChannelMetricList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirDeviceObservationReportVirtualDeviceChannelMetricListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricListEnumerator.GetCurrent : TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  Result := FList[FIndex];
end;


{ TFhirDeviceObservationReportVirtualDeviceChannelMetricList }
procedure TFhirDeviceObservationReportVirtualDeviceChannelMetricList.AddItem(value: TFhirDeviceObservationReportVirtualDeviceChannelMetric);
begin
  assert(value.ClassName = 'TFhirDeviceObservationReportVirtualDeviceChannelMetric', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceObservationReportVirtualDeviceChannelMetric');
  add(value);
end;


function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Append: TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceObservationReportVirtualDeviceChannelMetricList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.GetEnumerator : TFhirDeviceObservationReportVirtualDeviceChannelMetricListEnumerator;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetricListEnumerator.Create(self.link);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Clone: TFhirDeviceObservationReportVirtualDeviceChannelMetricList;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetricList(inherited Clone);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.GetItemN(index: Integer): TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric(ObjectByIndex[index]);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.IndexOf(value: TFhirDeviceObservationReportVirtualDeviceChannelMetric): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Insert(index: Integer): TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDeviceObservationReportVirtualDeviceChannelMetricList.InsertItem(index: Integer; value: TFhirDeviceObservationReportVirtualDeviceChannelMetric);
begin
  assert(value is TFhirDeviceObservationReportVirtualDeviceChannelMetric);
  Inherited Insert(index, value);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Item(index: Integer): TFhirDeviceObservationReportVirtualDeviceChannelMetric;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetric(ObjectByIndex[index]);
end;

function TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Link: TFhirDeviceObservationReportVirtualDeviceChannelMetricList;
begin
  result := TFhirDeviceObservationReportVirtualDeviceChannelMetricList(inherited Link);
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelMetricList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelMetricList.SetItemByIndex(index: Integer; value: TFhirDeviceObservationReportVirtualDeviceChannelMetric);
begin
  assert(value is TFhirDeviceObservationReportVirtualDeviceChannelMetric);
  FhirDeviceObservationReportVirtualDeviceChannelMetrics[index] := value;
end;

procedure TFhirDeviceObservationReportVirtualDeviceChannelMetricList.SetItemN(index: Integer; value: TFhirDeviceObservationReportVirtualDeviceChannelMetric);
begin
  assert(value is TFhirDeviceObservationReportVirtualDeviceChannelMetric);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticOrderEvent }

constructor TFhirDiagnosticOrderEvent.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticOrderEvent.Destroy;
begin
  FStatus.free;
  FDescription.free;
  FDateTime.free;
  FActor.free;
  inherited;
end;

procedure TFhirDiagnosticOrderEvent.Assign(oSource : TAdvObject);
begin
  inherited;
  FStatus := TFhirDiagnosticOrderEvent(oSource).FStatus.Link;
  description := TFhirDiagnosticOrderEvent(oSource).description.Clone;
  dateTimeObject := TFhirDiagnosticOrderEvent(oSource).dateTimeObject.Clone;
  actor := TFhirDiagnosticOrderEvent(oSource).actor.Clone;
end;

procedure TFhirDiagnosticOrderEvent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'description') Then
     list.add(FDescription.Link);
  if (child_name = 'dateTime') Then
     list.add(FDateTime.Link);
  if (child_name = 'actor') Then
     list.add(FActor.Link);
end;

procedure TFhirDiagnosticOrderEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'description', 'CodeableConcept', FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'dateTime', FDateTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actor', 'Resource(Practitioner|Device)', FActor.Link));{2}
end;

procedure TFhirDiagnosticOrderEvent.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'status') then StatusObject := propValue as TFHIREnum
  else if (propName = 'description') then Description := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'dateTime') then DateTimeObject := propValue as TFhirDateTime{5a}
  else if (propName = 'actor') then Actor := propValue as TFhirResourceReference{Resource}{4b}
  else inherited;
end;

function TFhirDiagnosticOrderEvent.FhirType : string;
begin
  result := 'event';
end;

function TFhirDiagnosticOrderEvent.Link : TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(inherited Link);
end;

function TFhirDiagnosticOrderEvent.Clone : TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(inherited Clone);
end;

{ TFhirDiagnosticOrderEvent }

Procedure TFhirDiagnosticOrderEvent.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDiagnosticOrderEvent.GetStatusST : TFhirDiagnosticOrderStatus;
begin
  if FStatus = nil then
    result := TFhirDiagnosticOrderStatus(0)
  else
    result := TFhirDiagnosticOrderStatus(StringArrayIndexOfSensitive(CODES_TFhirDiagnosticOrderStatus, FStatus.value));
end;

Procedure TFhirDiagnosticOrderEvent.SetStatusST(value : TFhirDiagnosticOrderStatus);
begin
  if ord(value) = 0 then
    StatusObject := nil
  else
    StatusObject := TFhirEnum.create(CODES_TFhirDiagnosticOrderStatus[value]);
end;

Procedure TFhirDiagnosticOrderEvent.SetDescription(value : TFhirCodeableConcept);
begin
  FDescription.free;
  FDescription := value;
end;

Procedure TFhirDiagnosticOrderEvent.SetDateTime(value : TFhirDateTime);
begin
  FDateTime.free;
  FDateTime := value;
end;

Function TFhirDiagnosticOrderEvent.GetDateTimeST : TDateTimeEx;
begin
  if FDateTime = nil then
    result := nil
  else
    result := FDateTime.value;
end;

Procedure TFhirDiagnosticOrderEvent.SetDateTimeST(value : TDateTimeEx);
begin
  if value <> nil then
  begin
    if FDateTime = nil then
      FDateTime := TFhirDateTime.create;
    FDateTime.value := value
  end
  else if FDateTime <> nil then
    FDateTime.value := nil;
end;

Procedure TFhirDiagnosticOrderEvent.SetActor(value : TFhirResourceReference{Resource});
begin
  FActor.free;
  FActor := value;
end;


{ TFhirDiagnosticOrderEventListEnumerator }

Constructor TFhirDiagnosticOrderEventListEnumerator.Create(list : TFhirDiagnosticOrderEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirDiagnosticOrderEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticOrderEventListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirDiagnosticOrderEventListEnumerator.GetCurrent : TFhirDiagnosticOrderEvent;
begin
  Result := FList[FIndex];
end;


{ TFhirDiagnosticOrderEventList }
procedure TFhirDiagnosticOrderEventList.AddItem(value: TFhirDiagnosticOrderEvent);
begin
  assert(value.ClassName = 'TFhirDiagnosticOrderEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticOrderEvent');
  add(value);
end;


function TFhirDiagnosticOrderEventList.Append: TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticOrderEventList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticOrderEventList.GetEnumerator : TFhirDiagnosticOrderEventListEnumerator;
begin
  result := TFhirDiagnosticOrderEventListEnumerator.Create(self.link);
end;

function TFhirDiagnosticOrderEventList.Clone: TFhirDiagnosticOrderEventList;
begin
  result := TFhirDiagnosticOrderEventList(inherited Clone);
end;

function TFhirDiagnosticOrderEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticOrderEventList.GetItemN(index: Integer): TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderEventList.IndexOf(value: TFhirDiagnosticOrderEvent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDiagnosticOrderEventList.Insert(index: Integer): TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticOrderEventList.InsertItem(index: Integer; value: TFhirDiagnosticOrderEvent);
begin
  assert(value is TFhirDiagnosticOrderEvent);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticOrderEventList.Item(index: Integer): TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderEventList.Link: TFhirDiagnosticOrderEventList;
begin
  result := TFhirDiagnosticOrderEventList(inherited Link);
end;

procedure TFhirDiagnosticOrderEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticOrderEventList.SetItemByIndex(index: Integer; value: TFhirDiagnosticOrderEvent);
begin
  assert(value is TFhirDiagnosticOrderEvent);
  FhirDiagnosticOrderEvents[index] := value;
end;

procedure TFhirDiagnosticOrderEventList.SetItemN(index: Integer; value: TFhirDiagnosticOrderEvent);
begin
  assert(value is TFhirDiagnosticOrderEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticOrderItem }

constructor TFhirDiagnosticOrderItem.Create;
begin
  inherited;
  FSpecimenList := TFhirResourceReferenceList{TFhirSpecimen}.Create;
  FEventList := TFhirDiagnosticOrderEventList.Create;
end;

destructor TFhirDiagnosticOrderItem.Destroy;
begin
  FCode.free;
  FSpecimenList.Free;
  FBodySite.free;
  FStatus.free;
  FEventList.Free;
  inherited;
end;

procedure TFhirDiagnosticOrderItem.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirDiagnosticOrderItem(oSource).code.Clone;
  FSpecimenList.Assign(TFhirDiagnosticOrderItem(oSource).FSpecimenList);
  bodySite := TFhirDiagnosticOrderItem(oSource).bodySite.Clone;
  FStatus := TFhirDiagnosticOrderItem(oSource).FStatus.Link;
  FEventList.Assign(TFhirDiagnosticOrderItem(oSource).FEventList);
end;

procedure TFhirDiagnosticOrderItem.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'specimen') Then
     list.addAll(FSpecimenList);
  if (child_name = 'bodySite') Then
     list.add(FBodySite.Link);
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'event') Then
     list.addAll(FEventList);
end;

procedure TFhirDiagnosticOrderItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specimen', 'Resource(Specimen)', FSpecimenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'event', '@DiagnosticOrder.event', FEventList.Link)){3};
end;

procedure TFhirDiagnosticOrderItem.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then Code := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'specimen') then SpecimenList.add(propValue as TFhirResourceReference{TFhirSpecimen}){2}
  else if (propName = 'bodySite') then BodySite := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'status') then StatusObject := propValue as TFHIREnum
  else if (propName = 'event') then EventList.add(propValue as TFhirDiagnosticOrderEvent){2}
  else inherited;
end;

function TFhirDiagnosticOrderItem.FhirType : string;
begin
  result := 'item';
end;

function TFhirDiagnosticOrderItem.Link : TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(inherited Link);
end;

function TFhirDiagnosticOrderItem.Clone : TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(inherited Clone);
end;

{ TFhirDiagnosticOrderItem }

Procedure TFhirDiagnosticOrderItem.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirDiagnosticOrderItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirDiagnosticOrderItem.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDiagnosticOrderItem.GetStatusST : TFhirDiagnosticOrderStatus;
begin
  if FStatus = nil then
    result := TFhirDiagnosticOrderStatus(0)
  else
    result := TFhirDiagnosticOrderStatus(StringArrayIndexOfSensitive(CODES_TFhirDiagnosticOrderStatus, FStatus.value));
end;

Procedure TFhirDiagnosticOrderItem.SetStatusST(value : TFhirDiagnosticOrderStatus);
begin
  if ord(value) = 0 then
    StatusObject := nil
  else
    StatusObject := TFhirEnum.create(CODES_TFhirDiagnosticOrderStatus[value]);
end;


{ TFhirDiagnosticOrderItemListEnumerator }

Constructor TFhirDiagnosticOrderItemListEnumerator.Create(list : TFhirDiagnosticOrderItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirDiagnosticOrderItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticOrderItemListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirDiagnosticOrderItemListEnumerator.GetCurrent : TFhirDiagnosticOrderItem;
begin
  Result := FList[FIndex];
end;


{ TFhirDiagnosticOrderItemList }
procedure TFhirDiagnosticOrderItemList.AddItem(value: TFhirDiagnosticOrderItem);
begin
  assert(value.ClassName = 'TFhirDiagnosticOrderItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticOrderItem');
  add(value);
end;


function TFhirDiagnosticOrderItemList.Append: TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticOrderItemList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticOrderItemList.GetEnumerator : TFhirDiagnosticOrderItemListEnumerator;
begin
  result := TFhirDiagnosticOrderItemListEnumerator.Create(self.link);
end;

function TFhirDiagnosticOrderItemList.Clone: TFhirDiagnosticOrderItemList;
begin
  result := TFhirDiagnosticOrderItemList(inherited Clone);
end;

function TFhirDiagnosticOrderItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticOrderItemList.GetItemN(index: Integer): TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderItemList.IndexOf(value: TFhirDiagnosticOrderItem): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDiagnosticOrderItemList.Insert(index: Integer): TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticOrderItemList.InsertItem(index: Integer; value: TFhirDiagnosticOrderItem);
begin
  assert(value is TFhirDiagnosticOrderItem);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticOrderItemList.Item(index: Integer): TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderItemList.Link: TFhirDiagnosticOrderItemList;
begin
  result := TFhirDiagnosticOrderItemList(inherited Link);
end;

procedure TFhirDiagnosticOrderItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticOrderItemList.SetItemByIndex(index: Integer; value: TFhirDiagnosticOrderItem);
begin
  assert(value is TFhirDiagnosticOrderItem);
  FhirDiagnosticOrderItems[index] := value;
end;

procedure TFhirDiagnosticOrderItemList.SetItemN(index: Integer; value: TFhirDiagnosticOrderItem);
begin
  assert(value is TFhirDiagnosticOrderItem);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticReportImage }

constructor TFhirDiagnosticReportImage.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticReportImage.Destroy;
begin
  FComment.free;
  FLink_.free;
  inherited;
end;

procedure TFhirDiagnosticReportImage.Assign(oSource : TAdvObject);
begin
  inherited;
  commentObject := TFhirDiagnosticReportImage(oSource).commentObject.Clone;
  link_ := TFhirDiagnosticReportImage(oSource).link_.Clone;
end;

procedure TFhirDiagnosticReportImage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'comment') Then
     list.add(FComment.Link);
  if (child_name = 'link') Then
     list.add(FLink_.Link);
end;

procedure TFhirDiagnosticReportImage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'comment', 'string', FComment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'link', 'Resource(Media)', FLink_.Link));{2}
end;

procedure TFhirDiagnosticReportImage.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'comment') then CommentObject := propValue as TFhirString{5a}
  else if (propName = 'link') then Link_ := propValue as TFhirResourceReference{TFhirMedia}{4b}
  else inherited;
end;

function TFhirDiagnosticReportImage.FhirType : string;
begin
  result := 'image';
end;

function TFhirDiagnosticReportImage.Link : TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(inherited Link);
end;

function TFhirDiagnosticReportImage.Clone : TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(inherited Clone);
end;

{ TFhirDiagnosticReportImage }

Procedure TFhirDiagnosticReportImage.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirDiagnosticReportImage.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirDiagnosticReportImage.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Procedure TFhirDiagnosticReportImage.SetLink_(value : TFhirResourceReference{TFhirMedia});
begin
  FLink_.free;
  FLink_ := value;
end;


{ TFhirDiagnosticReportImageListEnumerator }

Constructor TFhirDiagnosticReportImageListEnumerator.Create(list : TFhirDiagnosticReportImageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirDiagnosticReportImageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticReportImageListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirDiagnosticReportImageListEnumerator.GetCurrent : TFhirDiagnosticReportImage;
begin
  Result := FList[FIndex];
end;


{ TFhirDiagnosticReportImageList }
procedure TFhirDiagnosticReportImageList.AddItem(value: TFhirDiagnosticReportImage);
begin
  assert(value.ClassName = 'TFhirDiagnosticReportImage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticReportImage');
  add(value);
end;


function TFhirDiagnosticReportImageList.Append: TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticReportImageList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticReportImageList.GetEnumerator : TFhirDiagnosticReportImageListEnumerator;
begin
  result := TFhirDiagnosticReportImageListEnumerator.Create(self.link);
end;

function TFhirDiagnosticReportImageList.Clone: TFhirDiagnosticReportImageList;
begin
  result := TFhirDiagnosticReportImageList(inherited Clone);
end;

function TFhirDiagnosticReportImageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticReportImageList.GetItemN(index: Integer): TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportImageList.IndexOf(value: TFhirDiagnosticReportImage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDiagnosticReportImageList.Insert(index: Integer): TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDiagnosticReportImageList.InsertItem(index: Integer; value: TFhirDiagnosticReportImage);
begin
  assert(value is TFhirDiagnosticReportImage);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticReportImageList.Item(index: Integer): TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportImageList.Link: TFhirDiagnosticReportImageList;
begin
  result := TFhirDiagnosticReportImageList(inherited Link);
end;

procedure TFhirDiagnosticReportImageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticReportImageList.SetItemByIndex(index: Integer; value: TFhirDiagnosticReportImage);
begin
  assert(value is TFhirDiagnosticReportImage);
  FhirDiagnosticReportImages[index] := value;
end;

procedure TFhirDiagnosticReportImageList.SetItemN(index: Integer; value: TFhirDiagnosticReportImage);
begin
  assert(value is TFhirDiagnosticReportImage);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceRelatesTo }

constructor TFhirDocumentReferenceRelatesTo.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceRelatesTo.Destroy;
begin
  FCode.free;
  FTarget.free;
  inherited;
end;

procedure TFhirDocumentReferenceRelatesTo.Assign(oSource : TAdvObject);
begin
  inherited;
  FCode := TFhirDocumentReferenceRelatesTo(oSource).FCode.Link;
  target := TFhirDocumentReferenceRelatesTo(oSource).target.Clone;
end;

procedure TFhirDocumentReferenceRelatesTo.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'target') Then
     list.add(FTarget.Link);
end;

procedure TFhirDocumentReferenceRelatesTo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(DocumentReference)', FTarget.Link));{2}
end;

procedure TFhirDocumentReferenceRelatesTo.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then CodeObject := propValue as TFHIREnum
  else if (propName = 'target') then Target := propValue as TFhirResourceReference{TFhirDocumentReference}{4b}
  else inherited;
end;

function TFhirDocumentReferenceRelatesTo.FhirType : string;
begin
  result := 'relatesTo';
end;

function TFhirDocumentReferenceRelatesTo.Link : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(inherited Link);
end;

function TFhirDocumentReferenceRelatesTo.Clone : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(inherited Clone);
end;

{ TFhirDocumentReferenceRelatesTo }

Procedure TFhirDocumentReferenceRelatesTo.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirDocumentReferenceRelatesTo.GetCodeST : TFhirDocumentRelationshipType;
begin
  if FCode = nil then
    result := TFhirDocumentRelationshipType(0)
  else
    result := TFhirDocumentRelationshipType(StringArrayIndexOfSensitive(CODES_TFhirDocumentRelationshipType, FCode.value));
end;

Procedure TFhirDocumentReferenceRelatesTo.SetCodeST(value : TFhirDocumentRelationshipType);
begin
  if ord(value) = 0 then
    CodeObject := nil
  else
    CodeObject := TFhirEnum.create(CODES_TFhirDocumentRelationshipType[value]);
end;

Procedure TFhirDocumentReferenceRelatesTo.SetTarget(value : TFhirResourceReference{TFhirDocumentReference});
begin
  FTarget.free;
  FTarget := value;
end;


{ TFhirDocumentReferenceRelatesToListEnumerator }

Constructor TFhirDocumentReferenceRelatesToListEnumerator.Create(list : TFhirDocumentReferenceRelatesToList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirDocumentReferenceRelatesToListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceRelatesToListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirDocumentReferenceRelatesToListEnumerator.GetCurrent : TFhirDocumentReferenceRelatesTo;
begin
  Result := FList[FIndex];
end;


{ TFhirDocumentReferenceRelatesToList }
procedure TFhirDocumentReferenceRelatesToList.AddItem(value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceRelatesTo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceRelatesTo');
  add(value);
end;


function TFhirDocumentReferenceRelatesToList.Append: TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceRelatesToList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceRelatesToList.GetEnumerator : TFhirDocumentReferenceRelatesToListEnumerator;
begin
  result := TFhirDocumentReferenceRelatesToListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceRelatesToList.Clone: TFhirDocumentReferenceRelatesToList;
begin
  result := TFhirDocumentReferenceRelatesToList(inherited Clone);
end;

function TFhirDocumentReferenceRelatesToList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceRelatesToList.GetItemN(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceRelatesToList.IndexOf(value: TFhirDocumentReferenceRelatesTo): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDocumentReferenceRelatesToList.Insert(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceRelatesToList.InsertItem(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceRelatesToList.Item(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceRelatesToList.Link: TFhirDocumentReferenceRelatesToList;
begin
  result := TFhirDocumentReferenceRelatesToList(inherited Link);
end;

procedure TFhirDocumentReferenceRelatesToList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceRelatesToList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  FhirDocumentReferenceRelatesTos[index] := value;
end;

procedure TFhirDocumentReferenceRelatesToList.SetItemN(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceService }

constructor TFhirDocumentReferenceService.Create;
begin
  inherited;
  FParameterList := TFhirDocumentReferenceServiceParameterList.Create;
end;

destructor TFhirDocumentReferenceService.Destroy;
begin
  FType_.free;
  FAddress.free;
  FParameterList.Free;
  inherited;
end;

procedure TFhirDocumentReferenceService.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirDocumentReferenceService(oSource).type_.Clone;
  addressObject := TFhirDocumentReferenceService(oSource).addressObject.Clone;
  FParameterList.Assign(TFhirDocumentReferenceService(oSource).FParameterList);
end;

procedure TFhirDocumentReferenceService.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'address') Then
     list.add(FAddress.Link);
  if (child_name = 'parameter') Then
     list.addAll(FParameterList);
end;

procedure TFhirDocumentReferenceService.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'address', 'string', FAddress.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', '', FParameterList.Link)){3};
end;

procedure TFhirDocumentReferenceService.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'type') then Type_ := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'address') then AddressObject := propValue as TFhirString{5a}
  else if (propName = 'parameter') then ParameterList.add(propValue as TFhirDocumentReferenceServiceParameter){2}
  else inherited;
end;

function TFhirDocumentReferenceService.FhirType : string;
begin
  result := 'service';
end;

function TFhirDocumentReferenceService.Link : TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService(inherited Link);
end;

function TFhirDocumentReferenceService.Clone : TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService(inherited Clone);
end;

{ TFhirDocumentReferenceService }

Procedure TFhirDocumentReferenceService.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirDocumentReferenceService.SetAddress(value : TFhirString);
begin
  FAddress.free;
  FAddress := value;
end;

Function TFhirDocumentReferenceService.GetAddressST : String;
begin
  if FAddress = nil then
    result := ''
  else
    result := FAddress.value;
end;

Procedure TFhirDocumentReferenceService.SetAddressST(value : String);
begin
  if value <> '' then
  begin
    if FAddress = nil then
      FAddress := TFhirString.create;
    FAddress.value := value
  end
  else if FAddress <> nil then
    FAddress.value := '';
end;


{ TFhirDocumentReferenceServiceListEnumerator }

Constructor TFhirDocumentReferenceServiceListEnumerator.Create(list : TFhirDocumentReferenceServiceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirDocumentReferenceServiceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceServiceListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirDocumentReferenceServiceListEnumerator.GetCurrent : TFhirDocumentReferenceService;
begin
  Result := FList[FIndex];
end;


{ TFhirDocumentReferenceServiceList }
procedure TFhirDocumentReferenceServiceList.AddItem(value: TFhirDocumentReferenceService);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceService', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceService');
  add(value);
end;


function TFhirDocumentReferenceServiceList.Append: TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceServiceList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceServiceList.GetEnumerator : TFhirDocumentReferenceServiceListEnumerator;
begin
  result := TFhirDocumentReferenceServiceListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceServiceList.Clone: TFhirDocumentReferenceServiceList;
begin
  result := TFhirDocumentReferenceServiceList(inherited Clone);
end;

function TFhirDocumentReferenceServiceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceServiceList.GetItemN(index: Integer): TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceServiceList.IndexOf(value: TFhirDocumentReferenceService): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDocumentReferenceServiceList.Insert(index: Integer): TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceServiceList.InsertItem(index: Integer; value: TFhirDocumentReferenceService);
begin
  assert(value is TFhirDocumentReferenceService);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceServiceList.Item(index: Integer): TFhirDocumentReferenceService;
begin
  result := TFhirDocumentReferenceService(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceServiceList.Link: TFhirDocumentReferenceServiceList;
begin
  result := TFhirDocumentReferenceServiceList(inherited Link);
end;

procedure TFhirDocumentReferenceServiceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceServiceList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceService);
begin
  assert(value is TFhirDocumentReferenceService);
  FhirDocumentReferenceServices[index] := value;
end;

procedure TFhirDocumentReferenceServiceList.SetItemN(index: Integer; value: TFhirDocumentReferenceService);
begin
  assert(value is TFhirDocumentReferenceService);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceServiceParameter }

constructor TFhirDocumentReferenceServiceParameter.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceServiceParameter.Destroy;
begin
  FName.free;
  FValue.free;
  inherited;
end;

procedure TFhirDocumentReferenceServiceParameter.Assign(oSource : TAdvObject);
begin
  inherited;
  nameObject := TFhirDocumentReferenceServiceParameter(oSource).nameObject.Clone;
  valueObject := TFhirDocumentReferenceServiceParameter(oSource).valueObject.Clone;
end;

procedure TFhirDocumentReferenceServiceParameter.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'value') Then
     list.add(FValue.Link);
end;

procedure TFhirDocumentReferenceServiceParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', FValue.Link));{2}
end;

procedure TFhirDocumentReferenceServiceParameter.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'value') then ValueObject := propValue as TFhirString{5a}
  else inherited;
end;

function TFhirDocumentReferenceServiceParameter.FhirType : string;
begin
  result := 'parameter';
end;

function TFhirDocumentReferenceServiceParameter.Link : TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter(inherited Link);
end;

function TFhirDocumentReferenceServiceParameter.Clone : TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter(inherited Clone);
end;

{ TFhirDocumentReferenceServiceParameter }

Procedure TFhirDocumentReferenceServiceParameter.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirDocumentReferenceServiceParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirDocumentReferenceServiceParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirDocumentReferenceServiceParameter.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirDocumentReferenceServiceParameter.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirDocumentReferenceServiceParameter.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;


{ TFhirDocumentReferenceServiceParameterListEnumerator }

Constructor TFhirDocumentReferenceServiceParameterListEnumerator.Create(list : TFhirDocumentReferenceServiceParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirDocumentReferenceServiceParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceServiceParameterListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirDocumentReferenceServiceParameterListEnumerator.GetCurrent : TFhirDocumentReferenceServiceParameter;
begin
  Result := FList[FIndex];
end;


{ TFhirDocumentReferenceServiceParameterList }
procedure TFhirDocumentReferenceServiceParameterList.AddItem(value: TFhirDocumentReferenceServiceParameter);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceServiceParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceServiceParameter');
  add(value);
end;


function TFhirDocumentReferenceServiceParameterList.Append: TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceServiceParameterList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceServiceParameterList.GetEnumerator : TFhirDocumentReferenceServiceParameterListEnumerator;
begin
  result := TFhirDocumentReferenceServiceParameterListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceServiceParameterList.Clone: TFhirDocumentReferenceServiceParameterList;
begin
  result := TFhirDocumentReferenceServiceParameterList(inherited Clone);
end;

function TFhirDocumentReferenceServiceParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceServiceParameterList.GetItemN(index: Integer): TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceServiceParameterList.IndexOf(value: TFhirDocumentReferenceServiceParameter): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDocumentReferenceServiceParameterList.Insert(index: Integer): TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceServiceParameterList.InsertItem(index: Integer; value: TFhirDocumentReferenceServiceParameter);
begin
  assert(value is TFhirDocumentReferenceServiceParameter);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceServiceParameterList.Item(index: Integer): TFhirDocumentReferenceServiceParameter;
begin
  result := TFhirDocumentReferenceServiceParameter(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceServiceParameterList.Link: TFhirDocumentReferenceServiceParameterList;
begin
  result := TFhirDocumentReferenceServiceParameterList(inherited Link);
end;

procedure TFhirDocumentReferenceServiceParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceServiceParameterList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceServiceParameter);
begin
  assert(value is TFhirDocumentReferenceServiceParameter);
  FhirDocumentReferenceServiceParameters[index] := value;
end;

procedure TFhirDocumentReferenceServiceParameterList.SetItemN(index: Integer; value: TFhirDocumentReferenceServiceParameter);
begin
  assert(value is TFhirDocumentReferenceServiceParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceContext }

constructor TFhirDocumentReferenceContext.Create;
begin
  inherited;
  FEventList := TFhirCodeableConceptList.Create;
end;

destructor TFhirDocumentReferenceContext.Destroy;
begin
  FEventList.Free;
  FPeriod.free;
  FFacilityType.free;
  inherited;
end;

procedure TFhirDocumentReferenceContext.Assign(oSource : TAdvObject);
begin
  inherited;
  FEventList.Assign(TFhirDocumentReferenceContext(oSource).FEventList);
  period := TFhirDocumentReferenceContext(oSource).period.Clone;
  facilityType := TFhirDocumentReferenceContext(oSource).facilityType.Clone;
end;

procedure TFhirDocumentReferenceContext.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'event') Then
     list.addAll(FEventList);
  if (child_name = 'period') Then
     list.add(FPeriod.Link);
  if (child_name = 'facilityType') Then
     list.add(FFacilityType.Link);
end;

procedure TFhirDocumentReferenceContext.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'event', 'CodeableConcept', FEventList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'facilityType', 'CodeableConcept', FFacilityType.Link));{2}
end;

procedure TFhirDocumentReferenceContext.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'event') then EventList.add(propValue as TFhirCodeableConcept){2}
  else if (propName = 'period') then Period := propValue as TFhirPeriod{4b}
  else if (propName = 'facilityType') then FacilityType := propValue as TFhirCodeableConcept{4b}
  else inherited;
end;

function TFhirDocumentReferenceContext.FhirType : string;
begin
  result := 'context';
end;

function TFhirDocumentReferenceContext.Link : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(inherited Link);
end;

function TFhirDocumentReferenceContext.Clone : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(inherited Clone);
end;

{ TFhirDocumentReferenceContext }

Procedure TFhirDocumentReferenceContext.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirDocumentReferenceContext.SetFacilityType(value : TFhirCodeableConcept);
begin
  FFacilityType.free;
  FFacilityType := value;
end;


{ TFhirDocumentReferenceContextListEnumerator }

Constructor TFhirDocumentReferenceContextListEnumerator.Create(list : TFhirDocumentReferenceContextList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirDocumentReferenceContextListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceContextListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirDocumentReferenceContextListEnumerator.GetCurrent : TFhirDocumentReferenceContext;
begin
  Result := FList[FIndex];
end;


{ TFhirDocumentReferenceContextList }
procedure TFhirDocumentReferenceContextList.AddItem(value: TFhirDocumentReferenceContext);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceContext', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceContext');
  add(value);
end;


function TFhirDocumentReferenceContextList.Append: TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceContextList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceContextList.GetEnumerator : TFhirDocumentReferenceContextListEnumerator;
begin
  result := TFhirDocumentReferenceContextListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceContextList.Clone: TFhirDocumentReferenceContextList;
begin
  result := TFhirDocumentReferenceContextList(inherited Clone);
end;

function TFhirDocumentReferenceContextList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceContextList.GetItemN(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextList.IndexOf(value: TFhirDocumentReferenceContext): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirDocumentReferenceContextList.Insert(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirDocumentReferenceContextList.InsertItem(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceContextList.Item(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextList.Link: TFhirDocumentReferenceContextList;
begin
  result := TFhirDocumentReferenceContextList(inherited Link);
end;

procedure TFhirDocumentReferenceContextList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceContextList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  FhirDocumentReferenceContexts[index] := value;
end;

procedure TFhirDocumentReferenceContextList.SetItemN(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterParticipant }

constructor TFhirEncounterParticipant.Create;
begin
  inherited;
  FType_List := TFhirCodeableConceptList.Create;
end;

destructor TFhirEncounterParticipant.Destroy;
begin
  FType_List.Free;
  FIndividual.free;
  inherited;
end;

procedure TFhirEncounterParticipant.Assign(oSource : TAdvObject);
begin
  inherited;
  FType_List.Assign(TFhirEncounterParticipant(oSource).FType_List);
  individual := TFhirEncounterParticipant(oSource).individual.Clone;
end;

procedure TFhirEncounterParticipant.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type') Then
     list.addAll(FType_List);
  if (child_name = 'individual') Then
     list.add(FIndividual.Link);
end;

procedure TFhirEncounterParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'individual', 'Resource(Practitioner|RelatedPerson)', FIndividual.Link));{2}
end;

procedure TFhirEncounterParticipant.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'type') then Type_List.add(propValue as TFhirCodeableConcept){2}
  else if (propName = 'individual') then Individual := propValue as TFhirResourceReference{Resource}{4b}
  else inherited;
end;

function TFhirEncounterParticipant.FhirType : string;
begin
  result := 'participant';
end;

function TFhirEncounterParticipant.Link : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(inherited Link);
end;

function TFhirEncounterParticipant.Clone : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(inherited Clone);
end;

{ TFhirEncounterParticipant }

Procedure TFhirEncounterParticipant.SetIndividual(value : TFhirResourceReference{Resource});
begin
  FIndividual.free;
  FIndividual := value;
end;


{ TFhirEncounterParticipantListEnumerator }

Constructor TFhirEncounterParticipantListEnumerator.Create(list : TFhirEncounterParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirEncounterParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterParticipantListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirEncounterParticipantListEnumerator.GetCurrent : TFhirEncounterParticipant;
begin
  Result := FList[FIndex];
end;


{ TFhirEncounterParticipantList }
procedure TFhirEncounterParticipantList.AddItem(value: TFhirEncounterParticipant);
begin
  assert(value.ClassName = 'TFhirEncounterParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterParticipant');
  add(value);
end;


function TFhirEncounterParticipantList.Append: TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterParticipantList.GetEnumerator : TFhirEncounterParticipantListEnumerator;
begin
  result := TFhirEncounterParticipantListEnumerator.Create(self.link);
end;

function TFhirEncounterParticipantList.Clone: TFhirEncounterParticipantList;
begin
  result := TFhirEncounterParticipantList(inherited Clone);
end;

function TFhirEncounterParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterParticipantList.GetItemN(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(ObjectByIndex[index]);
end;

function TFhirEncounterParticipantList.IndexOf(value: TFhirEncounterParticipant): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirEncounterParticipantList.Insert(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterParticipantList.InsertItem(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  Inherited Insert(index, value);
end;

function TFhirEncounterParticipantList.Item(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(ObjectByIndex[index]);
end;

function TFhirEncounterParticipantList.Link: TFhirEncounterParticipantList;
begin
  result := TFhirEncounterParticipantList(inherited Link);
end;

procedure TFhirEncounterParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterParticipantList.SetItemByIndex(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  FhirEncounterParticipants[index] := value;
end;

procedure TFhirEncounterParticipantList.SetItemN(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterHospitalization }

constructor TFhirEncounterHospitalization.Create;
begin
  inherited;
  FAccomodationList := TFhirEncounterHospitalizationAccomodationList.Create;
  FSpecialCourtesyList := TFhirCodeableConceptList.Create;
  FSpecialArrangementList := TFhirCodeableConceptList.Create;
end;

destructor TFhirEncounterHospitalization.Destroy;
begin
  FPreAdmissionIdentifier.free;
  FOrigin.free;
  FAdmitSource.free;
  FPeriod.free;
  FAccomodationList.Free;
  FDiet.free;
  FSpecialCourtesyList.Free;
  FSpecialArrangementList.Free;
  FDestination.free;
  FDischargeDisposition.free;
  FDischargeDiagnosis.free;
  FReAdmission.free;
  inherited;
end;

procedure TFhirEncounterHospitalization.Assign(oSource : TAdvObject);
begin
  inherited;
  preAdmissionIdentifier := TFhirEncounterHospitalization(oSource).preAdmissionIdentifier.Clone;
  origin := TFhirEncounterHospitalization(oSource).origin.Clone;
  admitSource := TFhirEncounterHospitalization(oSource).admitSource.Clone;
  period := TFhirEncounterHospitalization(oSource).period.Clone;
  FAccomodationList.Assign(TFhirEncounterHospitalization(oSource).FAccomodationList);
  diet := TFhirEncounterHospitalization(oSource).diet.Clone;
  FSpecialCourtesyList.Assign(TFhirEncounterHospitalization(oSource).FSpecialCourtesyList);
  FSpecialArrangementList.Assign(TFhirEncounterHospitalization(oSource).FSpecialArrangementList);
  destination := TFhirEncounterHospitalization(oSource).destination.Clone;
  dischargeDisposition := TFhirEncounterHospitalization(oSource).dischargeDisposition.Clone;
  dischargeDiagnosis := TFhirEncounterHospitalization(oSource).dischargeDiagnosis.Clone;
  reAdmissionObject := TFhirEncounterHospitalization(oSource).reAdmissionObject.Clone;
end;

procedure TFhirEncounterHospitalization.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'preAdmissionIdentifier') Then
     list.add(FPreAdmissionIdentifier.Link);
  if (child_name = 'origin') Then
     list.add(FOrigin.Link);
  if (child_name = 'admitSource') Then
     list.add(FAdmitSource.Link);
  if (child_name = 'period') Then
     list.add(FPeriod.Link);
  if (child_name = 'accomodation') Then
     list.addAll(FAccomodationList);
  if (child_name = 'diet') Then
     list.add(FDiet.Link);
  if (child_name = 'specialCourtesy') Then
     list.addAll(FSpecialCourtesyList);
  if (child_name = 'specialArrangement') Then
     list.addAll(FSpecialArrangementList);
  if (child_name = 'destination') Then
     list.add(FDestination.Link);
  if (child_name = 'dischargeDisposition') Then
     list.add(FDischargeDisposition.Link);
  if (child_name = 'dischargeDiagnosis') Then
     list.add(FDischargeDiagnosis.Link);
  if (child_name = 'reAdmission') Then
     list.add(FReAdmission.Link);
end;

procedure TFhirEncounterHospitalization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'preAdmissionIdentifier', 'Identifier', FPreAdmissionIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'origin', 'Resource(Location)', FOrigin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'admitSource', 'CodeableConcept', FAdmitSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'accomodation', '', FAccomodationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'diet', 'CodeableConcept', FDiet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specialCourtesy', 'CodeableConcept', FSpecialCourtesyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'specialArrangement', 'CodeableConcept', FSpecialArrangementList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'destination', 'Resource(Location)', FDestination.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dischargeDisposition', 'CodeableConcept', FDischargeDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dischargeDiagnosis', 'Resource(Any)', FDischargeDiagnosis.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reAdmission', 'boolean', FReAdmission.Link));{2}
end;

procedure TFhirEncounterHospitalization.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'preAdmissionIdentifier') then PreAdmissionIdentifier := propValue as TFhirIdentifier{4b}
  else if (propName = 'origin') then Origin := propValue as TFhirResourceReference{TFhirLocation}{4b}
  else if (propName = 'admitSource') then AdmitSource := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'period') then Period := propValue as TFhirPeriod{4b}
  else if (propName = 'accomodation') then AccomodationList.add(propValue as TFhirEncounterHospitalizationAccomodation){2}
  else if (propName = 'diet') then Diet := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'specialCourtesy') then SpecialCourtesyList.add(propValue as TFhirCodeableConcept){2}
  else if (propName = 'specialArrangement') then SpecialArrangementList.add(propValue as TFhirCodeableConcept){2}
  else if (propName = 'destination') then Destination := propValue as TFhirResourceReference{TFhirLocation}{4b}
  else if (propName = 'dischargeDisposition') then DischargeDisposition := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'dischargeDiagnosis') then DischargeDiagnosis := propValue as TFhirResourceReference{Resource}{4b}
  else if (propName = 'reAdmission') then ReAdmissionObject := propValue as TFhirBoolean{5a}
  else inherited;
end;

function TFhirEncounterHospitalization.FhirType : string;
begin
  result := 'hospitalization';
end;

function TFhirEncounterHospitalization.Link : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(inherited Link);
end;

function TFhirEncounterHospitalization.Clone : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(inherited Clone);
end;

{ TFhirEncounterHospitalization }

Procedure TFhirEncounterHospitalization.SetPreAdmissionIdentifier(value : TFhirIdentifier);
begin
  FPreAdmissionIdentifier.free;
  FPreAdmissionIdentifier := value;
end;

Procedure TFhirEncounterHospitalization.SetOrigin(value : TFhirResourceReference{TFhirLocation});
begin
  FOrigin.free;
  FOrigin := value;
end;

Procedure TFhirEncounterHospitalization.SetAdmitSource(value : TFhirCodeableConcept);
begin
  FAdmitSource.free;
  FAdmitSource := value;
end;

Procedure TFhirEncounterHospitalization.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirEncounterHospitalization.SetDiet(value : TFhirCodeableConcept);
begin
  FDiet.free;
  FDiet := value;
end;

Procedure TFhirEncounterHospitalization.SetDestination(value : TFhirResourceReference{TFhirLocation});
begin
  FDestination.free;
  FDestination := value;
end;

Procedure TFhirEncounterHospitalization.SetDischargeDisposition(value : TFhirCodeableConcept);
begin
  FDischargeDisposition.free;
  FDischargeDisposition := value;
end;

Procedure TFhirEncounterHospitalization.SetDischargeDiagnosis(value : TFhirResourceReference{Resource});
begin
  FDischargeDiagnosis.free;
  FDischargeDiagnosis := value;
end;

Procedure TFhirEncounterHospitalization.SetReAdmission(value : TFhirBoolean);
begin
  FReAdmission.free;
  FReAdmission := value;
end;

Function TFhirEncounterHospitalization.GetReAdmissionST : Boolean;
begin
  if FReAdmission = nil then
    result := false
  else
    result := FReAdmission.value;
end;

Procedure TFhirEncounterHospitalization.SetReAdmissionST(value : Boolean);
begin
  if FReAdmission = nil then
    FReAdmission := TFhirBoolean.create;
  FReAdmission.value := value
end;


{ TFhirEncounterHospitalizationListEnumerator }

Constructor TFhirEncounterHospitalizationListEnumerator.Create(list : TFhirEncounterHospitalizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirEncounterHospitalizationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterHospitalizationListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirEncounterHospitalizationListEnumerator.GetCurrent : TFhirEncounterHospitalization;
begin
  Result := FList[FIndex];
end;


{ TFhirEncounterHospitalizationList }
procedure TFhirEncounterHospitalizationList.AddItem(value: TFhirEncounterHospitalization);
begin
  assert(value.ClassName = 'TFhirEncounterHospitalization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterHospitalization');
  add(value);
end;


function TFhirEncounterHospitalizationList.Append: TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterHospitalizationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterHospitalizationList.GetEnumerator : TFhirEncounterHospitalizationListEnumerator;
begin
  result := TFhirEncounterHospitalizationListEnumerator.Create(self.link);
end;

function TFhirEncounterHospitalizationList.Clone: TFhirEncounterHospitalizationList;
begin
  result := TFhirEncounterHospitalizationList(inherited Clone);
end;

function TFhirEncounterHospitalizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterHospitalizationList.GetItemN(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationList.IndexOf(value: TFhirEncounterHospitalization): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirEncounterHospitalizationList.Insert(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterHospitalizationList.InsertItem(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  Inherited Insert(index, value);
end;

function TFhirEncounterHospitalizationList.Item(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationList.Link: TFhirEncounterHospitalizationList;
begin
  result := TFhirEncounterHospitalizationList(inherited Link);
end;

procedure TFhirEncounterHospitalizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterHospitalizationList.SetItemByIndex(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  FhirEncounterHospitalizations[index] := value;
end;

procedure TFhirEncounterHospitalizationList.SetItemN(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterHospitalizationAccomodation }

constructor TFhirEncounterHospitalizationAccomodation.Create;
begin
  inherited;
end;

destructor TFhirEncounterHospitalizationAccomodation.Destroy;
begin
  FBed.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterHospitalizationAccomodation.Assign(oSource : TAdvObject);
begin
  inherited;
  bed := TFhirEncounterHospitalizationAccomodation(oSource).bed.Clone;
  period := TFhirEncounterHospitalizationAccomodation(oSource).period.Clone;
end;

procedure TFhirEncounterHospitalizationAccomodation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'bed') Then
     list.add(FBed.Link);
  if (child_name = 'period') Then
     list.add(FPeriod.Link);
end;

procedure TFhirEncounterHospitalizationAccomodation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'bed', 'Resource(Location)', FBed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link));{2}
end;

procedure TFhirEncounterHospitalizationAccomodation.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'bed') then Bed := propValue as TFhirResourceReference{TFhirLocation}{4b}
  else if (propName = 'period') then Period := propValue as TFhirPeriod{4b}
  else inherited;
end;

function TFhirEncounterHospitalizationAccomodation.FhirType : string;
begin
  result := 'accomodation';
end;

function TFhirEncounterHospitalizationAccomodation.Link : TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation(inherited Link);
end;

function TFhirEncounterHospitalizationAccomodation.Clone : TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation(inherited Clone);
end;

{ TFhirEncounterHospitalizationAccomodation }

Procedure TFhirEncounterHospitalizationAccomodation.SetBed(value : TFhirResourceReference{TFhirLocation});
begin
  FBed.free;
  FBed := value;
end;

Procedure TFhirEncounterHospitalizationAccomodation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;


{ TFhirEncounterHospitalizationAccomodationListEnumerator }

Constructor TFhirEncounterHospitalizationAccomodationListEnumerator.Create(list : TFhirEncounterHospitalizationAccomodationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirEncounterHospitalizationAccomodationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterHospitalizationAccomodationListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirEncounterHospitalizationAccomodationListEnumerator.GetCurrent : TFhirEncounterHospitalizationAccomodation;
begin
  Result := FList[FIndex];
end;


{ TFhirEncounterHospitalizationAccomodationList }
procedure TFhirEncounterHospitalizationAccomodationList.AddItem(value: TFhirEncounterHospitalizationAccomodation);
begin
  assert(value.ClassName = 'TFhirEncounterHospitalizationAccomodation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterHospitalizationAccomodation');
  add(value);
end;


function TFhirEncounterHospitalizationAccomodationList.Append: TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterHospitalizationAccomodationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterHospitalizationAccomodationList.GetEnumerator : TFhirEncounterHospitalizationAccomodationListEnumerator;
begin
  result := TFhirEncounterHospitalizationAccomodationListEnumerator.Create(self.link);
end;

function TFhirEncounterHospitalizationAccomodationList.Clone: TFhirEncounterHospitalizationAccomodationList;
begin
  result := TFhirEncounterHospitalizationAccomodationList(inherited Clone);
end;

function TFhirEncounterHospitalizationAccomodationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterHospitalizationAccomodationList.GetItemN(index: Integer): TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationAccomodationList.IndexOf(value: TFhirEncounterHospitalizationAccomodation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirEncounterHospitalizationAccomodationList.Insert(index: Integer): TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterHospitalizationAccomodationList.InsertItem(index: Integer; value: TFhirEncounterHospitalizationAccomodation);
begin
  assert(value is TFhirEncounterHospitalizationAccomodation);
  Inherited Insert(index, value);
end;

function TFhirEncounterHospitalizationAccomodationList.Item(index: Integer): TFhirEncounterHospitalizationAccomodation;
begin
  result := TFhirEncounterHospitalizationAccomodation(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationAccomodationList.Link: TFhirEncounterHospitalizationAccomodationList;
begin
  result := TFhirEncounterHospitalizationAccomodationList(inherited Link);
end;

procedure TFhirEncounterHospitalizationAccomodationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterHospitalizationAccomodationList.SetItemByIndex(index: Integer; value: TFhirEncounterHospitalizationAccomodation);
begin
  assert(value is TFhirEncounterHospitalizationAccomodation);
  FhirEncounterHospitalizationAccomodations[index] := value;
end;

procedure TFhirEncounterHospitalizationAccomodationList.SetItemN(index: Integer; value: TFhirEncounterHospitalizationAccomodation);
begin
  assert(value is TFhirEncounterHospitalizationAccomodation);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterLocation }

constructor TFhirEncounterLocation.Create;
begin
  inherited;
end;

destructor TFhirEncounterLocation.Destroy;
begin
  FLocation.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterLocation.Assign(oSource : TAdvObject);
begin
  inherited;
  location := TFhirEncounterLocation(oSource).location.Clone;
  period := TFhirEncounterLocation(oSource).period.Clone;
end;

procedure TFhirEncounterLocation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'location') Then
     list.add(FLocation.Link);
  if (child_name = 'period') Then
     list.add(FPeriod.Link);
end;

procedure TFhirEncounterLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'location', 'Resource(Location)', FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link));{2}
end;

procedure TFhirEncounterLocation.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'location') then Location := propValue as TFhirResourceReference{TFhirLocation}{4b}
  else if (propName = 'period') then Period := propValue as TFhirPeriod{4b}
  else inherited;
end;

function TFhirEncounterLocation.FhirType : string;
begin
  result := 'location';
end;

function TFhirEncounterLocation.Link : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(inherited Link);
end;

function TFhirEncounterLocation.Clone : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(inherited Clone);
end;

{ TFhirEncounterLocation }

Procedure TFhirEncounterLocation.SetLocation(value : TFhirResourceReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirEncounterLocation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;


{ TFhirEncounterLocationListEnumerator }

Constructor TFhirEncounterLocationListEnumerator.Create(list : TFhirEncounterLocationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirEncounterLocationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterLocationListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirEncounterLocationListEnumerator.GetCurrent : TFhirEncounterLocation;
begin
  Result := FList[FIndex];
end;


{ TFhirEncounterLocationList }
procedure TFhirEncounterLocationList.AddItem(value: TFhirEncounterLocation);
begin
  assert(value.ClassName = 'TFhirEncounterLocation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterLocation');
  add(value);
end;


function TFhirEncounterLocationList.Append: TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterLocationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterLocationList.GetEnumerator : TFhirEncounterLocationListEnumerator;
begin
  result := TFhirEncounterLocationListEnumerator.Create(self.link);
end;

function TFhirEncounterLocationList.Clone: TFhirEncounterLocationList;
begin
  result := TFhirEncounterLocationList(inherited Clone);
end;

function TFhirEncounterLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterLocationList.GetItemN(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(ObjectByIndex[index]);
end;

function TFhirEncounterLocationList.IndexOf(value: TFhirEncounterLocation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirEncounterLocationList.Insert(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirEncounterLocationList.InsertItem(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  Inherited Insert(index, value);
end;

function TFhirEncounterLocationList.Item(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(ObjectByIndex[index]);
end;

function TFhirEncounterLocationList.Link: TFhirEncounterLocationList;
begin
  result := TFhirEncounterLocationList(inherited Link);
end;

procedure TFhirEncounterLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterLocationList.SetItemByIndex(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  FhirEncounterLocations[index] := value;
end;

procedure TFhirEncounterLocationList.SetItemN(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  ObjectByIndex[index] := value;
end;

{ TFhirFamilyHistoryRelation }

constructor TFhirFamilyHistoryRelation.Create;
begin
  inherited;
  FConditionList := TFhirFamilyHistoryRelationConditionList.Create;
end;

destructor TFhirFamilyHistoryRelation.Destroy;
begin
  FName.free;
  FRelationship.free;
  FBorn.free;
  FDeceased.free;
  FNote.free;
  FConditionList.Free;
  inherited;
end;

procedure TFhirFamilyHistoryRelation.Assign(oSource : TAdvObject);
begin
  inherited;
  nameObject := TFhirFamilyHistoryRelation(oSource).nameObject.Clone;
  relationship := TFhirFamilyHistoryRelation(oSource).relationship.Clone;
  born := TFhirFamilyHistoryRelation(oSource).born.Clone;
  deceased := TFhirFamilyHistoryRelation(oSource).deceased.Clone;
  noteObject := TFhirFamilyHistoryRelation(oSource).noteObject.Clone;
  FConditionList.Assign(TFhirFamilyHistoryRelation(oSource).FConditionList);
end;

procedure TFhirFamilyHistoryRelation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'relationship') Then
     list.add(FRelationship.Link);
  if (child_name = 'born[x]') Then
     list.add(FBorn.Link);
  if (child_name = 'deceased[x]') Then
     list.add(FDeceased.Link);
  if (child_name = 'note') Then
     list.add(FNote.Link);
  if (child_name = 'condition') Then
     list.addAll(FConditionList);
end;

procedure TFhirFamilyHistoryRelation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', FRelationship.Link));{2}
  oList.add(TFHIRProperty.create(self, 'born[x]', 'Period|date|string', FBorn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'deceased[x]', 'boolean|Age|Range|date|string', FDeceased.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'string', FNote.Link));{2}
  oList.add(TFHIRProperty.create(self, 'condition', '', FConditionList.Link)){3};
end;

procedure TFhirFamilyHistoryRelation.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'relationship') then Relationship := propValue as TFhirCodeableConcept{4b}
  else if (propName.startsWith('born')) then Born := propValue as TFhirType{4}
  else if (propName.startsWith('deceased')) then Deceased := propValue as TFhirType{4}
  else if (propName = 'note') then NoteObject := propValue as TFhirString{5a}
  else if (propName = 'condition') then ConditionList.add(propValue as TFhirFamilyHistoryRelationCondition){2}
  else inherited;
end;

function TFhirFamilyHistoryRelation.FhirType : string;
begin
  result := 'relation';
end;

function TFhirFamilyHistoryRelation.Link : TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation(inherited Link);
end;

function TFhirFamilyHistoryRelation.Clone : TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation(inherited Clone);
end;

{ TFhirFamilyHistoryRelation }

Procedure TFhirFamilyHistoryRelation.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirFamilyHistoryRelation.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirFamilyHistoryRelation.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirFamilyHistoryRelation.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

Procedure TFhirFamilyHistoryRelation.SetBorn(value : TFhirType);
begin
  FBorn.free;
  FBorn := value;
end;

Procedure TFhirFamilyHistoryRelation.SetDeceased(value : TFhirType);
begin
  FDeceased.free;
  FDeceased := value;
end;

Procedure TFhirFamilyHistoryRelation.SetNote(value : TFhirString);
begin
  FNote.free;
  FNote := value;
end;

Function TFhirFamilyHistoryRelation.GetNoteST : String;
begin
  if FNote = nil then
    result := ''
  else
    result := FNote.value;
end;

Procedure TFhirFamilyHistoryRelation.SetNoteST(value : String);
begin
  if value <> '' then
  begin
    if FNote = nil then
      FNote := TFhirString.create;
    FNote.value := value
  end
  else if FNote <> nil then
    FNote.value := '';
end;


{ TFhirFamilyHistoryRelationListEnumerator }

Constructor TFhirFamilyHistoryRelationListEnumerator.Create(list : TFhirFamilyHistoryRelationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirFamilyHistoryRelationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFamilyHistoryRelationListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirFamilyHistoryRelationListEnumerator.GetCurrent : TFhirFamilyHistoryRelation;
begin
  Result := FList[FIndex];
end;


{ TFhirFamilyHistoryRelationList }
procedure TFhirFamilyHistoryRelationList.AddItem(value: TFhirFamilyHistoryRelation);
begin
  assert(value.ClassName = 'TFhirFamilyHistoryRelation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyHistoryRelation');
  add(value);
end;


function TFhirFamilyHistoryRelationList.Append: TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirFamilyHistoryRelationList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyHistoryRelationList.GetEnumerator : TFhirFamilyHistoryRelationListEnumerator;
begin
  result := TFhirFamilyHistoryRelationListEnumerator.Create(self.link);
end;

function TFhirFamilyHistoryRelationList.Clone: TFhirFamilyHistoryRelationList;
begin
  result := TFhirFamilyHistoryRelationList(inherited Clone);
end;

function TFhirFamilyHistoryRelationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyHistoryRelationList.GetItemN(index: Integer): TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation(ObjectByIndex[index]);
end;

function TFhirFamilyHistoryRelationList.IndexOf(value: TFhirFamilyHistoryRelation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirFamilyHistoryRelationList.Insert(index: Integer): TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirFamilyHistoryRelationList.InsertItem(index: Integer; value: TFhirFamilyHistoryRelation);
begin
  assert(value is TFhirFamilyHistoryRelation);
  Inherited Insert(index, value);
end;

function TFhirFamilyHistoryRelationList.Item(index: Integer): TFhirFamilyHistoryRelation;
begin
  result := TFhirFamilyHistoryRelation(ObjectByIndex[index]);
end;

function TFhirFamilyHistoryRelationList.Link: TFhirFamilyHistoryRelationList;
begin
  result := TFhirFamilyHistoryRelationList(inherited Link);
end;

procedure TFhirFamilyHistoryRelationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyHistoryRelationList.SetItemByIndex(index: Integer; value: TFhirFamilyHistoryRelation);
begin
  assert(value is TFhirFamilyHistoryRelation);
  FhirFamilyHistoryRelations[index] := value;
end;

procedure TFhirFamilyHistoryRelationList.SetItemN(index: Integer; value: TFhirFamilyHistoryRelation);
begin
  assert(value is TFhirFamilyHistoryRelation);
  ObjectByIndex[index] := value;
end;

{ TFhirFamilyHistoryRelationCondition }

constructor TFhirFamilyHistoryRelationCondition.Create;
begin
  inherited;
end;

destructor TFhirFamilyHistoryRelationCondition.Destroy;
begin
  FType_.free;
  FOutcome.free;
  FOnset.free;
  FNote.free;
  inherited;
end;

procedure TFhirFamilyHistoryRelationCondition.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirFamilyHistoryRelationCondition(oSource).type_.Clone;
  outcome := TFhirFamilyHistoryRelationCondition(oSource).outcome.Clone;
  onset := TFhirFamilyHistoryRelationCondition(oSource).onset.Clone;
  noteObject := TFhirFamilyHistoryRelationCondition(oSource).noteObject.Clone;
end;

procedure TFhirFamilyHistoryRelationCondition.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'outcome') Then
     list.add(FOutcome.Link);
  if (child_name = 'onset[x]') Then
     list.add(FOnset.Link);
  if (child_name = 'note') Then
     list.add(FNote.Link);
end;

procedure TFhirFamilyHistoryRelationCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onset[x]', 'Age|Range|string', FOnset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'string', FNote.Link));{2}
end;

procedure TFhirFamilyHistoryRelationCondition.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'type') then Type_ := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'outcome') then Outcome := propValue as TFhirCodeableConcept{4b}
  else if (propName.startsWith('onset')) then Onset := propValue as TFhirType{4}
  else if (propName = 'note') then NoteObject := propValue as TFhirString{5a}
  else inherited;
end;

function TFhirFamilyHistoryRelationCondition.FhirType : string;
begin
  result := 'condition';
end;

function TFhirFamilyHistoryRelationCondition.Link : TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition(inherited Link);
end;

function TFhirFamilyHistoryRelationCondition.Clone : TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition(inherited Clone);
end;

{ TFhirFamilyHistoryRelationCondition }

Procedure TFhirFamilyHistoryRelationCondition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirFamilyHistoryRelationCondition.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirFamilyHistoryRelationCondition.SetOnset(value : TFhirType);
begin
  FOnset.free;
  FOnset := value;
end;

Procedure TFhirFamilyHistoryRelationCondition.SetNote(value : TFhirString);
begin
  FNote.free;
  FNote := value;
end;

Function TFhirFamilyHistoryRelationCondition.GetNoteST : String;
begin
  if FNote = nil then
    result := ''
  else
    result := FNote.value;
end;

Procedure TFhirFamilyHistoryRelationCondition.SetNoteST(value : String);
begin
  if value <> '' then
  begin
    if FNote = nil then
      FNote := TFhirString.create;
    FNote.value := value
  end
  else if FNote <> nil then
    FNote.value := '';
end;


{ TFhirFamilyHistoryRelationConditionListEnumerator }

Constructor TFhirFamilyHistoryRelationConditionListEnumerator.Create(list : TFhirFamilyHistoryRelationConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirFamilyHistoryRelationConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFamilyHistoryRelationConditionListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirFamilyHistoryRelationConditionListEnumerator.GetCurrent : TFhirFamilyHistoryRelationCondition;
begin
  Result := FList[FIndex];
end;


{ TFhirFamilyHistoryRelationConditionList }
procedure TFhirFamilyHistoryRelationConditionList.AddItem(value: TFhirFamilyHistoryRelationCondition);
begin
  assert(value.ClassName = 'TFhirFamilyHistoryRelationCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyHistoryRelationCondition');
  add(value);
end;


function TFhirFamilyHistoryRelationConditionList.Append: TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirFamilyHistoryRelationConditionList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyHistoryRelationConditionList.GetEnumerator : TFhirFamilyHistoryRelationConditionListEnumerator;
begin
  result := TFhirFamilyHistoryRelationConditionListEnumerator.Create(self.link);
end;

function TFhirFamilyHistoryRelationConditionList.Clone: TFhirFamilyHistoryRelationConditionList;
begin
  result := TFhirFamilyHistoryRelationConditionList(inherited Clone);
end;

function TFhirFamilyHistoryRelationConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyHistoryRelationConditionList.GetItemN(index: Integer): TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition(ObjectByIndex[index]);
end;

function TFhirFamilyHistoryRelationConditionList.IndexOf(value: TFhirFamilyHistoryRelationCondition): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirFamilyHistoryRelationConditionList.Insert(index: Integer): TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirFamilyHistoryRelationConditionList.InsertItem(index: Integer; value: TFhirFamilyHistoryRelationCondition);
begin
  assert(value is TFhirFamilyHistoryRelationCondition);
  Inherited Insert(index, value);
end;

function TFhirFamilyHistoryRelationConditionList.Item(index: Integer): TFhirFamilyHistoryRelationCondition;
begin
  result := TFhirFamilyHistoryRelationCondition(ObjectByIndex[index]);
end;

function TFhirFamilyHistoryRelationConditionList.Link: TFhirFamilyHistoryRelationConditionList;
begin
  result := TFhirFamilyHistoryRelationConditionList(inherited Link);
end;

procedure TFhirFamilyHistoryRelationConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyHistoryRelationConditionList.SetItemByIndex(index: Integer; value: TFhirFamilyHistoryRelationCondition);
begin
  assert(value is TFhirFamilyHistoryRelationCondition);
  FhirFamilyHistoryRelationConditions[index] := value;
end;

procedure TFhirFamilyHistoryRelationConditionList.SetItemN(index: Integer; value: TFhirFamilyHistoryRelationCondition);
begin
  assert(value is TFhirFamilyHistoryRelationCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirGroupCharacteristic }

constructor TFhirGroupCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirGroupCharacteristic.Destroy;
begin
  FCode.free;
  FValue.free;
  FExclude.free;
  inherited;
end;

procedure TFhirGroupCharacteristic.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirGroupCharacteristic(oSource).code.Clone;
  value := TFhirGroupCharacteristic(oSource).value.Clone;
  excludeObject := TFhirGroupCharacteristic(oSource).excludeObject.Clone;
end;

procedure TFhirGroupCharacteristic.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'value[x]') Then
     list.add(FValue.Link);
  if (child_name = 'exclude') Then
     list.add(FExclude.Link);
end;

procedure TFhirGroupCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|boolean|Quantity|Range', FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exclude', 'boolean', FExclude.Link));{2}
end;

procedure TFhirGroupCharacteristic.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then Code := propValue as TFhirCodeableConcept{4b}
  else if (propName.startsWith('value')) then Value := propValue as TFhirType{4}
  else if (propName = 'exclude') then ExcludeObject := propValue as TFhirBoolean{5a}
  else inherited;
end;

function TFhirGroupCharacteristic.FhirType : string;
begin
  result := 'characteristic';
end;

function TFhirGroupCharacteristic.Link : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(inherited Link);
end;

function TFhirGroupCharacteristic.Clone : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(inherited Clone);
end;

{ TFhirGroupCharacteristic }

Procedure TFhirGroupCharacteristic.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirGroupCharacteristic.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirGroupCharacteristic.SetExclude(value : TFhirBoolean);
begin
  FExclude.free;
  FExclude := value;
end;

Function TFhirGroupCharacteristic.GetExcludeST : Boolean;
begin
  if FExclude = nil then
    result := false
  else
    result := FExclude.value;
end;

Procedure TFhirGroupCharacteristic.SetExcludeST(value : Boolean);
begin
  if FExclude = nil then
    FExclude := TFhirBoolean.create;
  FExclude.value := value
end;


{ TFhirGroupCharacteristicListEnumerator }

Constructor TFhirGroupCharacteristicListEnumerator.Create(list : TFhirGroupCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirGroupCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGroupCharacteristicListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirGroupCharacteristicListEnumerator.GetCurrent : TFhirGroupCharacteristic;
begin
  Result := FList[FIndex];
end;


{ TFhirGroupCharacteristicList }
procedure TFhirGroupCharacteristicList.AddItem(value: TFhirGroupCharacteristic);
begin
  assert(value.ClassName = 'TFhirGroupCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGroupCharacteristic');
  add(value);
end;


function TFhirGroupCharacteristicList.Append: TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirGroupCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirGroupCharacteristicList.GetEnumerator : TFhirGroupCharacteristicListEnumerator;
begin
  result := TFhirGroupCharacteristicListEnumerator.Create(self.link);
end;

function TFhirGroupCharacteristicList.Clone: TFhirGroupCharacteristicList;
begin
  result := TFhirGroupCharacteristicList(inherited Clone);
end;

function TFhirGroupCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupCharacteristicList.GetItemN(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(ObjectByIndex[index]);
end;

function TFhirGroupCharacteristicList.IndexOf(value: TFhirGroupCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirGroupCharacteristicList.Insert(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirGroupCharacteristicList.InsertItem(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirGroupCharacteristicList.Item(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(ObjectByIndex[index]);
end;

function TFhirGroupCharacteristicList.Link: TFhirGroupCharacteristicList;
begin
  result := TFhirGroupCharacteristicList(inherited Link);
end;

procedure TFhirGroupCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupCharacteristicList.SetItemByIndex(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  FhirGroupCharacteristics[index] := value;
end;

procedure TFhirGroupCharacteristicList.SetItemN(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudySeries }

constructor TFhirImagingStudySeries.Create;
begin
  inherited;
  FInstanceList := TFhirImagingStudySeriesInstanceList.Create;
end;

destructor TFhirImagingStudySeries.Destroy;
begin
  FNumber.free;
  FModality.free;
  FUid.free;
  FDescription.free;
  FNumberOfInstances.free;
  FAvailability.free;
  FUrl.free;
  FBodySite.free;
  FDateTime.free;
  FInstanceList.Free;
  inherited;
end;

procedure TFhirImagingStudySeries.Assign(oSource : TAdvObject);
begin
  inherited;
  numberObject := TFhirImagingStudySeries(oSource).numberObject.Clone;
  FModality := TFhirImagingStudySeries(oSource).FModality.Link;
  uidObject := TFhirImagingStudySeries(oSource).uidObject.Clone;
  descriptionObject := TFhirImagingStudySeries(oSource).descriptionObject.Clone;
  numberOfInstancesObject := TFhirImagingStudySeries(oSource).numberOfInstancesObject.Clone;
  FAvailability := TFhirImagingStudySeries(oSource).FAvailability.Link;
  urlObject := TFhirImagingStudySeries(oSource).urlObject.Clone;
  bodySite := TFhirImagingStudySeries(oSource).bodySite.Clone;
  dateTimeObject := TFhirImagingStudySeries(oSource).dateTimeObject.Clone;
  FInstanceList.Assign(TFhirImagingStudySeries(oSource).FInstanceList);
end;

procedure TFhirImagingStudySeries.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(FNumber.Link);
  if (child_name = 'modality') Then
     list.add(FModality.Link);
  if (child_name = 'uid') Then
     list.add(FUid.Link);
  if (child_name = 'description') Then
     list.add(FDescription.Link);
  if (child_name = 'numberOfInstances') Then
     list.add(FNumberOfInstances.Link);
  if (child_name = 'availability') Then
     list.add(FAvailability.Link);
  if (child_name = 'url') Then
     list.add(FUrl.Link);
  if (child_name = 'bodySite') Then
     list.add(FBodySite.Link);
  if (child_name = 'dateTime') Then
     list.add(FDateTime.Link);
  if (child_name = 'instance') Then
     list.addAll(FInstanceList);
end;

procedure TFhirImagingStudySeries.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'integer', FNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modality', 'code', FModality.Link));{1}
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', FUid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfInstances', 'integer', FNumberOfInstances.Link));{2}
  oList.add(TFHIRProperty.create(self, 'availability', 'code', FAvailability.Link));{1}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'Coding', FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'dateTime', FDateTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'instance', '', FInstanceList.Link)){3};
end;

procedure TFhirImagingStudySeries.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'number') then NumberObject := propValue as TFhirInteger{5a}
  else if (propName = 'modality') then ModalityObject := propValue as TFHIREnum
  else if (propName = 'uid') then UidObject := propValue as TFhirOid{5a}
  else if (propName = 'description') then DescriptionObject := propValue as TFhirString{5a}
  else if (propName = 'numberOfInstances') then NumberOfInstancesObject := propValue as TFhirInteger{5a}
  else if (propName = 'availability') then AvailabilityObject := propValue as TFHIREnum
  else if (propName = 'url') then UrlObject := propValue as TFhirUri{5a}
  else if (propName = 'bodySite') then BodySite := propValue as TFhirCoding{4b}
  else if (propName = 'dateTime') then DateTimeObject := propValue as TFhirDateTime{5a}
  else if (propName = 'instance') then InstanceList.add(propValue as TFhirImagingStudySeriesInstance){2}
  else inherited;
end;

function TFhirImagingStudySeries.FhirType : string;
begin
  result := 'series';
end;

function TFhirImagingStudySeries.Link : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(inherited Link);
end;

function TFhirImagingStudySeries.Clone : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(inherited Clone);
end;

{ TFhirImagingStudySeries }

Procedure TFhirImagingStudySeries.SetNumber(value : TFhirInteger);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirImagingStudySeries.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

Procedure TFhirImagingStudySeries.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirInteger.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirImagingStudySeries.SetModality(value : TFhirEnum);
begin
  FModality.free;
  FModality := value;
end;

Function TFhirImagingStudySeries.GetModalityST : TFhirModality;
begin
  if FModality = nil then
    result := TFhirModality(0)
  else
    result := TFhirModality(StringArrayIndexOfSensitive(CODES_TFhirModality, FModality.value));
end;

Procedure TFhirImagingStudySeries.SetModalityST(value : TFhirModality);
begin
  if ord(value) = 0 then
    ModalityObject := nil
  else
    ModalityObject := TFhirEnum.create(CODES_TFhirModality[value]);
end;

Procedure TFhirImagingStudySeries.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingStudySeries.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingStudySeries.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingStudySeries.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImagingStudySeries.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImagingStudySeries.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImagingStudySeries.SetNumberOfInstances(value : TFhirInteger);
begin
  FNumberOfInstances.free;
  FNumberOfInstances := value;
end;

Function TFhirImagingStudySeries.GetNumberOfInstancesST : String;
begin
  if FNumberOfInstances = nil then
    result := ''
  else
    result := FNumberOfInstances.value;
end;

Procedure TFhirImagingStudySeries.SetNumberOfInstancesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfInstances = nil then
      FNumberOfInstances := TFhirInteger.create;
    FNumberOfInstances.value := value
  end
  else if FNumberOfInstances <> nil then
    FNumberOfInstances.value := '';
end;

Procedure TFhirImagingStudySeries.SetAvailability(value : TFhirEnum);
begin
  FAvailability.free;
  FAvailability := value;
end;

Function TFhirImagingStudySeries.GetAvailabilityST : TFhirInstanceAvailability;
begin
  if FAvailability = nil then
    result := TFhirInstanceAvailability(0)
  else
    result := TFhirInstanceAvailability(StringArrayIndexOfSensitive(CODES_TFhirInstanceAvailability, FAvailability.value));
end;

Procedure TFhirImagingStudySeries.SetAvailabilityST(value : TFhirInstanceAvailability);
begin
  if ord(value) = 0 then
    AvailabilityObject := nil
  else
    AvailabilityObject := TFhirEnum.create(CODES_TFhirInstanceAvailability[value]);
end;

Procedure TFhirImagingStudySeries.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirImagingStudySeries.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirImagingStudySeries.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirImagingStudySeries.SetBodySite(value : TFhirCoding);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirImagingStudySeries.SetDateTime(value : TFhirDateTime);
begin
  FDateTime.free;
  FDateTime := value;
end;

Function TFhirImagingStudySeries.GetDateTimeST : TDateTimeEx;
begin
  if FDateTime = nil then
    result := nil
  else
    result := FDateTime.value;
end;

Procedure TFhirImagingStudySeries.SetDateTimeST(value : TDateTimeEx);
begin
  if value <> nil then
  begin
    if FDateTime = nil then
      FDateTime := TFhirDateTime.create;
    FDateTime.value := value
  end
  else if FDateTime <> nil then
    FDateTime.value := nil;
end;


{ TFhirImagingStudySeriesListEnumerator }

Constructor TFhirImagingStudySeriesListEnumerator.Create(list : TFhirImagingStudySeriesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirImagingStudySeriesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudySeriesListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirImagingStudySeriesListEnumerator.GetCurrent : TFhirImagingStudySeries;
begin
  Result := FList[FIndex];
end;


{ TFhirImagingStudySeriesList }
procedure TFhirImagingStudySeriesList.AddItem(value: TFhirImagingStudySeries);
begin
  assert(value.ClassName = 'TFhirImagingStudySeries', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeries');
  add(value);
end;


function TFhirImagingStudySeriesList.Append: TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImagingStudySeriesList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesList.GetEnumerator : TFhirImagingStudySeriesListEnumerator;
begin
  result := TFhirImagingStudySeriesListEnumerator.Create(self.link);
end;

function TFhirImagingStudySeriesList.Clone: TFhirImagingStudySeriesList;
begin
  result := TFhirImagingStudySeriesList(inherited Clone);
end;

function TFhirImagingStudySeriesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesList.GetItemN(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesList.IndexOf(value: TFhirImagingStudySeries): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImagingStudySeriesList.Insert(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImagingStudySeriesList.InsertItem(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesList.Item(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesList.Link: TFhirImagingStudySeriesList;
begin
  result := TFhirImagingStudySeriesList(inherited Link);
end;

procedure TFhirImagingStudySeriesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  FhirImagingStudySeries[index] := value;
end;

procedure TFhirImagingStudySeriesList.SetItemN(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudySeriesInstance }

constructor TFhirImagingStudySeriesInstance.Create;
begin
  inherited;
end;

destructor TFhirImagingStudySeriesInstance.Destroy;
begin
  FNumber.free;
  FUid.free;
  FSopclass.free;
  FType_.free;
  FTitle.free;
  FUrl.free;
  FAttachment.free;
  inherited;
end;

procedure TFhirImagingStudySeriesInstance.Assign(oSource : TAdvObject);
begin
  inherited;
  numberObject := TFhirImagingStudySeriesInstance(oSource).numberObject.Clone;
  uidObject := TFhirImagingStudySeriesInstance(oSource).uidObject.Clone;
  sopclassObject := TFhirImagingStudySeriesInstance(oSource).sopclassObject.Clone;
  type_Object := TFhirImagingStudySeriesInstance(oSource).type_Object.Clone;
  titleObject := TFhirImagingStudySeriesInstance(oSource).titleObject.Clone;
  urlObject := TFhirImagingStudySeriesInstance(oSource).urlObject.Clone;
  attachment := TFhirImagingStudySeriesInstance(oSource).attachment.Clone;
end;

procedure TFhirImagingStudySeriesInstance.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(FNumber.Link);
  if (child_name = 'uid') Then
     list.add(FUid.Link);
  if (child_name = 'sopclass') Then
     list.add(FSopclass.Link);
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'title') Then
     list.add(FTitle.Link);
  if (child_name = 'url') Then
     list.add(FUrl.Link);
  if (child_name = 'attachment') Then
     list.add(FAttachment.Link);
end;

procedure TFhirImagingStudySeriesInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'integer', FNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', FUid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sopclass', 'oid', FSopclass.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'string', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'attachment', 'Resource(Any)', FAttachment.Link));{2}
end;

procedure TFhirImagingStudySeriesInstance.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'number') then NumberObject := propValue as TFhirInteger{5a}
  else if (propName = 'uid') then UidObject := propValue as TFhirOid{5a}
  else if (propName = 'sopclass') then SopclassObject := propValue as TFhirOid{5a}
  else if (propName = 'type') then Type_Object := propValue as TFhirString{5a}
  else if (propName = 'title') then TitleObject := propValue as TFhirString{5a}
  else if (propName = 'url') then UrlObject := propValue as TFhirUri{5a}
  else if (propName = 'attachment') then Attachment := propValue as TFhirResourceReference{Resource}{4b}
  else inherited;
end;

function TFhirImagingStudySeriesInstance.FhirType : string;
begin
  result := 'instance';
end;

function TFhirImagingStudySeriesInstance.Link : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(inherited Link);
end;

function TFhirImagingStudySeriesInstance.Clone : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(inherited Clone);
end;

{ TFhirImagingStudySeriesInstance }

Procedure TFhirImagingStudySeriesInstance.SetNumber(value : TFhirInteger);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirImagingStudySeriesInstance.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirInteger.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingStudySeriesInstance.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetSopclass(value : TFhirOid);
begin
  FSopclass.free;
  FSopclass := value;
end;

Function TFhirImagingStudySeriesInstance.GetSopclassST : String;
begin
  if FSopclass = nil then
    result := ''
  else
    result := FSopclass.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetSopclassST(value : String);
begin
  if value <> '' then
  begin
    if FSopclass = nil then
      FSopclass := TFhirOid.create;
    FSopclass.value := value
  end
  else if FSopclass <> nil then
    FSopclass.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirImagingStudySeriesInstance.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirImagingStudySeriesInstance.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirImagingStudySeriesInstance.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetAttachment(value : TFhirResourceReference{Resource});
begin
  FAttachment.free;
  FAttachment := value;
end;


{ TFhirImagingStudySeriesInstanceListEnumerator }

Constructor TFhirImagingStudySeriesInstanceListEnumerator.Create(list : TFhirImagingStudySeriesInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirImagingStudySeriesInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudySeriesInstanceListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirImagingStudySeriesInstanceListEnumerator.GetCurrent : TFhirImagingStudySeriesInstance;
begin
  Result := FList[FIndex];
end;


{ TFhirImagingStudySeriesInstanceList }
procedure TFhirImagingStudySeriesInstanceList.AddItem(value: TFhirImagingStudySeriesInstance);
begin
  assert(value.ClassName = 'TFhirImagingStudySeriesInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeriesInstance');
  add(value);
end;


function TFhirImagingStudySeriesInstanceList.Append: TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImagingStudySeriesInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesInstanceList.GetEnumerator : TFhirImagingStudySeriesInstanceListEnumerator;
begin
  result := TFhirImagingStudySeriesInstanceListEnumerator.Create(self.link);
end;

function TFhirImagingStudySeriesInstanceList.Clone: TFhirImagingStudySeriesInstanceList;
begin
  result := TFhirImagingStudySeriesInstanceList(inherited Clone);
end;

function TFhirImagingStudySeriesInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesInstanceList.GetItemN(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesInstanceList.IndexOf(value: TFhirImagingStudySeriesInstance): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImagingStudySeriesInstanceList.Insert(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImagingStudySeriesInstanceList.InsertItem(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesInstanceList.Item(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesInstanceList.Link: TFhirImagingStudySeriesInstanceList;
begin
  result := TFhirImagingStudySeriesInstanceList(inherited Link);
end;

procedure TFhirImagingStudySeriesInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesInstanceList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  FhirImagingStudySeriesInstances[index] := value;
end;

procedure TFhirImagingStudySeriesInstanceList.SetItemN(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationExplanation }

constructor TFhirImmunizationExplanation.Create;
begin
  inherited;
  FReasonList := TFhirCodeableConceptList.Create;
  FRefusalReasonList := TFhirCodeableConceptList.Create;
end;

destructor TFhirImmunizationExplanation.Destroy;
begin
  FReasonList.Free;
  FRefusalReasonList.Free;
  inherited;
end;

procedure TFhirImmunizationExplanation.Assign(oSource : TAdvObject);
begin
  inherited;
  FReasonList.Assign(TFhirImmunizationExplanation(oSource).FReasonList);
  FRefusalReasonList.Assign(TFhirImmunizationExplanation(oSource).FRefusalReasonList);
end;

procedure TFhirImmunizationExplanation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'reason') Then
     list.addAll(FReasonList);
  if (child_name = 'refusalReason') Then
     list.addAll(FRefusalReasonList);
end;

procedure TFhirImmunizationExplanation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'refusalReason', 'CodeableConcept', FRefusalReasonList.Link)){3};
end;

procedure TFhirImmunizationExplanation.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'reason') then ReasonList.add(propValue as TFhirCodeableConcept){2}
  else if (propName = 'refusalReason') then RefusalReasonList.add(propValue as TFhirCodeableConcept){2}
  else inherited;
end;

function TFhirImmunizationExplanation.FhirType : string;
begin
  result := 'explanation';
end;

function TFhirImmunizationExplanation.Link : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(inherited Link);
end;

function TFhirImmunizationExplanation.Clone : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(inherited Clone);
end;

{ TFhirImmunizationExplanation }


{ TFhirImmunizationExplanationListEnumerator }

Constructor TFhirImmunizationExplanationListEnumerator.Create(list : TFhirImmunizationExplanationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirImmunizationExplanationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationExplanationListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirImmunizationExplanationListEnumerator.GetCurrent : TFhirImmunizationExplanation;
begin
  Result := FList[FIndex];
end;


{ TFhirImmunizationExplanationList }
procedure TFhirImmunizationExplanationList.AddItem(value: TFhirImmunizationExplanation);
begin
  assert(value.ClassName = 'TFhirImmunizationExplanation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationExplanation');
  add(value);
end;


function TFhirImmunizationExplanationList.Append: TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationExplanationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationExplanationList.GetEnumerator : TFhirImmunizationExplanationListEnumerator;
begin
  result := TFhirImmunizationExplanationListEnumerator.Create(self.link);
end;

function TFhirImmunizationExplanationList.Clone: TFhirImmunizationExplanationList;
begin
  result := TFhirImmunizationExplanationList(inherited Clone);
end;

function TFhirImmunizationExplanationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationExplanationList.GetItemN(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(ObjectByIndex[index]);
end;

function TFhirImmunizationExplanationList.IndexOf(value: TFhirImmunizationExplanation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationExplanationList.Insert(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationExplanationList.InsertItem(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationExplanationList.Item(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(ObjectByIndex[index]);
end;

function TFhirImmunizationExplanationList.Link: TFhirImmunizationExplanationList;
begin
  result := TFhirImmunizationExplanationList(inherited Link);
end;

procedure TFhirImmunizationExplanationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationExplanationList.SetItemByIndex(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  FhirImmunizationExplanations[index] := value;
end;

procedure TFhirImmunizationExplanationList.SetItemN(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationReaction }

constructor TFhirImmunizationReaction.Create;
begin
  inherited;
end;

destructor TFhirImmunizationReaction.Destroy;
begin
  FDate.free;
  FDetail.free;
  FReported.free;
  inherited;
end;

procedure TFhirImmunizationReaction.Assign(oSource : TAdvObject);
begin
  inherited;
  dateObject := TFhirImmunizationReaction(oSource).dateObject.Clone;
  detail := TFhirImmunizationReaction(oSource).detail.Clone;
  reportedObject := TFhirImmunizationReaction(oSource).reportedObject.Clone;
end;

procedure TFhirImmunizationReaction.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(FDate.Link);
  if (child_name = 'detail') Then
     list.add(FDetail.Link);
  if (child_name = 'reported') Then
     list.add(FReported.Link);
end;

procedure TFhirImmunizationReaction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Resource(AdverseReaction|Observation)', FDetail.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reported', 'boolean', FReported.Link));{2}
end;

procedure TFhirImmunizationReaction.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'date') then DateObject := propValue as TFhirDateTime{5a}
  else if (propName = 'detail') then Detail := propValue as TFhirResourceReference{Resource}{4b}
  else if (propName = 'reported') then ReportedObject := propValue as TFhirBoolean{5a}
  else inherited;
end;

function TFhirImmunizationReaction.FhirType : string;
begin
  result := 'reaction';
end;

function TFhirImmunizationReaction.Link : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(inherited Link);
end;

function TFhirImmunizationReaction.Clone : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(inherited Clone);
end;

{ TFhirImmunizationReaction }

Procedure TFhirImmunizationReaction.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirImmunizationReaction.GetDateST : TDateTimeEx;
begin
  if FDate = nil then
    result := nil
  else
    result := FDate.value;
end;

Procedure TFhirImmunizationReaction.SetDateST(value : TDateTimeEx);
begin
  if value <> nil then
  begin
    if FDate = nil then
      FDate := TFhirDateTime.create;
    FDate.value := value
  end
  else if FDate <> nil then
    FDate.value := nil;
end;

Procedure TFhirImmunizationReaction.SetDetail(value : TFhirResourceReference{Resource});
begin
  FDetail.free;
  FDetail := value;
end;

Procedure TFhirImmunizationReaction.SetReported(value : TFhirBoolean);
begin
  FReported.free;
  FReported := value;
end;

Function TFhirImmunizationReaction.GetReportedST : Boolean;
begin
  if FReported = nil then
    result := false
  else
    result := FReported.value;
end;

Procedure TFhirImmunizationReaction.SetReportedST(value : Boolean);
begin
  if FReported = nil then
    FReported := TFhirBoolean.create;
  FReported.value := value
end;


{ TFhirImmunizationReactionListEnumerator }

Constructor TFhirImmunizationReactionListEnumerator.Create(list : TFhirImmunizationReactionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirImmunizationReactionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationReactionListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirImmunizationReactionListEnumerator.GetCurrent : TFhirImmunizationReaction;
begin
  Result := FList[FIndex];
end;


{ TFhirImmunizationReactionList }
procedure TFhirImmunizationReactionList.AddItem(value: TFhirImmunizationReaction);
begin
  assert(value.ClassName = 'TFhirImmunizationReaction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationReaction');
  add(value);
end;


function TFhirImmunizationReactionList.Append: TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationReactionList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationReactionList.GetEnumerator : TFhirImmunizationReactionListEnumerator;
begin
  result := TFhirImmunizationReactionListEnumerator.Create(self.link);
end;

function TFhirImmunizationReactionList.Clone: TFhirImmunizationReactionList;
begin
  result := TFhirImmunizationReactionList(inherited Clone);
end;

function TFhirImmunizationReactionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationReactionList.GetItemN(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(ObjectByIndex[index]);
end;

function TFhirImmunizationReactionList.IndexOf(value: TFhirImmunizationReaction): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationReactionList.Insert(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationReactionList.InsertItem(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  Inherited Insert(index, value);
end;

function TFhirImmunizationReactionList.Item(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(ObjectByIndex[index]);
end;

function TFhirImmunizationReactionList.Link: TFhirImmunizationReactionList;
begin
  result := TFhirImmunizationReactionList(inherited Link);
end;

procedure TFhirImmunizationReactionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationReactionList.SetItemByIndex(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  FhirImmunizationReactions[index] := value;
end;

procedure TFhirImmunizationReactionList.SetItemN(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationVaccinationProtocol }

constructor TFhirImmunizationVaccinationProtocol.Create;
begin
  inherited;
end;

destructor TFhirImmunizationVaccinationProtocol.Destroy;
begin
  FDoseSequence.free;
  FDescription.free;
  FAuthority.free;
  FSeries.free;
  FSeriesDoses.free;
  FDoseTarget.free;
  FDoseStatus.free;
  FDoseStatusReason.free;
  inherited;
end;

procedure TFhirImmunizationVaccinationProtocol.Assign(oSource : TAdvObject);
begin
  inherited;
  doseSequenceObject := TFhirImmunizationVaccinationProtocol(oSource).doseSequenceObject.Clone;
  descriptionObject := TFhirImmunizationVaccinationProtocol(oSource).descriptionObject.Clone;
  authority := TFhirImmunizationVaccinationProtocol(oSource).authority.Clone;
  seriesObject := TFhirImmunizationVaccinationProtocol(oSource).seriesObject.Clone;
  seriesDosesObject := TFhirImmunizationVaccinationProtocol(oSource).seriesDosesObject.Clone;
  doseTarget := TFhirImmunizationVaccinationProtocol(oSource).doseTarget.Clone;
  doseStatus := TFhirImmunizationVaccinationProtocol(oSource).doseStatus.Clone;
  doseStatusReason := TFhirImmunizationVaccinationProtocol(oSource).doseStatusReason.Clone;
end;

procedure TFhirImmunizationVaccinationProtocol.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'doseSequence') Then
     list.add(FDoseSequence.Link);
  if (child_name = 'description') Then
     list.add(FDescription.Link);
  if (child_name = 'authority') Then
     list.add(FAuthority.Link);
  if (child_name = 'series') Then
     list.add(FSeries.Link);
  if (child_name = 'seriesDoses') Then
     list.add(FSeriesDoses.Link);
  if (child_name = 'doseTarget') Then
     list.add(FDoseTarget.Link);
  if (child_name = 'doseStatus') Then
     list.add(FDoseStatus.Link);
  if (child_name = 'doseStatusReason') Then
     list.add(FDoseStatusReason.Link);
end;

procedure TFhirImmunizationVaccinationProtocol.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'doseSequence', 'integer', FDoseSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authority', 'Resource(Organization)', FAuthority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'series', 'string', FSeries.Link));{2}
  oList.add(TFHIRProperty.create(self, 'seriesDoses', 'integer', FSeriesDoses.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseTarget', 'CodeableConcept', FDoseTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseStatus', 'CodeableConcept', FDoseStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseStatusReason', 'CodeableConcept', FDoseStatusReason.Link));{2}
end;

procedure TFhirImmunizationVaccinationProtocol.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'doseSequence') then DoseSequenceObject := propValue as TFhirInteger{5a}
  else if (propName = 'description') then DescriptionObject := propValue as TFhirString{5a}
  else if (propName = 'authority') then Authority := propValue as TFhirResourceReference{TFhirOrganization}{4b}
  else if (propName = 'series') then SeriesObject := propValue as TFhirString{5a}
  else if (propName = 'seriesDoses') then SeriesDosesObject := propValue as TFhirInteger{5a}
  else if (propName = 'doseTarget') then DoseTarget := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'doseStatus') then DoseStatus := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'doseStatusReason') then DoseStatusReason := propValue as TFhirCodeableConcept{4b}
  else inherited;
end;

function TFhirImmunizationVaccinationProtocol.FhirType : string;
begin
  result := 'vaccinationProtocol';
end;

function TFhirImmunizationVaccinationProtocol.Link : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(inherited Link);
end;

function TFhirImmunizationVaccinationProtocol.Clone : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(inherited Clone);
end;

{ TFhirImmunizationVaccinationProtocol }

Procedure TFhirImmunizationVaccinationProtocol.SetDoseSequence(value : TFhirInteger);
begin
  FDoseSequence.free;
  FDoseSequence := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetDoseSequenceST : String;
begin
  if FDoseSequence = nil then
    result := ''
  else
    result := FDoseSequence.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDoseSequence = nil then
      FDoseSequence := TFhirInteger.create;
    FDoseSequence.value := value
  end
  else if FDoseSequence <> nil then
    FDoseSequence.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetAuthority(value : TFhirResourceReference{TFhirOrganization});
begin
  FAuthority.free;
  FAuthority := value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := FSeries.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesDoses(value : TFhirInteger);
begin
  FSeriesDoses.free;
  FSeriesDoses := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetSeriesDosesST : String;
begin
  if FSeriesDoses = nil then
    result := ''
  else
    result := FSeriesDoses.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesDosesST(value : String);
begin
  if value <> '' then
  begin
    if FSeriesDoses = nil then
      FSeriesDoses := TFhirInteger.create;
    FSeriesDoses.value := value
  end
  else if FSeriesDoses <> nil then
    FSeriesDoses.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseTarget(value : TFhirCodeableConcept);
begin
  FDoseTarget.free;
  FDoseTarget := value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseStatus(value : TFhirCodeableConcept);
begin
  FDoseStatus.free;
  FDoseStatus := value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseStatusReason(value : TFhirCodeableConcept);
begin
  FDoseStatusReason.free;
  FDoseStatusReason := value;
end;


{ TFhirImmunizationVaccinationProtocolListEnumerator }

Constructor TFhirImmunizationVaccinationProtocolListEnumerator.Create(list : TFhirImmunizationVaccinationProtocolList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirImmunizationVaccinationProtocolListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationVaccinationProtocolListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirImmunizationVaccinationProtocolListEnumerator.GetCurrent : TFhirImmunizationVaccinationProtocol;
begin
  Result := FList[FIndex];
end;


{ TFhirImmunizationVaccinationProtocolList }
procedure TFhirImmunizationVaccinationProtocolList.AddItem(value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value.ClassName = 'TFhirImmunizationVaccinationProtocol', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationVaccinationProtocol');
  add(value);
end;


function TFhirImmunizationVaccinationProtocolList.Append: TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationVaccinationProtocolList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationVaccinationProtocolList.GetEnumerator : TFhirImmunizationVaccinationProtocolListEnumerator;
begin
  result := TFhirImmunizationVaccinationProtocolListEnumerator.Create(self.link);
end;

function TFhirImmunizationVaccinationProtocolList.Clone: TFhirImmunizationVaccinationProtocolList;
begin
  result := TFhirImmunizationVaccinationProtocolList(inherited Clone);
end;

function TFhirImmunizationVaccinationProtocolList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationVaccinationProtocolList.GetItemN(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationVaccinationProtocolList.IndexOf(value: TFhirImmunizationVaccinationProtocol): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationVaccinationProtocolList.Insert(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationVaccinationProtocolList.InsertItem(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  Inherited Insert(index, value);
end;

function TFhirImmunizationVaccinationProtocolList.Item(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationVaccinationProtocolList.Link: TFhirImmunizationVaccinationProtocolList;
begin
  result := TFhirImmunizationVaccinationProtocolList(inherited Link);
end;

procedure TFhirImmunizationVaccinationProtocolList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationVaccinationProtocolList.SetItemByIndex(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  FhirImmunizationVaccinationProtocols[index] := value;
end;

procedure TFhirImmunizationVaccinationProtocolList.SetItemN(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendationRecommendation }

constructor TFhirImmunizationRecommendationRecommendation.Create;
begin
  inherited;
  FDateCriterionList := TFhirImmunizationRecommendationRecommendationDateCriterionList.Create;
  FSupportingImmunizationList := TFhirResourceReferenceList{TFhirImmunization}.Create;
  FSupportingPatientInformationList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirImmunizationRecommendationRecommendation.Destroy;
begin
  FDate.free;
  FVaccineType.free;
  FDoseNumber.free;
  FForecastStatus.free;
  FDateCriterionList.Free;
  FProtocol.free;
  FSupportingImmunizationList.Free;
  FSupportingPatientInformationList.Free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendation.Assign(oSource : TAdvObject);
begin
  inherited;
  dateObject := TFhirImmunizationRecommendationRecommendation(oSource).dateObject.Clone;
  vaccineType := TFhirImmunizationRecommendationRecommendation(oSource).vaccineType.Clone;
  doseNumberObject := TFhirImmunizationRecommendationRecommendation(oSource).doseNumberObject.Clone;
  forecastStatus := TFhirImmunizationRecommendationRecommendation(oSource).forecastStatus.Clone;
  FDateCriterionList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FDateCriterionList);
  protocol := TFhirImmunizationRecommendationRecommendation(oSource).protocol.Clone;
  FSupportingImmunizationList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FSupportingImmunizationList);
  FSupportingPatientInformationList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FSupportingPatientInformationList);
end;

procedure TFhirImmunizationRecommendationRecommendation.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(FDate.Link);
  if (child_name = 'vaccineType') Then
     list.add(FVaccineType.Link);
  if (child_name = 'doseNumber') Then
     list.add(FDoseNumber.Link);
  if (child_name = 'forecastStatus') Then
     list.add(FForecastStatus.Link);
  if (child_name = 'dateCriterion') Then
     list.addAll(FDateCriterionList);
  if (child_name = 'protocol') Then
     list.add(FProtocol.Link);
  if (child_name = 'supportingImmunization') Then
     list.addAll(FSupportingImmunizationList);
  if (child_name = 'supportingPatientInformation') Then
     list.addAll(FSupportingPatientInformationList);
end;

procedure TFhirImmunizationRecommendationRecommendation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'vaccineType', 'CodeableConcept', FVaccineType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseNumber', 'integer', FDoseNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'forecastStatus', 'CodeableConcept', FForecastStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateCriterion', '', FDateCriterionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'protocol', '', FProtocol.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supportingImmunization', 'Resource(Immunization)', FSupportingImmunizationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingPatientInformation', 'Resource(Observation|AdverseReaction|AllergyIntolerance)', FSupportingPatientInformationList.Link)){3};
end;

procedure TFhirImmunizationRecommendationRecommendation.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'date') then DateObject := propValue as TFhirDateTime{5a}
  else if (propName = 'vaccineType') then VaccineType := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'doseNumber') then DoseNumberObject := propValue as TFhirInteger{5a}
  else if (propName = 'forecastStatus') then ForecastStatus := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'dateCriterion') then DateCriterionList.add(propValue as TFhirImmunizationRecommendationRecommendationDateCriterion){2}
  else if (propName = 'protocol') then Protocol := propValue as TFhirImmunizationRecommendationRecommendationProtocol{4b}
  else if (propName = 'supportingImmunization') then SupportingImmunizationList.add(propValue as TFhirResourceReference{TFhirImmunization}){2}
  else if (propName = 'supportingPatientInformation') then SupportingPatientInformationList.add(propValue as TFhirResourceReference{Resource}){2}
  else inherited;
end;

function TFhirImmunizationRecommendationRecommendation.FhirType : string;
begin
  result := 'recommendation';
end;

function TFhirImmunizationRecommendationRecommendation.Link : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendation.Clone : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(inherited Clone);
end;

{ TFhirImmunizationRecommendationRecommendation }

Procedure TFhirImmunizationRecommendationRecommendation.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirImmunizationRecommendationRecommendation.GetDateST : TDateTimeEx;
begin
  if FDate = nil then
    result := nil
  else
    result := FDate.value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetDateST(value : TDateTimeEx);
begin
  if value <> nil then
  begin
    if FDate = nil then
      FDate := TFhirDateTime.create;
    FDate.value := value
  end
  else if FDate <> nil then
    FDate.value := nil;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetVaccineType(value : TFhirCodeableConcept);
begin
  FVaccineType.free;
  FVaccineType := value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetDoseNumber(value : TFhirInteger);
begin
  FDoseNumber.free;
  FDoseNumber := value;
end;

Function TFhirImmunizationRecommendationRecommendation.GetDoseNumberST : String;
begin
  if FDoseNumber = nil then
    result := ''
  else
    result := FDoseNumber.value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetDoseNumberST(value : String);
begin
  if value <> '' then
  begin
    if FDoseNumber = nil then
      FDoseNumber := TFhirInteger.create;
    FDoseNumber.value := value
  end
  else if FDoseNumber <> nil then
    FDoseNumber.value := '';
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetForecastStatus(value : TFhirCodeableConcept);
begin
  FForecastStatus.free;
  FForecastStatus := value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetProtocol(value : TFhirImmunizationRecommendationRecommendationProtocol);
begin
  FProtocol.free;
  FProtocol := value;
end;


{ TFhirImmunizationRecommendationRecommendationListEnumerator }

Constructor TFhirImmunizationRecommendationRecommendationListEnumerator.Create(list : TFhirImmunizationRecommendationRecommendationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirImmunizationRecommendationRecommendationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirImmunizationRecommendationRecommendationListEnumerator.GetCurrent : TFhirImmunizationRecommendationRecommendation;
begin
  Result := FList[FIndex];
end;


{ TFhirImmunizationRecommendationRecommendationList }
procedure TFhirImmunizationRecommendationRecommendationList.AddItem(value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendation');
  add(value);
end;


function TFhirImmunizationRecommendationRecommendationList.Append: TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationRecommendationRecommendationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationList.GetEnumerator : TFhirImmunizationRecommendationRecommendationListEnumerator;
begin
  result := TFhirImmunizationRecommendationRecommendationListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationRecommendationList.Clone: TFhirImmunizationRecommendationRecommendationList;
begin
  result := TFhirImmunizationRecommendationRecommendationList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationList.IndexOf(value: TFhirImmunizationRecommendationRecommendation): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationRecommendationRecommendationList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationRecommendationRecommendationList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationList.Item(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationList.Link: TFhirImmunizationRecommendationRecommendationList;
begin
  result := TFhirImmunizationRecommendationRecommendationList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  FhirImmunizationRecommendationRecommendations[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterion }

constructor TFhirImmunizationRecommendationRecommendationDateCriterion.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendationRecommendationDateCriterion.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirImmunizationRecommendationRecommendationDateCriterion(oSource).code.Clone;
  valueObject := TFhirImmunizationRecommendationRecommendationDateCriterion(oSource).valueObject.Clone;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'value') Then
     list.add(FValue.Link);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'dateTime', FValue.Link));{2}
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then Code := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'value') then ValueObject := propValue as TFhirDateTime{5a}
  else inherited;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.FhirType : string;
begin
  result := 'dateCriterion';
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.Link : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.Clone : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(inherited Clone);
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterion }

Procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetValue(value : TFhirDateTime);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirImmunizationRecommendationRecommendationDateCriterion.GetValueST : TDateTimeEx;
begin
  if FValue = nil then
    result := nil
  else
    result := FValue.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetValueST(value : TDateTimeEx);
begin
  if value <> nil then
  begin
    if FValue = nil then
      FValue := TFhirDateTime.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := nil;
end;


{ TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator }

Constructor TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Create(list : TFhirImmunizationRecommendationRecommendationDateCriterionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.GetCurrent : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  Result := FList[FIndex];
end;


{ TFhirImmunizationRecommendationRecommendationDateCriterionList }
procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.AddItem(value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendationDateCriterion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendationDateCriterion');
  add(value);
end;


function TFhirImmunizationRecommendationRecommendationDateCriterionList.Append: TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.GetEnumerator : TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Clone: TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.IndexOf(value: TFhirImmunizationRecommendationRecommendationDateCriterion): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationRecommendationRecommendationDateCriterionList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Item(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Link: TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  FhirImmunizationRecommendationRecommendationDateCriterions[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendationRecommendationProtocol }

constructor TFhirImmunizationRecommendationRecommendationProtocol.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendationRecommendationProtocol.Destroy;
begin
  FDoseSequence.free;
  FDescription.free;
  FAuthority.free;
  FSeries.free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.Assign(oSource : TAdvObject);
begin
  inherited;
  doseSequenceObject := TFhirImmunizationRecommendationRecommendationProtocol(oSource).doseSequenceObject.Clone;
  descriptionObject := TFhirImmunizationRecommendationRecommendationProtocol(oSource).descriptionObject.Clone;
  authority := TFhirImmunizationRecommendationRecommendationProtocol(oSource).authority.Clone;
  seriesObject := TFhirImmunizationRecommendationRecommendationProtocol(oSource).seriesObject.Clone;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'doseSequence') Then
     list.add(FDoseSequence.Link);
  if (child_name = 'description') Then
     list.add(FDescription.Link);
  if (child_name = 'authority') Then
     list.add(FAuthority.Link);
  if (child_name = 'series') Then
     list.add(FSeries.Link);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'doseSequence', 'integer', FDoseSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authority', 'Resource(Organization)', FAuthority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'series', 'string', FSeries.Link));{2}
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'doseSequence') then DoseSequenceObject := propValue as TFhirInteger{5a}
  else if (propName = 'description') then DescriptionObject := propValue as TFhirString{5a}
  else if (propName = 'authority') then Authority := propValue as TFhirResourceReference{TFhirOrganization}{4b}
  else if (propName = 'series') then SeriesObject := propValue as TFhirString{5a}
  else inherited;
end;

function TFhirImmunizationRecommendationRecommendationProtocol.FhirType : string;
begin
  result := 'protocol';
end;

function TFhirImmunizationRecommendationRecommendationProtocol.Link : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendationProtocol.Clone : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(inherited Clone);
end;

{ TFhirImmunizationRecommendationRecommendationProtocol }

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDoseSequence(value : TFhirInteger);
begin
  FDoseSequence.free;
  FDoseSequence := value;
end;

Function TFhirImmunizationRecommendationRecommendationProtocol.GetDoseSequenceST : String;
begin
  if FDoseSequence = nil then
    result := ''
  else
    result := FDoseSequence.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDoseSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDoseSequence = nil then
      FDoseSequence := TFhirInteger.create;
    FDoseSequence.value := value
  end
  else if FDoseSequence <> nil then
    FDoseSequence.value := '';
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImmunizationRecommendationRecommendationProtocol.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetAuthority(value : TFhirResourceReference{TFhirOrganization});
begin
  FAuthority.free;
  FAuthority := value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value;
end;

Function TFhirImmunizationRecommendationRecommendationProtocol.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := FSeries.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;


{ TFhirImmunizationRecommendationRecommendationProtocolListEnumerator }

Constructor TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.Create(list : TFhirImmunizationRecommendationRecommendationProtocolList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.GetCurrent : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  Result := FList[FIndex];
end;


{ TFhirImmunizationRecommendationRecommendationProtocolList }
procedure TFhirImmunizationRecommendationRecommendationProtocolList.AddItem(value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendationProtocol', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendationProtocol');
  add(value);
end;


function TFhirImmunizationRecommendationRecommendationProtocolList.Append: TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationRecommendationRecommendationProtocolList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.GetEnumerator : TFhirImmunizationRecommendationRecommendationProtocolListEnumerator;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Clone: TFhirImmunizationRecommendationRecommendationProtocolList;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocolList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.IndexOf(value: TFhirImmunizationRecommendationRecommendationProtocol): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirImmunizationRecommendationRecommendationProtocolList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirImmunizationRecommendationRecommendationProtocolList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationProtocol);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Item(index: Integer): TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Link: TFhirImmunizationRecommendationRecommendationProtocolList;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocolList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationProtocol);
  FhirImmunizationRecommendationRecommendationProtocols[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationProtocol);
  ObjectByIndex[index] := value;
end;

{ TFhirListEntry }

constructor TFhirListEntry.Create;
begin
  inherited;
  FFlagList := TFhirCodeableConceptList.Create;
end;

destructor TFhirListEntry.Destroy;
begin
  FFlagList.Free;
  FDeleted.free;
  FDate.free;
  FItem.free;
  inherited;
end;

procedure TFhirListEntry.Assign(oSource : TAdvObject);
begin
  inherited;
  FFlagList.Assign(TFhirListEntry(oSource).FFlagList);
  deletedObject := TFhirListEntry(oSource).deletedObject.Clone;
  dateObject := TFhirListEntry(oSource).dateObject.Clone;
  item := TFhirListEntry(oSource).item.Clone;
end;

procedure TFhirListEntry.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'flag') Then
     list.addAll(FFlagList);
  if (child_name = 'deleted') Then
     list.add(FDeleted.Link);
  if (child_name = 'date') Then
     list.add(FDate.Link);
  if (child_name = 'item') Then
     list.add(FItem.Link);
end;

procedure TFhirListEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'flag', 'CodeableConcept', FFlagList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'deleted', 'boolean', FDeleted.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', 'Resource(Any)', FItem.Link));{2}
end;

procedure TFhirListEntry.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'flag') then FlagList.add(propValue as TFhirCodeableConcept){2}
  else if (propName = 'deleted') then DeletedObject := propValue as TFhirBoolean{5a}
  else if (propName = 'date') then DateObject := propValue as TFhirDateTime{5a}
  else if (propName = 'item') then Item := propValue as TFhirResourceReference{Resource}{4b}
  else inherited;
end;

function TFhirListEntry.FhirType : string;
begin
  result := 'entry';
end;

function TFhirListEntry.Link : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Link);
end;

function TFhirListEntry.Clone : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Clone);
end;

{ TFhirListEntry }

Procedure TFhirListEntry.SetDeleted(value : TFhirBoolean);
begin
  FDeleted.free;
  FDeleted := value;
end;

Function TFhirListEntry.GetDeletedST : Boolean;
begin
  if FDeleted = nil then
    result := false
  else
    result := FDeleted.value;
end;

Procedure TFhirListEntry.SetDeletedST(value : Boolean);
begin
  if FDeleted = nil then
    FDeleted := TFhirBoolean.create;
  FDeleted.value := value
end;

Procedure TFhirListEntry.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirListEntry.GetDateST : TDateTimeEx;
begin
  if FDate = nil then
    result := nil
  else
    result := FDate.value;
end;

Procedure TFhirListEntry.SetDateST(value : TDateTimeEx);
begin
  if value <> nil then
  begin
    if FDate = nil then
      FDate := TFhirDateTime.create;
    FDate.value := value
  end
  else if FDate <> nil then
    FDate.value := nil;
end;

Procedure TFhirListEntry.SetItem(value : TFhirResourceReference{Resource});
begin
  FItem.free;
  FItem := value;
end;


{ TFhirListEntryListEnumerator }

Constructor TFhirListEntryListEnumerator.Create(list : TFhirListEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirListEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirListEntryListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirListEntryListEnumerator.GetCurrent : TFhirListEntry;
begin
  Result := FList[FIndex];
end;


{ TFhirListEntryList }
procedure TFhirListEntryList.AddItem(value: TFhirListEntry);
begin
  assert(value.ClassName = 'TFhirListEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirListEntry');
  add(value);
end;


function TFhirListEntryList.Append: TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirListEntryList.ClearItems;
begin
  Clear;
end;

function TFhirListEntryList.GetEnumerator : TFhirListEntryListEnumerator;
begin
  result := TFhirListEntryListEnumerator.Create(self.link);
end;

function TFhirListEntryList.Clone: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Clone);
end;

function TFhirListEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirListEntryList.GetItemN(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.IndexOf(value: TFhirListEntry): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirListEntryList.Insert(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirListEntryList.InsertItem(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  Inherited Insert(index, value);
end;

function TFhirListEntryList.Item(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.Link: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Link);
end;

procedure TFhirListEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirListEntryList.SetItemByIndex(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  FhirListEntries[index] := value;
end;

procedure TFhirListEntryList.SetItemN(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirLocationPosition }

constructor TFhirLocationPosition.Create;
begin
  inherited;
end;

destructor TFhirLocationPosition.Destroy;
begin
  FLongitude.free;
  FLatitude.free;
  FAltitude.free;
  inherited;
end;

procedure TFhirLocationPosition.Assign(oSource : TAdvObject);
begin
  inherited;
  longitudeObject := TFhirLocationPosition(oSource).longitudeObject.Clone;
  latitudeObject := TFhirLocationPosition(oSource).latitudeObject.Clone;
  altitudeObject := TFhirLocationPosition(oSource).altitudeObject.Clone;
end;

procedure TFhirLocationPosition.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'longitude') Then
     list.add(FLongitude.Link);
  if (child_name = 'latitude') Then
     list.add(FLatitude.Link);
  if (child_name = 'altitude') Then
     list.add(FAltitude.Link);
end;

procedure TFhirLocationPosition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'longitude', 'decimal', FLongitude.Link));{2}
  oList.add(TFHIRProperty.create(self, 'latitude', 'decimal', FLatitude.Link));{2}
  oList.add(TFHIRProperty.create(self, 'altitude', 'decimal', FAltitude.Link));{2}
end;

procedure TFhirLocationPosition.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'longitude') then LongitudeObject := propValue as TFhirDecimal{5a}
  else if (propName = 'latitude') then LatitudeObject := propValue as TFhirDecimal{5a}
  else if (propName = 'altitude') then AltitudeObject := propValue as TFhirDecimal{5a}
  else inherited;
end;

function TFhirLocationPosition.FhirType : string;
begin
  result := 'position';
end;

function TFhirLocationPosition.Link : TFhirLocationPosition;
begin
  result := TFhirLocationPosition(inherited Link);
end;

function TFhirLocationPosition.Clone : TFhirLocationPosition;
begin
  result := TFhirLocationPosition(inherited Clone);
end;

{ TFhirLocationPosition }

Procedure TFhirLocationPosition.SetLongitude(value : TFhirDecimal);
begin
  FLongitude.free;
  FLongitude := value;
end;

Function TFhirLocationPosition.GetLongitudeST : String;
begin
  if FLongitude = nil then
    result := ''
  else
    result := FLongitude.value;
end;

Procedure TFhirLocationPosition.SetLongitudeST(value : String);
begin
  if value <> '' then
  begin
    if FLongitude = nil then
      FLongitude := TFhirDecimal.create;
    FLongitude.value := value
  end
  else if FLongitude <> nil then
    FLongitude.value := '';
end;

Procedure TFhirLocationPosition.SetLatitude(value : TFhirDecimal);
begin
  FLatitude.free;
  FLatitude := value;
end;

Function TFhirLocationPosition.GetLatitudeST : String;
begin
  if FLatitude = nil then
    result := ''
  else
    result := FLatitude.value;
end;

Procedure TFhirLocationPosition.SetLatitudeST(value : String);
begin
  if value <> '' then
  begin
    if FLatitude = nil then
      FLatitude := TFhirDecimal.create;
    FLatitude.value := value
  end
  else if FLatitude <> nil then
    FLatitude.value := '';
end;

Procedure TFhirLocationPosition.SetAltitude(value : TFhirDecimal);
begin
  FAltitude.free;
  FAltitude := value;
end;

Function TFhirLocationPosition.GetAltitudeST : String;
begin
  if FAltitude = nil then
    result := ''
  else
    result := FAltitude.value;
end;

Procedure TFhirLocationPosition.SetAltitudeST(value : String);
begin
  if value <> '' then
  begin
    if FAltitude = nil then
      FAltitude := TFhirDecimal.create;
    FAltitude.value := value
  end
  else if FAltitude <> nil then
    FAltitude.value := '';
end;


{ TFhirLocationPositionListEnumerator }

Constructor TFhirLocationPositionListEnumerator.Create(list : TFhirLocationPositionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirLocationPositionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLocationPositionListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirLocationPositionListEnumerator.GetCurrent : TFhirLocationPosition;
begin
  Result := FList[FIndex];
end;


{ TFhirLocationPositionList }
procedure TFhirLocationPositionList.AddItem(value: TFhirLocationPosition);
begin
  assert(value.ClassName = 'TFhirLocationPosition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLocationPosition');
  add(value);
end;


function TFhirLocationPositionList.Append: TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirLocationPositionList.ClearItems;
begin
  Clear;
end;

function TFhirLocationPositionList.GetEnumerator : TFhirLocationPositionListEnumerator;
begin
  result := TFhirLocationPositionListEnumerator.Create(self.link);
end;

function TFhirLocationPositionList.Clone: TFhirLocationPositionList;
begin
  result := TFhirLocationPositionList(inherited Clone);
end;

function TFhirLocationPositionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLocationPositionList.GetItemN(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition(ObjectByIndex[index]);
end;

function TFhirLocationPositionList.IndexOf(value: TFhirLocationPosition): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirLocationPositionList.Insert(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirLocationPositionList.InsertItem(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  Inherited Insert(index, value);
end;

function TFhirLocationPositionList.Item(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition(ObjectByIndex[index]);
end;

function TFhirLocationPositionList.Link: TFhirLocationPositionList;
begin
  result := TFhirLocationPositionList(inherited Link);
end;

procedure TFhirLocationPositionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLocationPositionList.SetItemByIndex(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  FhirLocationPositions[index] := value;
end;

procedure TFhirLocationPositionList.SetItemN(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationProduct }

constructor TFhirMedicationProduct.Create;
begin
  inherited;
  FIngredientList := TFhirMedicationProductIngredientList.Create;
end;

destructor TFhirMedicationProduct.Destroy;
begin
  FForm.free;
  FIngredientList.Free;
  inherited;
end;

procedure TFhirMedicationProduct.Assign(oSource : TAdvObject);
begin
  inherited;
  form := TFhirMedicationProduct(oSource).form.Clone;
  FIngredientList.Assign(TFhirMedicationProduct(oSource).FIngredientList);
end;

procedure TFhirMedicationProduct.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'form') Then
     list.add(FForm.Link);
  if (child_name = 'ingredient') Then
     list.addAll(FIngredientList);
end;

procedure TFhirMedicationProduct.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ingredient', '', FIngredientList.Link)){3};
end;

procedure TFhirMedicationProduct.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'form') then Form := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'ingredient') then IngredientList.add(propValue as TFhirMedicationProductIngredient){2}
  else inherited;
end;

function TFhirMedicationProduct.FhirType : string;
begin
  result := 'product';
end;

function TFhirMedicationProduct.Link : TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(inherited Link);
end;

function TFhirMedicationProduct.Clone : TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(inherited Clone);
end;

{ TFhirMedicationProduct }

Procedure TFhirMedicationProduct.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;


{ TFhirMedicationProductListEnumerator }

Constructor TFhirMedicationProductListEnumerator.Create(list : TFhirMedicationProductList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMedicationProductListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationProductListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMedicationProductListEnumerator.GetCurrent : TFhirMedicationProduct;
begin
  Result := FList[FIndex];
end;


{ TFhirMedicationProductList }
procedure TFhirMedicationProductList.AddItem(value: TFhirMedicationProduct);
begin
  assert(value.ClassName = 'TFhirMedicationProduct', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationProduct');
  add(value);
end;


function TFhirMedicationProductList.Append: TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationProductList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationProductList.GetEnumerator : TFhirMedicationProductListEnumerator;
begin
  result := TFhirMedicationProductListEnumerator.Create(self.link);
end;

function TFhirMedicationProductList.Clone: TFhirMedicationProductList;
begin
  result := TFhirMedicationProductList(inherited Clone);
end;

function TFhirMedicationProductList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationProductList.GetItemN(index: Integer): TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(ObjectByIndex[index]);
end;

function TFhirMedicationProductList.IndexOf(value: TFhirMedicationProduct): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationProductList.Insert(index: Integer): TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationProductList.InsertItem(index: Integer; value: TFhirMedicationProduct);
begin
  assert(value is TFhirMedicationProduct);
  Inherited Insert(index, value);
end;

function TFhirMedicationProductList.Item(index: Integer): TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(ObjectByIndex[index]);
end;

function TFhirMedicationProductList.Link: TFhirMedicationProductList;
begin
  result := TFhirMedicationProductList(inherited Link);
end;

procedure TFhirMedicationProductList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationProductList.SetItemByIndex(index: Integer; value: TFhirMedicationProduct);
begin
  assert(value is TFhirMedicationProduct);
  FhirMedicationProducts[index] := value;
end;

procedure TFhirMedicationProductList.SetItemN(index: Integer; value: TFhirMedicationProduct);
begin
  assert(value is TFhirMedicationProduct);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationProductIngredient }

constructor TFhirMedicationProductIngredient.Create;
begin
  inherited;
end;

destructor TFhirMedicationProductIngredient.Destroy;
begin
  FItem.free;
  FAmount.free;
  inherited;
end;

procedure TFhirMedicationProductIngredient.Assign(oSource : TAdvObject);
begin
  inherited;
  item := TFhirMedicationProductIngredient(oSource).item.Clone;
  amount := TFhirMedicationProductIngredient(oSource).amount.Clone;
end;

procedure TFhirMedicationProductIngredient.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(FItem.Link);
  if (child_name = 'amount') Then
     list.add(FAmount.Link);
end;

procedure TFhirMedicationProductIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'Resource(Substance|Medication)', FItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Ratio', FAmount.Link));{2}
end;

procedure TFhirMedicationProductIngredient.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'item') then Item := propValue as TFhirResourceReference{Resource}{4b}
  else if (propName = 'amount') then Amount := propValue as TFhirRatio{4b}
  else inherited;
end;

function TFhirMedicationProductIngredient.FhirType : string;
begin
  result := 'ingredient';
end;

function TFhirMedicationProductIngredient.Link : TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(inherited Link);
end;

function TFhirMedicationProductIngredient.Clone : TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(inherited Clone);
end;

{ TFhirMedicationProductIngredient }

Procedure TFhirMedicationProductIngredient.SetItem(value : TFhirResourceReference{Resource});
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirMedicationProductIngredient.SetAmount(value : TFhirRatio);
begin
  FAmount.free;
  FAmount := value;
end;


{ TFhirMedicationProductIngredientListEnumerator }

Constructor TFhirMedicationProductIngredientListEnumerator.Create(list : TFhirMedicationProductIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMedicationProductIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationProductIngredientListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMedicationProductIngredientListEnumerator.GetCurrent : TFhirMedicationProductIngredient;
begin
  Result := FList[FIndex];
end;


{ TFhirMedicationProductIngredientList }
procedure TFhirMedicationProductIngredientList.AddItem(value: TFhirMedicationProductIngredient);
begin
  assert(value.ClassName = 'TFhirMedicationProductIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationProductIngredient');
  add(value);
end;


function TFhirMedicationProductIngredientList.Append: TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationProductIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationProductIngredientList.GetEnumerator : TFhirMedicationProductIngredientListEnumerator;
begin
  result := TFhirMedicationProductIngredientListEnumerator.Create(self.link);
end;

function TFhirMedicationProductIngredientList.Clone: TFhirMedicationProductIngredientList;
begin
  result := TFhirMedicationProductIngredientList(inherited Clone);
end;

function TFhirMedicationProductIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationProductIngredientList.GetItemN(index: Integer): TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationProductIngredientList.IndexOf(value: TFhirMedicationProductIngredient): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationProductIngredientList.Insert(index: Integer): TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationProductIngredientList.InsertItem(index: Integer; value: TFhirMedicationProductIngredient);
begin
  assert(value is TFhirMedicationProductIngredient);
  Inherited Insert(index, value);
end;

function TFhirMedicationProductIngredientList.Item(index: Integer): TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationProductIngredientList.Link: TFhirMedicationProductIngredientList;
begin
  result := TFhirMedicationProductIngredientList(inherited Link);
end;

procedure TFhirMedicationProductIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationProductIngredientList.SetItemByIndex(index: Integer; value: TFhirMedicationProductIngredient);
begin
  assert(value is TFhirMedicationProductIngredient);
  FhirMedicationProductIngredients[index] := value;
end;

procedure TFhirMedicationProductIngredientList.SetItemN(index: Integer; value: TFhirMedicationProductIngredient);
begin
  assert(value is TFhirMedicationProductIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPackage }

constructor TFhirMedicationPackage.Create;
begin
  inherited;
  FContentList := TFhirMedicationPackageContentList.Create;
end;

destructor TFhirMedicationPackage.Destroy;
begin
  FContainer.free;
  FContentList.Free;
  inherited;
end;

procedure TFhirMedicationPackage.Assign(oSource : TAdvObject);
begin
  inherited;
  container := TFhirMedicationPackage(oSource).container.Clone;
  FContentList.Assign(TFhirMedicationPackage(oSource).FContentList);
end;

procedure TFhirMedicationPackage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'container') Then
     list.add(FContainer.Link);
  if (child_name = 'content') Then
     list.addAll(FContentList);
end;

procedure TFhirMedicationPackage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'container', 'CodeableConcept', FContainer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', '', FContentList.Link)){3};
end;

procedure TFhirMedicationPackage.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'container') then Container := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'content') then ContentList.add(propValue as TFhirMedicationPackageContent){2}
  else inherited;
end;

function TFhirMedicationPackage.FhirType : string;
begin
  result := 'package';
end;

function TFhirMedicationPackage.Link : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(inherited Link);
end;

function TFhirMedicationPackage.Clone : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(inherited Clone);
end;

{ TFhirMedicationPackage }

Procedure TFhirMedicationPackage.SetContainer(value : TFhirCodeableConcept);
begin
  FContainer.free;
  FContainer := value;
end;


{ TFhirMedicationPackageListEnumerator }

Constructor TFhirMedicationPackageListEnumerator.Create(list : TFhirMedicationPackageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMedicationPackageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationPackageListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMedicationPackageListEnumerator.GetCurrent : TFhirMedicationPackage;
begin
  Result := FList[FIndex];
end;


{ TFhirMedicationPackageList }
procedure TFhirMedicationPackageList.AddItem(value: TFhirMedicationPackage);
begin
  assert(value.ClassName = 'TFhirMedicationPackage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPackage');
  add(value);
end;


function TFhirMedicationPackageList.Append: TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPackageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPackageList.GetEnumerator : TFhirMedicationPackageListEnumerator;
begin
  result := TFhirMedicationPackageListEnumerator.Create(self.link);
end;

function TFhirMedicationPackageList.Clone: TFhirMedicationPackageList;
begin
  result := TFhirMedicationPackageList(inherited Clone);
end;

function TFhirMedicationPackageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPackageList.GetItemN(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(ObjectByIndex[index]);
end;

function TFhirMedicationPackageList.IndexOf(value: TFhirMedicationPackage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPackageList.Insert(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPackageList.InsertItem(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  Inherited Insert(index, value);
end;

function TFhirMedicationPackageList.Item(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(ObjectByIndex[index]);
end;

function TFhirMedicationPackageList.Link: TFhirMedicationPackageList;
begin
  result := TFhirMedicationPackageList(inherited Link);
end;

procedure TFhirMedicationPackageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPackageList.SetItemByIndex(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  FhirMedicationPackages[index] := value;
end;

procedure TFhirMedicationPackageList.SetItemN(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPackageContent }

constructor TFhirMedicationPackageContent.Create;
begin
  inherited;
end;

destructor TFhirMedicationPackageContent.Destroy;
begin
  FItem.free;
  FAmount.free;
  inherited;
end;

procedure TFhirMedicationPackageContent.Assign(oSource : TAdvObject);
begin
  inherited;
  item := TFhirMedicationPackageContent(oSource).item.Clone;
  amount := TFhirMedicationPackageContent(oSource).amount.Clone;
end;

procedure TFhirMedicationPackageContent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(FItem.Link);
  if (child_name = 'amount') Then
     list.add(FAmount.Link);
end;

procedure TFhirMedicationPackageContent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'Resource(Medication)', FItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', FAmount.Link));{2}
end;

procedure TFhirMedicationPackageContent.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'item') then Item := propValue as TFhirResourceReference{TFhirMedication}{4b}
  else if (propName = 'amount') then Amount := propValue as TFhirQuantity{4b}
  else inherited;
end;

function TFhirMedicationPackageContent.FhirType : string;
begin
  result := 'content';
end;

function TFhirMedicationPackageContent.Link : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(inherited Link);
end;

function TFhirMedicationPackageContent.Clone : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(inherited Clone);
end;

{ TFhirMedicationPackageContent }

Procedure TFhirMedicationPackageContent.SetItem(value : TFhirResourceReference{TFhirMedication});
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirMedicationPackageContent.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;


{ TFhirMedicationPackageContentListEnumerator }

Constructor TFhirMedicationPackageContentListEnumerator.Create(list : TFhirMedicationPackageContentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMedicationPackageContentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationPackageContentListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMedicationPackageContentListEnumerator.GetCurrent : TFhirMedicationPackageContent;
begin
  Result := FList[FIndex];
end;


{ TFhirMedicationPackageContentList }
procedure TFhirMedicationPackageContentList.AddItem(value: TFhirMedicationPackageContent);
begin
  assert(value.ClassName = 'TFhirMedicationPackageContent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPackageContent');
  add(value);
end;


function TFhirMedicationPackageContentList.Append: TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPackageContentList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPackageContentList.GetEnumerator : TFhirMedicationPackageContentListEnumerator;
begin
  result := TFhirMedicationPackageContentListEnumerator.Create(self.link);
end;

function TFhirMedicationPackageContentList.Clone: TFhirMedicationPackageContentList;
begin
  result := TFhirMedicationPackageContentList(inherited Clone);
end;

function TFhirMedicationPackageContentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPackageContentList.GetItemN(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(ObjectByIndex[index]);
end;

function TFhirMedicationPackageContentList.IndexOf(value: TFhirMedicationPackageContent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPackageContentList.Insert(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPackageContentList.InsertItem(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  Inherited Insert(index, value);
end;

function TFhirMedicationPackageContentList.Item(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(ObjectByIndex[index]);
end;

function TFhirMedicationPackageContentList.Link: TFhirMedicationPackageContentList;
begin
  result := TFhirMedicationPackageContentList(inherited Link);
end;

procedure TFhirMedicationPackageContentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPackageContentList.SetItemByIndex(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  FhirMedicationPackageContents[index] := value;
end;

procedure TFhirMedicationPackageContentList.SetItemN(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationAdministrationDosage }

constructor TFhirMedicationAdministrationDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationAdministrationDosage.Destroy;
begin
  FTiming.free;
  FAsNeeded.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FQuantity.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationAdministrationDosage.Assign(oSource : TAdvObject);
begin
  inherited;
  timing := TFhirMedicationAdministrationDosage(oSource).timing.Clone;
  asNeeded := TFhirMedicationAdministrationDosage(oSource).asNeeded.Clone;
  site := TFhirMedicationAdministrationDosage(oSource).site.Clone;
  route := TFhirMedicationAdministrationDosage(oSource).route.Clone;
  method := TFhirMedicationAdministrationDosage(oSource).method.Clone;
  quantity := TFhirMedicationAdministrationDosage(oSource).quantity.Clone;
  rate := TFhirMedicationAdministrationDosage(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationAdministrationDosage(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationAdministrationDosage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'timing[x]') Then
     list.add(FTiming.Link);
  if (child_name = 'asNeeded[x]') Then
     list.add(FAsNeeded.Link);
  if (child_name = 'site') Then
     list.add(FSite.Link);
  if (child_name = 'route') Then
     list.add(FRoute.Link);
  if (child_name = 'method') Then
     list.add(FMethod.Link);
  if (child_name = 'quantity') Then
     list.add(FQuantity.Link);
  if (child_name = 'rate') Then
     list.add(FRate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(FMaxDosePerPeriod.Link);
end;

procedure TFhirMedicationAdministrationDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Period', FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', FAsNeeded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', FRoute.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate', 'Ratio', FRate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', FMaxDosePerPeriod.Link));{2}
end;

procedure TFhirMedicationAdministrationDosage.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName.startsWith('timing')) then Timing := propValue as TFhirType{4}
  else if (propName.startsWith('asNeeded')) then AsNeeded := propValue as TFhirType{4}
  else if (propName = 'site') then Site := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'route') then Route := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'method') then Method := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'quantity') then Quantity := propValue as TFhirQuantity{4b}
  else if (propName = 'rate') then Rate := propValue as TFhirRatio{4b}
  else if (propName = 'maxDosePerPeriod') then MaxDosePerPeriod := propValue as TFhirRatio{4b}
  else inherited;
end;

function TFhirMedicationAdministrationDosage.FhirType : string;
begin
  result := 'dosage';
end;

function TFhirMedicationAdministrationDosage.Link : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(inherited Link);
end;

function TFhirMedicationAdministrationDosage.Clone : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(inherited Clone);
end;

{ TFhirMedicationAdministrationDosage }

Procedure TFhirMedicationAdministrationDosage.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetAsNeeded(value : TFhirType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetRate(value : TFhirRatio);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;


{ TFhirMedicationAdministrationDosageListEnumerator }

Constructor TFhirMedicationAdministrationDosageListEnumerator.Create(list : TFhirMedicationAdministrationDosageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMedicationAdministrationDosageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationAdministrationDosageListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMedicationAdministrationDosageListEnumerator.GetCurrent : TFhirMedicationAdministrationDosage;
begin
  Result := FList[FIndex];
end;


{ TFhirMedicationAdministrationDosageList }
procedure TFhirMedicationAdministrationDosageList.AddItem(value: TFhirMedicationAdministrationDosage);
begin
  assert(value.ClassName = 'TFhirMedicationAdministrationDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationAdministrationDosage');
  add(value);
end;


function TFhirMedicationAdministrationDosageList.Append: TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationAdministrationDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationAdministrationDosageList.GetEnumerator : TFhirMedicationAdministrationDosageListEnumerator;
begin
  result := TFhirMedicationAdministrationDosageListEnumerator.Create(self.link);
end;

function TFhirMedicationAdministrationDosageList.Clone: TFhirMedicationAdministrationDosageList;
begin
  result := TFhirMedicationAdministrationDosageList(inherited Clone);
end;

function TFhirMedicationAdministrationDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationAdministrationDosageList.GetItemN(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationDosageList.IndexOf(value: TFhirMedicationAdministrationDosage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationAdministrationDosageList.Insert(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationAdministrationDosageList.InsertItem(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationAdministrationDosageList.Item(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationDosageList.Link: TFhirMedicationAdministrationDosageList;
begin
  result := TFhirMedicationAdministrationDosageList(inherited Link);
end;

procedure TFhirMedicationAdministrationDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationAdministrationDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  FhirMedicationAdministrationDosages[index] := value;
end;

procedure TFhirMedicationAdministrationDosageList.SetItemN(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispenseDispense }

constructor TFhirMedicationDispenseDispense.Create;
begin
  inherited;
  FReceiverList := TFhirResourceReferenceList{Resource}.Create;
  FDosageList := TFhirMedicationDispenseDispenseDosageList.Create;
end;

destructor TFhirMedicationDispenseDispense.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FType_.free;
  FQuantity.free;
  FMedication.free;
  FWhenPrepared.free;
  FWhenHandedOver.free;
  FDestination.free;
  FReceiverList.Free;
  FDosageList.Free;
  inherited;
end;

procedure TFhirMedicationDispenseDispense.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirMedicationDispenseDispense(oSource).identifier.Clone;
  FStatus := TFhirMedicationDispenseDispense(oSource).FStatus.Link;
  type_ := TFhirMedicationDispenseDispense(oSource).type_.Clone;
  quantity := TFhirMedicationDispenseDispense(oSource).quantity.Clone;
  medication := TFhirMedicationDispenseDispense(oSource).medication.Clone;
  whenPreparedObject := TFhirMedicationDispenseDispense(oSource).whenPreparedObject.Clone;
  whenHandedOverObject := TFhirMedicationDispenseDispense(oSource).whenHandedOverObject.Clone;
  destination := TFhirMedicationDispenseDispense(oSource).destination.Clone;
  FReceiverList.Assign(TFhirMedicationDispenseDispense(oSource).FReceiverList);
  FDosageList.Assign(TFhirMedicationDispenseDispense(oSource).FDosageList);
end;

procedure TFhirMedicationDispenseDispense.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'quantity') Then
     list.add(FQuantity.Link);
  if (child_name = 'medication') Then
     list.add(FMedication.Link);
  if (child_name = 'whenPrepared') Then
     list.add(FWhenPrepared.Link);
  if (child_name = 'whenHandedOver') Then
     list.add(FWhenHandedOver.Link);
  if (child_name = 'destination') Then
     list.add(FDestination.Link);
  if (child_name = 'receiver') Then
     list.addAll(FReceiverList);
  if (child_name = 'dosage') Then
     list.addAll(FDosageList);
end;

procedure TFhirMedicationDispenseDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'medication', 'Resource(Medication)', FMedication.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenPrepared', 'dateTime', FWhenPrepared.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenHandedOver', 'dateTime', FWhenHandedOver.Link));{2}
  oList.add(TFHIRProperty.create(self, 'destination', 'Resource(Location)', FDestination.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receiver', 'Resource(Patient|Practitioner)', FReceiverList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dosage', '', FDosageList.Link)){3};
end;

procedure TFhirMedicationDispenseDispense.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'identifier') then Identifier := propValue as TFhirIdentifier{4b}
  else if (propName = 'status') then StatusObject := propValue as TFHIREnum
  else if (propName = 'type') then Type_ := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'quantity') then Quantity := propValue as TFhirQuantity{4b}
  else if (propName = 'medication') then Medication := propValue as TFhirResourceReference{TFhirMedication}{4b}
  else if (propName = 'whenPrepared') then WhenPreparedObject := propValue as TFhirDateTime{5a}
  else if (propName = 'whenHandedOver') then WhenHandedOverObject := propValue as TFhirDateTime{5a}
  else if (propName = 'destination') then Destination := propValue as TFhirResourceReference{TFhirLocation}{4b}
  else if (propName = 'receiver') then ReceiverList.add(propValue as TFhirResourceReference{Resource}){2}
  else if (propName = 'dosage') then DosageList.add(propValue as TFhirMedicationDispenseDispenseDosage){2}
  else inherited;
end;

function TFhirMedicationDispenseDispense.FhirType : string;
begin
  result := 'dispense';
end;

function TFhirMedicationDispenseDispense.Link : TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense(inherited Link);
end;

function TFhirMedicationDispenseDispense.Clone : TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense(inherited Clone);
end;

{ TFhirMedicationDispenseDispense }

Procedure TFhirMedicationDispenseDispense.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirMedicationDispenseDispense.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMedicationDispenseDispense.GetStatusST : TFhirMedicationDispenseStatus;
begin
  if FStatus = nil then
    result := TFhirMedicationDispenseStatus(0)
  else
    result := TFhirMedicationDispenseStatus(StringArrayIndexOfSensitive(CODES_TFhirMedicationDispenseStatus, FStatus.value));
end;

Procedure TFhirMedicationDispenseDispense.SetStatusST(value : TFhirMedicationDispenseStatus);
begin
  if ord(value) = 0 then
    StatusObject := nil
  else
    StatusObject := TFhirEnum.create(CODES_TFhirMedicationDispenseStatus[value]);
end;

Procedure TFhirMedicationDispenseDispense.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationDispenseDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationDispenseDispense.SetMedication(value : TFhirResourceReference{TFhirMedication});
begin
  FMedication.free;
  FMedication := value;
end;

Procedure TFhirMedicationDispenseDispense.SetWhenPrepared(value : TFhirDateTime);
begin
  FWhenPrepared.free;
  FWhenPrepared := value;
end;

Function TFhirMedicationDispenseDispense.GetWhenPreparedST : TDateTimeEx;
begin
  if FWhenPrepared = nil then
    result := nil
  else
    result := FWhenPrepared.value;
end;

Procedure TFhirMedicationDispenseDispense.SetWhenPreparedST(value : TDateTimeEx);
begin
  if value <> nil then
  begin
    if FWhenPrepared = nil then
      FWhenPrepared := TFhirDateTime.create;
    FWhenPrepared.value := value
  end
  else if FWhenPrepared <> nil then
    FWhenPrepared.value := nil;
end;

Procedure TFhirMedicationDispenseDispense.SetWhenHandedOver(value : TFhirDateTime);
begin
  FWhenHandedOver.free;
  FWhenHandedOver := value;
end;

Function TFhirMedicationDispenseDispense.GetWhenHandedOverST : TDateTimeEx;
begin
  if FWhenHandedOver = nil then
    result := nil
  else
    result := FWhenHandedOver.value;
end;

Procedure TFhirMedicationDispenseDispense.SetWhenHandedOverST(value : TDateTimeEx);
begin
  if value <> nil then
  begin
    if FWhenHandedOver = nil then
      FWhenHandedOver := TFhirDateTime.create;
    FWhenHandedOver.value := value
  end
  else if FWhenHandedOver <> nil then
    FWhenHandedOver.value := nil;
end;

Procedure TFhirMedicationDispenseDispense.SetDestination(value : TFhirResourceReference{TFhirLocation});
begin
  FDestination.free;
  FDestination := value;
end;


{ TFhirMedicationDispenseDispenseListEnumerator }

Constructor TFhirMedicationDispenseDispenseListEnumerator.Create(list : TFhirMedicationDispenseDispenseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMedicationDispenseDispenseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispenseDispenseListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMedicationDispenseDispenseListEnumerator.GetCurrent : TFhirMedicationDispenseDispense;
begin
  Result := FList[FIndex];
end;


{ TFhirMedicationDispenseDispenseList }
procedure TFhirMedicationDispenseDispenseList.AddItem(value: TFhirMedicationDispenseDispense);
begin
  assert(value.ClassName = 'TFhirMedicationDispenseDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispenseDispense');
  add(value);
end;


function TFhirMedicationDispenseDispenseList.Append: TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseDispenseList.GetEnumerator : TFhirMedicationDispenseDispenseListEnumerator;
begin
  result := TFhirMedicationDispenseDispenseListEnumerator.Create(self.link);
end;

function TFhirMedicationDispenseDispenseList.Clone: TFhirMedicationDispenseDispenseList;
begin
  result := TFhirMedicationDispenseDispenseList(inherited Clone);
end;

function TFhirMedicationDispenseDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseDispenseList.GetItemN(index: Integer): TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseDispenseList.IndexOf(value: TFhirMedicationDispenseDispense): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationDispenseDispenseList.Insert(index: Integer): TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseDispenseList.InsertItem(index: Integer; value: TFhirMedicationDispenseDispense);
begin
  assert(value is TFhirMedicationDispenseDispense);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseDispenseList.Item(index: Integer): TFhirMedicationDispenseDispense;
begin
  result := TFhirMedicationDispenseDispense(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseDispenseList.Link: TFhirMedicationDispenseDispenseList;
begin
  result := TFhirMedicationDispenseDispenseList(inherited Link);
end;

procedure TFhirMedicationDispenseDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseDispenseList.SetItemByIndex(index: Integer; value: TFhirMedicationDispenseDispense);
begin
  assert(value is TFhirMedicationDispenseDispense);
  FhirMedicationDispenseDispenses[index] := value;
end;

procedure TFhirMedicationDispenseDispenseList.SetItemN(index: Integer; value: TFhirMedicationDispenseDispense);
begin
  assert(value is TFhirMedicationDispenseDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispenseDispenseDosage }

constructor TFhirMedicationDispenseDispenseDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispenseDispenseDosage.Destroy;
begin
  FAdditionalInstructions.free;
  FTiming.free;
  FAsNeeded.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FQuantity.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationDispenseDispenseDosage.Assign(oSource : TAdvObject);
begin
  inherited;
  additionalInstructions := TFhirMedicationDispenseDispenseDosage(oSource).additionalInstructions.Clone;
  timing := TFhirMedicationDispenseDispenseDosage(oSource).timing.Clone;
  asNeeded := TFhirMedicationDispenseDispenseDosage(oSource).asNeeded.Clone;
  site := TFhirMedicationDispenseDispenseDosage(oSource).site.Clone;
  route := TFhirMedicationDispenseDispenseDosage(oSource).route.Clone;
  method := TFhirMedicationDispenseDispenseDosage(oSource).method.Clone;
  quantity := TFhirMedicationDispenseDispenseDosage(oSource).quantity.Clone;
  rate := TFhirMedicationDispenseDispenseDosage(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationDispenseDispenseDosage(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationDispenseDispenseDosage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'additionalInstructions') Then
     list.add(FAdditionalInstructions.Link);
  if (child_name = 'timing[x]') Then
     list.add(FTiming.Link);
  if (child_name = 'asNeeded[x]') Then
     list.add(FAsNeeded.Link);
  if (child_name = 'site') Then
     list.add(FSite.Link);
  if (child_name = 'route') Then
     list.add(FRoute.Link);
  if (child_name = 'method') Then
     list.add(FMethod.Link);
  if (child_name = 'quantity') Then
     list.add(FQuantity.Link);
  if (child_name = 'rate') Then
     list.add(FRate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(FMaxDosePerPeriod.Link);
end;

procedure TFhirMedicationDispenseDispenseDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'additionalInstructions', 'CodeableConcept', FAdditionalInstructions.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Period|Schedule', FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', FAsNeeded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', FRoute.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate', 'Ratio', FRate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', FMaxDosePerPeriod.Link));{2}
end;

procedure TFhirMedicationDispenseDispenseDosage.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'additionalInstructions') then AdditionalInstructions := propValue as TFhirCodeableConcept{4b}
  else if (propName.startsWith('timing')) then Timing := propValue as TFhirType{4}
  else if (propName.startsWith('asNeeded')) then AsNeeded := propValue as TFhirType{4}
  else if (propName = 'site') then Site := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'route') then Route := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'method') then Method := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'quantity') then Quantity := propValue as TFhirQuantity{4b}
  else if (propName = 'rate') then Rate := propValue as TFhirRatio{4b}
  else if (propName = 'maxDosePerPeriod') then MaxDosePerPeriod := propValue as TFhirRatio{4b}
  else inherited;
end;

function TFhirMedicationDispenseDispenseDosage.FhirType : string;
begin
  result := 'dosage';
end;

function TFhirMedicationDispenseDispenseDosage.Link : TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage(inherited Link);
end;

function TFhirMedicationDispenseDispenseDosage.Clone : TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage(inherited Clone);
end;

{ TFhirMedicationDispenseDispenseDosage }

Procedure TFhirMedicationDispenseDispenseDosage.SetAdditionalInstructions(value : TFhirCodeableConcept);
begin
  FAdditionalInstructions.free;
  FAdditionalInstructions := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetAsNeeded(value : TFhirType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetRate(value : TFhirRatio);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationDispenseDispenseDosage.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;


{ TFhirMedicationDispenseDispenseDosageListEnumerator }

Constructor TFhirMedicationDispenseDispenseDosageListEnumerator.Create(list : TFhirMedicationDispenseDispenseDosageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMedicationDispenseDispenseDosageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispenseDispenseDosageListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMedicationDispenseDispenseDosageListEnumerator.GetCurrent : TFhirMedicationDispenseDispenseDosage;
begin
  Result := FList[FIndex];
end;


{ TFhirMedicationDispenseDispenseDosageList }
procedure TFhirMedicationDispenseDispenseDosageList.AddItem(value: TFhirMedicationDispenseDispenseDosage);
begin
  assert(value.ClassName = 'TFhirMedicationDispenseDispenseDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispenseDispenseDosage');
  add(value);
end;


function TFhirMedicationDispenseDispenseDosageList.Append: TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseDispenseDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseDispenseDosageList.GetEnumerator : TFhirMedicationDispenseDispenseDosageListEnumerator;
begin
  result := TFhirMedicationDispenseDispenseDosageListEnumerator.Create(self.link);
end;

function TFhirMedicationDispenseDispenseDosageList.Clone: TFhirMedicationDispenseDispenseDosageList;
begin
  result := TFhirMedicationDispenseDispenseDosageList(inherited Clone);
end;

function TFhirMedicationDispenseDispenseDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseDispenseDosageList.GetItemN(index: Integer): TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseDispenseDosageList.IndexOf(value: TFhirMedicationDispenseDispenseDosage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationDispenseDispenseDosageList.Insert(index: Integer): TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseDispenseDosageList.InsertItem(index: Integer; value: TFhirMedicationDispenseDispenseDosage);
begin
  assert(value is TFhirMedicationDispenseDispenseDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseDispenseDosageList.Item(index: Integer): TFhirMedicationDispenseDispenseDosage;
begin
  result := TFhirMedicationDispenseDispenseDosage(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseDispenseDosageList.Link: TFhirMedicationDispenseDispenseDosageList;
begin
  result := TFhirMedicationDispenseDispenseDosageList(inherited Link);
end;

procedure TFhirMedicationDispenseDispenseDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseDispenseDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationDispenseDispenseDosage);
begin
  assert(value is TFhirMedicationDispenseDispenseDosage);
  FhirMedicationDispenseDispenseDosages[index] := value;
end;

procedure TFhirMedicationDispenseDispenseDosageList.SetItemN(index: Integer; value: TFhirMedicationDispenseDispenseDosage);
begin
  assert(value is TFhirMedicationDispenseDispenseDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispenseSubstitution }

constructor TFhirMedicationDispenseSubstitution.Create;
begin
  inherited;
  FReasonList := TFhirCodeableConceptList.Create;
  FResponsiblePartyList := TFhirResourceReferenceList{TFhirPractitioner}.Create;
end;

destructor TFhirMedicationDispenseSubstitution.Destroy;
begin
  FType_.free;
  FReasonList.Free;
  FResponsiblePartyList.Free;
  inherited;
end;

procedure TFhirMedicationDispenseSubstitution.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirMedicationDispenseSubstitution(oSource).type_.Clone;
  FReasonList.Assign(TFhirMedicationDispenseSubstitution(oSource).FReasonList);
  FResponsiblePartyList.Assign(TFhirMedicationDispenseSubstitution(oSource).FResponsiblePartyList);
end;

procedure TFhirMedicationDispenseSubstitution.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'reason') Then
     list.addAll(FReasonList);
  if (child_name = 'responsibleParty') Then
     list.addAll(FResponsiblePartyList);
end;

procedure TFhirMedicationDispenseSubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'responsibleParty', 'Resource(Practitioner)', FResponsiblePartyList.Link)){3};
end;

procedure TFhirMedicationDispenseSubstitution.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'type') then Type_ := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'reason') then ReasonList.add(propValue as TFhirCodeableConcept){2}
  else if (propName = 'responsibleParty') then ResponsiblePartyList.add(propValue as TFhirResourceReference{TFhirPractitioner}){2}
  else inherited;
end;

function TFhirMedicationDispenseSubstitution.FhirType : string;
begin
  result := 'substitution';
end;

function TFhirMedicationDispenseSubstitution.Link : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(inherited Link);
end;

function TFhirMedicationDispenseSubstitution.Clone : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(inherited Clone);
end;

{ TFhirMedicationDispenseSubstitution }

Procedure TFhirMedicationDispenseSubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;


{ TFhirMedicationDispenseSubstitutionListEnumerator }

Constructor TFhirMedicationDispenseSubstitutionListEnumerator.Create(list : TFhirMedicationDispenseSubstitutionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMedicationDispenseSubstitutionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispenseSubstitutionListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMedicationDispenseSubstitutionListEnumerator.GetCurrent : TFhirMedicationDispenseSubstitution;
begin
  Result := FList[FIndex];
end;


{ TFhirMedicationDispenseSubstitutionList }
procedure TFhirMedicationDispenseSubstitutionList.AddItem(value: TFhirMedicationDispenseSubstitution);
begin
  assert(value.ClassName = 'TFhirMedicationDispenseSubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispenseSubstitution');
  add(value);
end;


function TFhirMedicationDispenseSubstitutionList.Append: TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseSubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseSubstitutionList.GetEnumerator : TFhirMedicationDispenseSubstitutionListEnumerator;
begin
  result := TFhirMedicationDispenseSubstitutionListEnumerator.Create(self.link);
end;

function TFhirMedicationDispenseSubstitutionList.Clone: TFhirMedicationDispenseSubstitutionList;
begin
  result := TFhirMedicationDispenseSubstitutionList(inherited Clone);
end;

function TFhirMedicationDispenseSubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseSubstitutionList.GetItemN(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseSubstitutionList.IndexOf(value: TFhirMedicationDispenseSubstitution): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationDispenseSubstitutionList.Insert(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationDispenseSubstitutionList.InsertItem(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseSubstitutionList.Item(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseSubstitutionList.Link: TFhirMedicationDispenseSubstitutionList;
begin
  result := TFhirMedicationDispenseSubstitutionList(inherited Link);
end;

procedure TFhirMedicationDispenseSubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseSubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  FhirMedicationDispenseSubstitutions[index] := value;
end;

procedure TFhirMedicationDispenseSubstitutionList.SetItemN(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPrescriptionDosageInstruction }

constructor TFhirMedicationPrescriptionDosageInstruction.Create;
begin
  inherited;
end;

destructor TFhirMedicationPrescriptionDosageInstruction.Destroy;
begin
  FText.free;
  FAdditionalInstructions.free;
  FTiming.free;
  FAsNeeded.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FDoseQuantity.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationPrescriptionDosageInstruction.Assign(oSource : TAdvObject);
begin
  inherited;
  textObject := TFhirMedicationPrescriptionDosageInstruction(oSource).textObject.Clone;
  additionalInstructions := TFhirMedicationPrescriptionDosageInstruction(oSource).additionalInstructions.Clone;
  timing := TFhirMedicationPrescriptionDosageInstruction(oSource).timing.Clone;
  asNeeded := TFhirMedicationPrescriptionDosageInstruction(oSource).asNeeded.Clone;
  site := TFhirMedicationPrescriptionDosageInstruction(oSource).site.Clone;
  route := TFhirMedicationPrescriptionDosageInstruction(oSource).route.Clone;
  method := TFhirMedicationPrescriptionDosageInstruction(oSource).method.Clone;
  doseQuantity := TFhirMedicationPrescriptionDosageInstruction(oSource).doseQuantity.Clone;
  rate := TFhirMedicationPrescriptionDosageInstruction(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationPrescriptionDosageInstruction(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationPrescriptionDosageInstruction.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'text') Then
     list.add(FText.Link);
  if (child_name = 'additionalInstructions') Then
     list.add(FAdditionalInstructions.Link);
  if (child_name = 'timing[x]') Then
     list.add(FTiming.Link);
  if (child_name = 'asNeeded[x]') Then
     list.add(FAsNeeded.Link);
  if (child_name = 'site') Then
     list.add(FSite.Link);
  if (child_name = 'route') Then
     list.add(FRoute.Link);
  if (child_name = 'method') Then
     list.add(FMethod.Link);
  if (child_name = 'doseQuantity') Then
     list.add(FDoseQuantity.Link);
  if (child_name = 'rate') Then
     list.add(FRate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(FMaxDosePerPeriod.Link);
end;

procedure TFhirMedicationPrescriptionDosageInstruction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'text', 'string', FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additionalInstructions', 'CodeableConcept', FAdditionalInstructions.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Period|Schedule', FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', FAsNeeded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', FRoute.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseQuantity', 'Quantity', FDoseQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate', 'Ratio', FRate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', FMaxDosePerPeriod.Link));{2}
end;

procedure TFhirMedicationPrescriptionDosageInstruction.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'text') then TextObject := propValue as TFhirString{5a}
  else if (propName = 'additionalInstructions') then AdditionalInstructions := propValue as TFhirCodeableConcept{4b}
  else if (propName.startsWith('timing')) then Timing := propValue as TFhirType{4}
  else if (propName.startsWith('asNeeded')) then AsNeeded := propValue as TFhirType{4}
  else if (propName = 'site') then Site := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'route') then Route := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'method') then Method := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'doseQuantity') then DoseQuantity := propValue as TFhirQuantity{4b}
  else if (propName = 'rate') then Rate := propValue as TFhirRatio{4b}
  else if (propName = 'maxDosePerPeriod') then MaxDosePerPeriod := propValue as TFhirRatio{4b}
  else inherited;
end;

function TFhirMedicationPrescriptionDosageInstruction.FhirType : string;
begin
  result := 'dosageInstruction';
end;

function TFhirMedicationPrescriptionDosageInstruction.Link : TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction(inherited Link);
end;

function TFhirMedicationPrescriptionDosageInstruction.Clone : TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction(inherited Clone);
end;

{ TFhirMedicationPrescriptionDosageInstruction }

Procedure TFhirMedicationPrescriptionDosageInstruction.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirMedicationPrescriptionDosageInstruction.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetAdditionalInstructions(value : TFhirCodeableConcept);
begin
  FAdditionalInstructions.free;
  FAdditionalInstructions := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetAsNeeded(value : TFhirType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetDoseQuantity(value : TFhirQuantity);
begin
  FDoseQuantity.free;
  FDoseQuantity := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetRate(value : TFhirRatio);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationPrescriptionDosageInstruction.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;


{ TFhirMedicationPrescriptionDosageInstructionListEnumerator }

Constructor TFhirMedicationPrescriptionDosageInstructionListEnumerator.Create(list : TFhirMedicationPrescriptionDosageInstructionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMedicationPrescriptionDosageInstructionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationPrescriptionDosageInstructionListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMedicationPrescriptionDosageInstructionListEnumerator.GetCurrent : TFhirMedicationPrescriptionDosageInstruction;
begin
  Result := FList[FIndex];
end;


{ TFhirMedicationPrescriptionDosageInstructionList }
procedure TFhirMedicationPrescriptionDosageInstructionList.AddItem(value: TFhirMedicationPrescriptionDosageInstruction);
begin
  assert(value.ClassName = 'TFhirMedicationPrescriptionDosageInstruction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPrescriptionDosageInstruction');
  add(value);
end;


function TFhirMedicationPrescriptionDosageInstructionList.Append: TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionDosageInstructionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPrescriptionDosageInstructionList.GetEnumerator : TFhirMedicationPrescriptionDosageInstructionListEnumerator;
begin
  result := TFhirMedicationPrescriptionDosageInstructionListEnumerator.Create(self.link);
end;

function TFhirMedicationPrescriptionDosageInstructionList.Clone: TFhirMedicationPrescriptionDosageInstructionList;
begin
  result := TFhirMedicationPrescriptionDosageInstructionList(inherited Clone);
end;

function TFhirMedicationPrescriptionDosageInstructionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPrescriptionDosageInstructionList.GetItemN(index: Integer): TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionDosageInstructionList.IndexOf(value: TFhirMedicationPrescriptionDosageInstruction): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPrescriptionDosageInstructionList.Insert(index: Integer): TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionDosageInstructionList.InsertItem(index: Integer; value: TFhirMedicationPrescriptionDosageInstruction);
begin
  assert(value is TFhirMedicationPrescriptionDosageInstruction);
  Inherited Insert(index, value);
end;

function TFhirMedicationPrescriptionDosageInstructionList.Item(index: Integer): TFhirMedicationPrescriptionDosageInstruction;
begin
  result := TFhirMedicationPrescriptionDosageInstruction(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionDosageInstructionList.Link: TFhirMedicationPrescriptionDosageInstructionList;
begin
  result := TFhirMedicationPrescriptionDosageInstructionList(inherited Link);
end;

procedure TFhirMedicationPrescriptionDosageInstructionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPrescriptionDosageInstructionList.SetItemByIndex(index: Integer; value: TFhirMedicationPrescriptionDosageInstruction);
begin
  assert(value is TFhirMedicationPrescriptionDosageInstruction);
  FhirMedicationPrescriptionDosageInstructions[index] := value;
end;

procedure TFhirMedicationPrescriptionDosageInstructionList.SetItemN(index: Integer; value: TFhirMedicationPrescriptionDosageInstruction);
begin
  assert(value is TFhirMedicationPrescriptionDosageInstruction);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPrescriptionDispense }

constructor TFhirMedicationPrescriptionDispense.Create;
begin
  inherited;
end;

destructor TFhirMedicationPrescriptionDispense.Destroy;
begin
  FMedication.free;
  FValidityPeriod.free;
  FNumberOfRepeatsAllowed.free;
  FQuantity.free;
  FExpectedSupplyDuration.free;
  inherited;
end;

procedure TFhirMedicationPrescriptionDispense.Assign(oSource : TAdvObject);
begin
  inherited;
  medication := TFhirMedicationPrescriptionDispense(oSource).medication.Clone;
  validityPeriod := TFhirMedicationPrescriptionDispense(oSource).validityPeriod.Clone;
  numberOfRepeatsAllowedObject := TFhirMedicationPrescriptionDispense(oSource).numberOfRepeatsAllowedObject.Clone;
  quantity := TFhirMedicationPrescriptionDispense(oSource).quantity.Clone;
  expectedSupplyDuration := TFhirMedicationPrescriptionDispense(oSource).expectedSupplyDuration.Clone;
end;

procedure TFhirMedicationPrescriptionDispense.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'medication') Then
     list.add(FMedication.Link);
  if (child_name = 'validityPeriod') Then
     list.add(FValidityPeriod.Link);
  if (child_name = 'numberOfRepeatsAllowed') Then
     list.add(FNumberOfRepeatsAllowed.Link);
  if (child_name = 'quantity') Then
     list.add(FQuantity.Link);
  if (child_name = 'expectedSupplyDuration') Then
     list.add(FExpectedSupplyDuration.Link);
end;

procedure TFhirMedicationPrescriptionDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'medication', 'Resource(Medication)', FMedication.Link));{2}
  oList.add(TFHIRProperty.create(self, 'validityPeriod', 'Period', FValidityPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfRepeatsAllowed', 'integer', FNumberOfRepeatsAllowed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expectedSupplyDuration', 'Duration', FExpectedSupplyDuration.Link));{2}
end;

procedure TFhirMedicationPrescriptionDispense.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'medication') then Medication := propValue as TFhirResourceReference{TFhirMedication}{4b}
  else if (propName = 'validityPeriod') then ValidityPeriod := propValue as TFhirPeriod{4b}
  else if (propName = 'numberOfRepeatsAllowed') then NumberOfRepeatsAllowedObject := propValue as TFhirInteger{5a}
  else if (propName = 'quantity') then Quantity := propValue as TFhirQuantity{4b}
  else if (propName = 'expectedSupplyDuration') then ExpectedSupplyDuration := propValue as TFhirQuantity{4b}
  else inherited;
end;

function TFhirMedicationPrescriptionDispense.FhirType : string;
begin
  result := 'dispense';
end;

function TFhirMedicationPrescriptionDispense.Link : TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense(inherited Link);
end;

function TFhirMedicationPrescriptionDispense.Clone : TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense(inherited Clone);
end;

{ TFhirMedicationPrescriptionDispense }

Procedure TFhirMedicationPrescriptionDispense.SetMedication(value : TFhirResourceReference{TFhirMedication});
begin
  FMedication.free;
  FMedication := value;
end;

Procedure TFhirMedicationPrescriptionDispense.SetValidityPeriod(value : TFhirPeriod);
begin
  FValidityPeriod.free;
  FValidityPeriod := value;
end;

Procedure TFhirMedicationPrescriptionDispense.SetNumberOfRepeatsAllowed(value : TFhirInteger);
begin
  FNumberOfRepeatsAllowed.free;
  FNumberOfRepeatsAllowed := value;
end;

Function TFhirMedicationPrescriptionDispense.GetNumberOfRepeatsAllowedST : String;
begin
  if FNumberOfRepeatsAllowed = nil then
    result := ''
  else
    result := FNumberOfRepeatsAllowed.value;
end;

Procedure TFhirMedicationPrescriptionDispense.SetNumberOfRepeatsAllowedST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfRepeatsAllowed = nil then
      FNumberOfRepeatsAllowed := TFhirInteger.create;
    FNumberOfRepeatsAllowed.value := value
  end
  else if FNumberOfRepeatsAllowed <> nil then
    FNumberOfRepeatsAllowed.value := '';
end;

Procedure TFhirMedicationPrescriptionDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationPrescriptionDispense.SetExpectedSupplyDuration(value : TFhirQuantity);
begin
  FExpectedSupplyDuration.free;
  FExpectedSupplyDuration := value;
end;


{ TFhirMedicationPrescriptionDispenseListEnumerator }

Constructor TFhirMedicationPrescriptionDispenseListEnumerator.Create(list : TFhirMedicationPrescriptionDispenseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMedicationPrescriptionDispenseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationPrescriptionDispenseListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMedicationPrescriptionDispenseListEnumerator.GetCurrent : TFhirMedicationPrescriptionDispense;
begin
  Result := FList[FIndex];
end;


{ TFhirMedicationPrescriptionDispenseList }
procedure TFhirMedicationPrescriptionDispenseList.AddItem(value: TFhirMedicationPrescriptionDispense);
begin
  assert(value.ClassName = 'TFhirMedicationPrescriptionDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPrescriptionDispense');
  add(value);
end;


function TFhirMedicationPrescriptionDispenseList.Append: TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPrescriptionDispenseList.GetEnumerator : TFhirMedicationPrescriptionDispenseListEnumerator;
begin
  result := TFhirMedicationPrescriptionDispenseListEnumerator.Create(self.link);
end;

function TFhirMedicationPrescriptionDispenseList.Clone: TFhirMedicationPrescriptionDispenseList;
begin
  result := TFhirMedicationPrescriptionDispenseList(inherited Clone);
end;

function TFhirMedicationPrescriptionDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPrescriptionDispenseList.GetItemN(index: Integer): TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionDispenseList.IndexOf(value: TFhirMedicationPrescriptionDispense): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPrescriptionDispenseList.Insert(index: Integer): TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionDispenseList.InsertItem(index: Integer; value: TFhirMedicationPrescriptionDispense);
begin
  assert(value is TFhirMedicationPrescriptionDispense);
  Inherited Insert(index, value);
end;

function TFhirMedicationPrescriptionDispenseList.Item(index: Integer): TFhirMedicationPrescriptionDispense;
begin
  result := TFhirMedicationPrescriptionDispense(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionDispenseList.Link: TFhirMedicationPrescriptionDispenseList;
begin
  result := TFhirMedicationPrescriptionDispenseList(inherited Link);
end;

procedure TFhirMedicationPrescriptionDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPrescriptionDispenseList.SetItemByIndex(index: Integer; value: TFhirMedicationPrescriptionDispense);
begin
  assert(value is TFhirMedicationPrescriptionDispense);
  FhirMedicationPrescriptionDispenses[index] := value;
end;

procedure TFhirMedicationPrescriptionDispenseList.SetItemN(index: Integer; value: TFhirMedicationPrescriptionDispense);
begin
  assert(value is TFhirMedicationPrescriptionDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPrescriptionSubstitution }

constructor TFhirMedicationPrescriptionSubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationPrescriptionSubstitution.Destroy;
begin
  FType_.free;
  FReason.free;
  inherited;
end;

procedure TFhirMedicationPrescriptionSubstitution.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirMedicationPrescriptionSubstitution(oSource).type_.Clone;
  reason := TFhirMedicationPrescriptionSubstitution(oSource).reason.Clone;
end;

procedure TFhirMedicationPrescriptionSubstitution.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'reason') Then
     list.add(FReason.Link);
end;

procedure TFhirMedicationPrescriptionSubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', FReason.Link));{2}
end;

procedure TFhirMedicationPrescriptionSubstitution.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'type') then Type_ := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'reason') then Reason := propValue as TFhirCodeableConcept{4b}
  else inherited;
end;

function TFhirMedicationPrescriptionSubstitution.FhirType : string;
begin
  result := 'substitution';
end;

function TFhirMedicationPrescriptionSubstitution.Link : TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution(inherited Link);
end;

function TFhirMedicationPrescriptionSubstitution.Clone : TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution(inherited Clone);
end;

{ TFhirMedicationPrescriptionSubstitution }

Procedure TFhirMedicationPrescriptionSubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationPrescriptionSubstitution.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;


{ TFhirMedicationPrescriptionSubstitutionListEnumerator }

Constructor TFhirMedicationPrescriptionSubstitutionListEnumerator.Create(list : TFhirMedicationPrescriptionSubstitutionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMedicationPrescriptionSubstitutionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationPrescriptionSubstitutionListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMedicationPrescriptionSubstitutionListEnumerator.GetCurrent : TFhirMedicationPrescriptionSubstitution;
begin
  Result := FList[FIndex];
end;


{ TFhirMedicationPrescriptionSubstitutionList }
procedure TFhirMedicationPrescriptionSubstitutionList.AddItem(value: TFhirMedicationPrescriptionSubstitution);
begin
  assert(value.ClassName = 'TFhirMedicationPrescriptionSubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPrescriptionSubstitution');
  add(value);
end;


function TFhirMedicationPrescriptionSubstitutionList.Append: TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionSubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPrescriptionSubstitutionList.GetEnumerator : TFhirMedicationPrescriptionSubstitutionListEnumerator;
begin
  result := TFhirMedicationPrescriptionSubstitutionListEnumerator.Create(self.link);
end;

function TFhirMedicationPrescriptionSubstitutionList.Clone: TFhirMedicationPrescriptionSubstitutionList;
begin
  result := TFhirMedicationPrescriptionSubstitutionList(inherited Clone);
end;

function TFhirMedicationPrescriptionSubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPrescriptionSubstitutionList.GetItemN(index: Integer): TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionSubstitutionList.IndexOf(value: TFhirMedicationPrescriptionSubstitution): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationPrescriptionSubstitutionList.Insert(index: Integer): TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationPrescriptionSubstitutionList.InsertItem(index: Integer; value: TFhirMedicationPrescriptionSubstitution);
begin
  assert(value is TFhirMedicationPrescriptionSubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationPrescriptionSubstitutionList.Item(index: Integer): TFhirMedicationPrescriptionSubstitution;
begin
  result := TFhirMedicationPrescriptionSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationPrescriptionSubstitutionList.Link: TFhirMedicationPrescriptionSubstitutionList;
begin
  result := TFhirMedicationPrescriptionSubstitutionList(inherited Link);
end;

procedure TFhirMedicationPrescriptionSubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPrescriptionSubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationPrescriptionSubstitution);
begin
  assert(value is TFhirMedicationPrescriptionSubstitution);
  FhirMedicationPrescriptionSubstitutions[index] := value;
end;

procedure TFhirMedicationPrescriptionSubstitutionList.SetItemN(index: Integer; value: TFhirMedicationPrescriptionSubstitution);
begin
  assert(value is TFhirMedicationPrescriptionSubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationStatementDosage }

constructor TFhirMedicationStatementDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationStatementDosage.Destroy;
begin
  FTiming.free;
  FAsNeeded.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FQuantity.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationStatementDosage.Assign(oSource : TAdvObject);
begin
  inherited;
  timing := TFhirMedicationStatementDosage(oSource).timing.Clone;
  asNeeded := TFhirMedicationStatementDosage(oSource).asNeeded.Clone;
  site := TFhirMedicationStatementDosage(oSource).site.Clone;
  route := TFhirMedicationStatementDosage(oSource).route.Clone;
  method := TFhirMedicationStatementDosage(oSource).method.Clone;
  quantity := TFhirMedicationStatementDosage(oSource).quantity.Clone;
  rate := TFhirMedicationStatementDosage(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationStatementDosage(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationStatementDosage.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'timing') Then
     list.add(FTiming.Link);
  if (child_name = 'asNeeded[x]') Then
     list.add(FAsNeeded.Link);
  if (child_name = 'site') Then
     list.add(FSite.Link);
  if (child_name = 'route') Then
     list.add(FRoute.Link);
  if (child_name = 'method') Then
     list.add(FMethod.Link);
  if (child_name = 'quantity') Then
     list.add(FQuantity.Link);
  if (child_name = 'rate') Then
     list.add(FRate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(FMaxDosePerPeriod.Link);
end;

procedure TFhirMedicationStatementDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'timing', 'Schedule', FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', FAsNeeded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', FRoute.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate', 'Ratio', FRate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', FMaxDosePerPeriod.Link));{2}
end;

procedure TFhirMedicationStatementDosage.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'timing') then Timing := propValue as TFhirSchedule{4b}
  else if (propName.startsWith('asNeeded')) then AsNeeded := propValue as TFhirType{4}
  else if (propName = 'site') then Site := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'route') then Route := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'method') then Method := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'quantity') then Quantity := propValue as TFhirQuantity{4b}
  else if (propName = 'rate') then Rate := propValue as TFhirRatio{4b}
  else if (propName = 'maxDosePerPeriod') then MaxDosePerPeriod := propValue as TFhirRatio{4b}
  else inherited;
end;

function TFhirMedicationStatementDosage.FhirType : string;
begin
  result := 'dosage';
end;

function TFhirMedicationStatementDosage.Link : TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(inherited Link);
end;

function TFhirMedicationStatementDosage.Clone : TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(inherited Clone);
end;

{ TFhirMedicationStatementDosage }

Procedure TFhirMedicationStatementDosage.SetTiming(value : TFhirSchedule);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationStatementDosage.SetAsNeeded(value : TFhirType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

Procedure TFhirMedicationStatementDosage.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationStatementDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationStatementDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationStatementDosage.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationStatementDosage.SetRate(value : TFhirRatio);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationStatementDosage.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;


{ TFhirMedicationStatementDosageListEnumerator }

Constructor TFhirMedicationStatementDosageListEnumerator.Create(list : TFhirMedicationStatementDosageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMedicationStatementDosageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationStatementDosageListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMedicationStatementDosageListEnumerator.GetCurrent : TFhirMedicationStatementDosage;
begin
  Result := FList[FIndex];
end;


{ TFhirMedicationStatementDosageList }
procedure TFhirMedicationStatementDosageList.AddItem(value: TFhirMedicationStatementDosage);
begin
  assert(value.ClassName = 'TFhirMedicationStatementDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationStatementDosage');
  add(value);
end;


function TFhirMedicationStatementDosageList.Append: TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationStatementDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationStatementDosageList.GetEnumerator : TFhirMedicationStatementDosageListEnumerator;
begin
  result := TFhirMedicationStatementDosageListEnumerator.Create(self.link);
end;

function TFhirMedicationStatementDosageList.Clone: TFhirMedicationStatementDosageList;
begin
  result := TFhirMedicationStatementDosageList(inherited Clone);
end;

function TFhirMedicationStatementDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationStatementDosageList.GetItemN(index: Integer): TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(ObjectByIndex[index]);
end;

function TFhirMedicationStatementDosageList.IndexOf(value: TFhirMedicationStatementDosage): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMedicationStatementDosageList.Insert(index: Integer): TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMedicationStatementDosageList.InsertItem(index: Integer; value: TFhirMedicationStatementDosage);
begin
  assert(value is TFhirMedicationStatementDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationStatementDosageList.Item(index: Integer): TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(ObjectByIndex[index]);
end;

function TFhirMedicationStatementDosageList.Link: TFhirMedicationStatementDosageList;
begin
  result := TFhirMedicationStatementDosageList(inherited Link);
end;

procedure TFhirMedicationStatementDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationStatementDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationStatementDosage);
begin
  assert(value is TFhirMedicationStatementDosage);
  FhirMedicationStatementDosages[index] := value;
end;

procedure TFhirMedicationStatementDosageList.SetItemN(index: Integer; value: TFhirMedicationStatementDosage);
begin
  assert(value is TFhirMedicationStatementDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderResponse }

constructor TFhirMessageHeaderResponse.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderResponse.Destroy;
begin
  FIdentifier.free;
  FCode.free;
  FDetails.free;
  inherited;
end;

procedure TFhirMessageHeaderResponse.Assign(oSource : TAdvObject);
begin
  inherited;
  identifierObject := TFhirMessageHeaderResponse(oSource).identifierObject.Clone;
  FCode := TFhirMessageHeaderResponse(oSource).FCode.Link;
  details := TFhirMessageHeaderResponse(oSource).details.Clone;
end;

procedure TFhirMessageHeaderResponse.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(FIdentifier.Link);
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'details') Then
     list.add(FDetails.Link);
end;

procedure TFhirMessageHeaderResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'id', FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'details', 'Resource(OperationOutcome)', FDetails.Link));{2}
end;

procedure TFhirMessageHeaderResponse.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierObject := propValue as TFhirId{5a}
  else if (propName = 'code') then CodeObject := propValue as TFHIREnum
  else if (propName = 'details') then Details := propValue as TFhirResourceReference{TFhirOperationOutcome}{4b}
  else inherited;
end;

function TFhirMessageHeaderResponse.FhirType : string;
begin
  result := 'response';
end;

function TFhirMessageHeaderResponse.Link : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(inherited Link);
end;

function TFhirMessageHeaderResponse.Clone : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(inherited Clone);
end;

{ TFhirMessageHeaderResponse }

Procedure TFhirMessageHeaderResponse.SetIdentifier(value : TFhirId);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirMessageHeaderResponse.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := FIdentifier.value;
end;

Procedure TFhirMessageHeaderResponse.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirId.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

Procedure TFhirMessageHeaderResponse.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirMessageHeaderResponse.GetCodeST : TFhirResponseCode;
begin
  if FCode = nil then
    result := TFhirResponseCode(0)
  else
    result := TFhirResponseCode(StringArrayIndexOfSensitive(CODES_TFhirResponseCode, FCode.value));
end;

Procedure TFhirMessageHeaderResponse.SetCodeST(value : TFhirResponseCode);
begin
  if ord(value) = 0 then
    CodeObject := nil
  else
    CodeObject := TFhirEnum.create(CODES_TFhirResponseCode[value]);
end;

Procedure TFhirMessageHeaderResponse.SetDetails(value : TFhirResourceReference{TFhirOperationOutcome});
begin
  FDetails.free;
  FDetails := value;
end;


{ TFhirMessageHeaderResponseListEnumerator }

Constructor TFhirMessageHeaderResponseListEnumerator.Create(list : TFhirMessageHeaderResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMessageHeaderResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderResponseListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMessageHeaderResponseListEnumerator.GetCurrent : TFhirMessageHeaderResponse;
begin
  Result := FList[FIndex];
end;


{ TFhirMessageHeaderResponseList }
procedure TFhirMessageHeaderResponseList.AddItem(value: TFhirMessageHeaderResponse);
begin
  assert(value.ClassName = 'TFhirMessageHeaderResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderResponse');
  add(value);
end;


function TFhirMessageHeaderResponseList.Append: TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMessageHeaderResponseList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderResponseList.GetEnumerator : TFhirMessageHeaderResponseListEnumerator;
begin
  result := TFhirMessageHeaderResponseListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderResponseList.Clone: TFhirMessageHeaderResponseList;
begin
  result := TFhirMessageHeaderResponseList(inherited Clone);
end;

function TFhirMessageHeaderResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderResponseList.GetItemN(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(ObjectByIndex[index]);
end;

function TFhirMessageHeaderResponseList.IndexOf(value: TFhirMessageHeaderResponse): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMessageHeaderResponseList.Insert(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMessageHeaderResponseList.InsertItem(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderResponseList.Item(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(ObjectByIndex[index]);
end;

function TFhirMessageHeaderResponseList.Link: TFhirMessageHeaderResponseList;
begin
  result := TFhirMessageHeaderResponseList(inherited Link);
end;

procedure TFhirMessageHeaderResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderResponseList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  FhirMessageHeaderResponses[index] := value;
end;

procedure TFhirMessageHeaderResponseList.SetItemN(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderSource }

constructor TFhirMessageHeaderSource.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderSource.Destroy;
begin
  FName.free;
  FSoftware.free;
  FVersion.free;
  FContact.free;
  FEndpoint.free;
  inherited;
end;

procedure TFhirMessageHeaderSource.Assign(oSource : TAdvObject);
begin
  inherited;
  nameObject := TFhirMessageHeaderSource(oSource).nameObject.Clone;
  softwareObject := TFhirMessageHeaderSource(oSource).softwareObject.Clone;
  versionObject := TFhirMessageHeaderSource(oSource).versionObject.Clone;
  contact := TFhirMessageHeaderSource(oSource).contact.Clone;
  endpointObject := TFhirMessageHeaderSource(oSource).endpointObject.Clone;
end;

procedure TFhirMessageHeaderSource.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'software') Then
     list.add(FSoftware.Link);
  if (child_name = 'version') Then
     list.add(FVersion.Link);
  if (child_name = 'contact') Then
     list.add(FContact.Link);
  if (child_name = 'endpoint') Then
     list.add(FEndpoint.Link);
end;

procedure TFhirMessageHeaderSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'software', 'string', FSoftware.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', 'Contact', FContact.Link));{2}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', FEndpoint.Link));{2}
end;

procedure TFhirMessageHeaderSource.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'software') then SoftwareObject := propValue as TFhirString{5a}
  else if (propName = 'version') then VersionObject := propValue as TFhirString{5a}
  else if (propName = 'contact') then Contact := propValue as TFhirContact{4b}
  else if (propName = 'endpoint') then EndpointObject := propValue as TFhirUri{5a}
  else inherited;
end;

function TFhirMessageHeaderSource.FhirType : string;
begin
  result := 'source';
end;

function TFhirMessageHeaderSource.Link : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(inherited Link);
end;

function TFhirMessageHeaderSource.Clone : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(inherited Clone);
end;

{ TFhirMessageHeaderSource }

Procedure TFhirMessageHeaderSource.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMessageHeaderSource.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirMessageHeaderSource.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMessageHeaderSource.SetSoftware(value : TFhirString);
begin
  FSoftware.free;
  FSoftware := value;
end;

Function TFhirMessageHeaderSource.GetSoftwareST : String;
begin
  if FSoftware = nil then
    result := ''
  else
    result := FSoftware.value;
end;

Procedure TFhirMessageHeaderSource.SetSoftwareST(value : String);
begin
  if value <> '' then
  begin
    if FSoftware = nil then
      FSoftware := TFhirString.create;
    FSoftware.value := value
  end
  else if FSoftware <> nil then
    FSoftware.value := '';
end;

Procedure TFhirMessageHeaderSource.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirMessageHeaderSource.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirMessageHeaderSource.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirMessageHeaderSource.SetContact(value : TFhirContact);
begin
  FContact.free;
  FContact := value;
end;

Procedure TFhirMessageHeaderSource.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirMessageHeaderSource.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

Procedure TFhirMessageHeaderSource.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;


{ TFhirMessageHeaderSourceListEnumerator }

Constructor TFhirMessageHeaderSourceListEnumerator.Create(list : TFhirMessageHeaderSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMessageHeaderSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderSourceListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMessageHeaderSourceListEnumerator.GetCurrent : TFhirMessageHeaderSource;
begin
  Result := FList[FIndex];
end;


{ TFhirMessageHeaderSourceList }
procedure TFhirMessageHeaderSourceList.AddItem(value: TFhirMessageHeaderSource);
begin
  assert(value.ClassName = 'TFhirMessageHeaderSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderSource');
  add(value);
end;


function TFhirMessageHeaderSourceList.Append: TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMessageHeaderSourceList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderSourceList.GetEnumerator : TFhirMessageHeaderSourceListEnumerator;
begin
  result := TFhirMessageHeaderSourceListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderSourceList.Clone: TFhirMessageHeaderSourceList;
begin
  result := TFhirMessageHeaderSourceList(inherited Clone);
end;

function TFhirMessageHeaderSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderSourceList.GetItemN(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(ObjectByIndex[index]);
end;

function TFhirMessageHeaderSourceList.IndexOf(value: TFhirMessageHeaderSource): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMessageHeaderSourceList.Insert(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMessageHeaderSourceList.InsertItem(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderSourceList.Item(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(ObjectByIndex[index]);
end;

function TFhirMessageHeaderSourceList.Link: TFhirMessageHeaderSourceList;
begin
  result := TFhirMessageHeaderSourceList(inherited Link);
end;

procedure TFhirMessageHeaderSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderSourceList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  FhirMessageHeaderSources[index] := value;
end;

procedure TFhirMessageHeaderSourceList.SetItemN(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderDestination }

constructor TFhirMessageHeaderDestination.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderDestination.Destroy;
begin
  FName.free;
  FTarget.free;
  FEndpoint.free;
  inherited;
end;

procedure TFhirMessageHeaderDestination.Assign(oSource : TAdvObject);
begin
  inherited;
  nameObject := TFhirMessageHeaderDestination(oSource).nameObject.Clone;
  target := TFhirMessageHeaderDestination(oSource).target.Clone;
  endpointObject := TFhirMessageHeaderDestination(oSource).endpointObject.Clone;
end;

procedure TFhirMessageHeaderDestination.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'target') Then
     list.add(FTarget.Link);
  if (child_name = 'endpoint') Then
     list.add(FEndpoint.Link);
end;

procedure TFhirMessageHeaderDestination.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(Device)', FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', FEndpoint.Link));{2}
end;

procedure TFhirMessageHeaderDestination.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'target') then Target := propValue as TFhirResourceReference{TFhirDevice}{4b}
  else if (propName = 'endpoint') then EndpointObject := propValue as TFhirUri{5a}
  else inherited;
end;

function TFhirMessageHeaderDestination.FhirType : string;
begin
  result := 'destination';
end;

function TFhirMessageHeaderDestination.Link : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(inherited Link);
end;

function TFhirMessageHeaderDestination.Clone : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(inherited Clone);
end;

{ TFhirMessageHeaderDestination }

Procedure TFhirMessageHeaderDestination.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMessageHeaderDestination.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirMessageHeaderDestination.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMessageHeaderDestination.SetTarget(value : TFhirResourceReference{TFhirDevice});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirMessageHeaderDestination.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirMessageHeaderDestination.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

Procedure TFhirMessageHeaderDestination.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;


{ TFhirMessageHeaderDestinationListEnumerator }

Constructor TFhirMessageHeaderDestinationListEnumerator.Create(list : TFhirMessageHeaderDestinationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirMessageHeaderDestinationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderDestinationListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirMessageHeaderDestinationListEnumerator.GetCurrent : TFhirMessageHeaderDestination;
begin
  Result := FList[FIndex];
end;


{ TFhirMessageHeaderDestinationList }
procedure TFhirMessageHeaderDestinationList.AddItem(value: TFhirMessageHeaderDestination);
begin
  assert(value.ClassName = 'TFhirMessageHeaderDestination', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderDestination');
  add(value);
end;


function TFhirMessageHeaderDestinationList.Append: TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirMessageHeaderDestinationList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderDestinationList.GetEnumerator : TFhirMessageHeaderDestinationListEnumerator;
begin
  result := TFhirMessageHeaderDestinationListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderDestinationList.Clone: TFhirMessageHeaderDestinationList;
begin
  result := TFhirMessageHeaderDestinationList(inherited Clone);
end;

function TFhirMessageHeaderDestinationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderDestinationList.GetItemN(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(ObjectByIndex[index]);
end;

function TFhirMessageHeaderDestinationList.IndexOf(value: TFhirMessageHeaderDestination): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirMessageHeaderDestinationList.Insert(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirMessageHeaderDestinationList.InsertItem(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderDestinationList.Item(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(ObjectByIndex[index]);
end;

function TFhirMessageHeaderDestinationList.Link: TFhirMessageHeaderDestinationList;
begin
  result := TFhirMessageHeaderDestinationList(inherited Link);
end;

procedure TFhirMessageHeaderDestinationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderDestinationList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  FhirMessageHeaderDestinations[index] := value;
end;

procedure TFhirMessageHeaderDestinationList.SetItemN(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  ObjectByIndex[index] := value;
end;

{ TFhirObservationReferenceRange }

constructor TFhirObservationReferenceRange.Create;
begin
  inherited;
end;

destructor TFhirObservationReferenceRange.Destroy;
begin
  FLow.free;
  FHigh.free;
  FMeaning.free;
  FAge.free;
  inherited;
end;

procedure TFhirObservationReferenceRange.Assign(oSource : TAdvObject);
begin
  inherited;
  low := TFhirObservationReferenceRange(oSource).low.Clone;
  high := TFhirObservationReferenceRange(oSource).high.Clone;
  meaning := TFhirObservationReferenceRange(oSource).meaning.Clone;
  age := TFhirObservationReferenceRange(oSource).age.Clone;
end;

procedure TFhirObservationReferenceRange.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'low') Then
     list.add(FLow.Link);
  if (child_name = 'high') Then
     list.add(FHigh.Link);
  if (child_name = 'meaning') Then
     list.add(FMeaning.Link);
  if (child_name = 'age') Then
     list.add(FAge.Link);
end;

procedure TFhirObservationReferenceRange.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'low', 'Quantity', FLow.Link));{2}
  oList.add(TFHIRProperty.create(self, 'high', 'Quantity', FHigh.Link));{2}
  oList.add(TFHIRProperty.create(self, 'meaning', 'CodeableConcept', FMeaning.Link));{2}
  oList.add(TFHIRProperty.create(self, 'age', 'Range', FAge.Link));{2}
end;

procedure TFhirObservationReferenceRange.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'low') then Low := propValue as TFhirQuantity{4b}
  else if (propName = 'high') then High := propValue as TFhirQuantity{4b}
  else if (propName = 'meaning') then Meaning := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'age') then Age := propValue as TFhirRange{4b}
  else inherited;
end;

function TFhirObservationReferenceRange.FhirType : string;
begin
  result := 'referenceRange';
end;

function TFhirObservationReferenceRange.Link : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(inherited Link);
end;

function TFhirObservationReferenceRange.Clone : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(inherited Clone);
end;

{ TFhirObservationReferenceRange }

Procedure TFhirObservationReferenceRange.SetLow(value : TFhirQuantity);
begin
  FLow.free;
  FLow := value;
end;

Procedure TFhirObservationReferenceRange.SetHigh(value : TFhirQuantity);
begin
  FHigh.free;
  FHigh := value;
end;

Procedure TFhirObservationReferenceRange.SetMeaning(value : TFhirCodeableConcept);
begin
  FMeaning.free;
  FMeaning := value;
end;

Procedure TFhirObservationReferenceRange.SetAge(value : TFhirRange);
begin
  FAge.free;
  FAge := value;
end;


{ TFhirObservationReferenceRangeListEnumerator }

Constructor TFhirObservationReferenceRangeListEnumerator.Create(list : TFhirObservationReferenceRangeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirObservationReferenceRangeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationReferenceRangeListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirObservationReferenceRangeListEnumerator.GetCurrent : TFhirObservationReferenceRange;
begin
  Result := FList[FIndex];
end;


{ TFhirObservationReferenceRangeList }
procedure TFhirObservationReferenceRangeList.AddItem(value: TFhirObservationReferenceRange);
begin
  assert(value.ClassName = 'TFhirObservationReferenceRange', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationReferenceRange');
  add(value);
end;


function TFhirObservationReferenceRangeList.Append: TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirObservationReferenceRangeList.ClearItems;
begin
  Clear;
end;

function TFhirObservationReferenceRangeList.GetEnumerator : TFhirObservationReferenceRangeListEnumerator;
begin
  result := TFhirObservationReferenceRangeListEnumerator.Create(self.link);
end;

function TFhirObservationReferenceRangeList.Clone: TFhirObservationReferenceRangeList;
begin
  result := TFhirObservationReferenceRangeList(inherited Clone);
end;

function TFhirObservationReferenceRangeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationReferenceRangeList.GetItemN(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(ObjectByIndex[index]);
end;

function TFhirObservationReferenceRangeList.IndexOf(value: TFhirObservationReferenceRange): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirObservationReferenceRangeList.Insert(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirObservationReferenceRangeList.InsertItem(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  Inherited Insert(index, value);
end;

function TFhirObservationReferenceRangeList.Item(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(ObjectByIndex[index]);
end;

function TFhirObservationReferenceRangeList.Link: TFhirObservationReferenceRangeList;
begin
  result := TFhirObservationReferenceRangeList(inherited Link);
end;

procedure TFhirObservationReferenceRangeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationReferenceRangeList.SetItemByIndex(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  FhirObservationReferenceRanges[index] := value;
end;

procedure TFhirObservationReferenceRangeList.SetItemN(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  ObjectByIndex[index] := value;
end;

{ TFhirObservationRelated }

constructor TFhirObservationRelated.Create;
begin
  inherited;
end;

destructor TFhirObservationRelated.Destroy;
begin
  FType_.free;
  FTarget.free;
  inherited;
end;

procedure TFhirObservationRelated.Assign(oSource : TAdvObject);
begin
  inherited;
  FType_ := TFhirObservationRelated(oSource).FType_.Link;
  target := TFhirObservationRelated(oSource).target.Clone;
end;

procedure TFhirObservationRelated.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'target') Then
     list.add(FTarget.Link);
end;

procedure TFhirObservationRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(Observation)', FTarget.Link));{2}
end;

procedure TFhirObservationRelated.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'type') then Type_Object := propValue as TFHIREnum
  else if (propName = 'target') then Target := propValue as TFhirResourceReference{TFhirObservation}{4b}
  else inherited;
end;

function TFhirObservationRelated.FhirType : string;
begin
  result := 'related';
end;

function TFhirObservationRelated.Link : TFhirObservationRelated;
begin
  result := TFhirObservationRelated(inherited Link);
end;

function TFhirObservationRelated.Clone : TFhirObservationRelated;
begin
  result := TFhirObservationRelated(inherited Clone);
end;

{ TFhirObservationRelated }

Procedure TFhirObservationRelated.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirObservationRelated.GetType_ST : TFhirObservationRelationshiptypes;
begin
  if FType_ = nil then
    result := TFhirObservationRelationshiptypes(0)
  else
    result := TFhirObservationRelationshiptypes(StringArrayIndexOfSensitive(CODES_TFhirObservationRelationshiptypes, FType_.value));
end;

Procedure TFhirObservationRelated.SetType_ST(value : TFhirObservationRelationshiptypes);
begin
  if ord(value) = 0 then
    Type_Object := nil
  else
    Type_Object := TFhirEnum.create(CODES_TFhirObservationRelationshiptypes[value]);
end;

Procedure TFhirObservationRelated.SetTarget(value : TFhirResourceReference{TFhirObservation});
begin
  FTarget.free;
  FTarget := value;
end;


{ TFhirObservationRelatedListEnumerator }

Constructor TFhirObservationRelatedListEnumerator.Create(list : TFhirObservationRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirObservationRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationRelatedListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirObservationRelatedListEnumerator.GetCurrent : TFhirObservationRelated;
begin
  Result := FList[FIndex];
end;


{ TFhirObservationRelatedList }
procedure TFhirObservationRelatedList.AddItem(value: TFhirObservationRelated);
begin
  assert(value.ClassName = 'TFhirObservationRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationRelated');
  add(value);
end;


function TFhirObservationRelatedList.Append: TFhirObservationRelated;
begin
  result := TFhirObservationRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirObservationRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirObservationRelatedList.GetEnumerator : TFhirObservationRelatedListEnumerator;
begin
  result := TFhirObservationRelatedListEnumerator.Create(self.link);
end;

function TFhirObservationRelatedList.Clone: TFhirObservationRelatedList;
begin
  result := TFhirObservationRelatedList(inherited Clone);
end;

function TFhirObservationRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationRelatedList.GetItemN(index: Integer): TFhirObservationRelated;
begin
  result := TFhirObservationRelated(ObjectByIndex[index]);
end;

function TFhirObservationRelatedList.IndexOf(value: TFhirObservationRelated): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirObservationRelatedList.Insert(index: Integer): TFhirObservationRelated;
begin
  result := TFhirObservationRelated.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirObservationRelatedList.InsertItem(index: Integer; value: TFhirObservationRelated);
begin
  assert(value is TFhirObservationRelated);
  Inherited Insert(index, value);
end;

function TFhirObservationRelatedList.Item(index: Integer): TFhirObservationRelated;
begin
  result := TFhirObservationRelated(ObjectByIndex[index]);
end;

function TFhirObservationRelatedList.Link: TFhirObservationRelatedList;
begin
  result := TFhirObservationRelatedList(inherited Link);
end;

procedure TFhirObservationRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationRelatedList.SetItemByIndex(index: Integer; value: TFhirObservationRelated);
begin
  assert(value is TFhirObservationRelated);
  FhirObservationRelateds[index] := value;
end;

procedure TFhirObservationRelatedList.SetItemN(index: Integer; value: TFhirObservationRelated);
begin
  assert(value is TFhirObservationRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationOutcomeIssue }

constructor TFhirOperationOutcomeIssue.Create;
begin
  inherited;
  FLocationList := TFhirStringList.Create;
end;

destructor TFhirOperationOutcomeIssue.Destroy;
begin
  FSeverity.free;
  FType_.free;
  FDetails.free;
  FLocationList.Free;
  inherited;
end;

procedure TFhirOperationOutcomeIssue.Assign(oSource : TAdvObject);
begin
  inherited;
  FSeverity := TFhirOperationOutcomeIssue(oSource).FSeverity.Link;
  type_ := TFhirOperationOutcomeIssue(oSource).type_.Clone;
  detailsObject := TFhirOperationOutcomeIssue(oSource).detailsObject.Clone;
  FLocationList.Assign(TFhirOperationOutcomeIssue(oSource).FLocationList);
end;

procedure TFhirOperationOutcomeIssue.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'severity') Then
     list.add(FSeverity.Link);
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'details') Then
     list.add(FDetails.Link);
  if (child_name = 'location') Then
     list.addAll(FLocationList);
end;

procedure TFhirOperationOutcomeIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'severity', 'code', FSeverity.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'details', 'string', FDetails.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'string', FLocationList.Link)){3};
end;

procedure TFhirOperationOutcomeIssue.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'severity') then SeverityObject := propValue as TFHIREnum
  else if (propName = 'type') then Type_ := propValue as TFhirCoding{4b}
  else if (propName = 'details') then DetailsObject := propValue as TFhirString{5a}
  else if (propName = 'location') then LocationList.add(propValue as TFhirString){2}
  else inherited;
end;

function TFhirOperationOutcomeIssue.FhirType : string;
begin
  result := 'issue';
end;

function TFhirOperationOutcomeIssue.Link : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Link);
end;

function TFhirOperationOutcomeIssue.Clone : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Clone);
end;

{ TFhirOperationOutcomeIssue }

Procedure TFhirOperationOutcomeIssue.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirOperationOutcomeIssue.GetSeverityST : TFhirIssueSeverity;
begin
  if FSeverity = nil then
    result := TFhirIssueSeverity(0)
  else
    result := TFhirIssueSeverity(StringArrayIndexOfSensitive(CODES_TFhirIssueSeverity, FSeverity.value));
end;

Procedure TFhirOperationOutcomeIssue.SetSeverityST(value : TFhirIssueSeverity);
begin
  if ord(value) = 0 then
    SeverityObject := nil
  else
    SeverityObject := TFhirEnum.create(CODES_TFhirIssueSeverity[value]);
end;

Procedure TFhirOperationOutcomeIssue.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirOperationOutcomeIssue.SetDetails(value : TFhirString);
begin
  FDetails.free;
  FDetails := value;
end;

Function TFhirOperationOutcomeIssue.GetDetailsST : String;
begin
  if FDetails = nil then
    result := ''
  else
    result := FDetails.value;
end;

Procedure TFhirOperationOutcomeIssue.SetDetailsST(value : String);
begin
  if value <> '' then
  begin
    if FDetails = nil then
      FDetails := TFhirString.create;
    FDetails.value := value
  end
  else if FDetails <> nil then
    FDetails.value := '';
end;


{ TFhirOperationOutcomeIssueListEnumerator }

Constructor TFhirOperationOutcomeIssueListEnumerator.Create(list : TFhirOperationOutcomeIssueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirOperationOutcomeIssueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationOutcomeIssueListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirOperationOutcomeIssueListEnumerator.GetCurrent : TFhirOperationOutcomeIssue;
begin
  Result := FList[FIndex];
end;


{ TFhirOperationOutcomeIssueList }
procedure TFhirOperationOutcomeIssueList.AddItem(value: TFhirOperationOutcomeIssue);
begin
  assert(value.ClassName = 'TFhirOperationOutcomeIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationOutcomeIssue');
  add(value);
end;


function TFhirOperationOutcomeIssueList.Append: TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirOperationOutcomeIssueList.ClearItems;
begin
  Clear;
end;

function TFhirOperationOutcomeIssueList.GetEnumerator : TFhirOperationOutcomeIssueListEnumerator;
begin
  result := TFhirOperationOutcomeIssueListEnumerator.Create(self.link);
end;

function TFhirOperationOutcomeIssueList.Clone: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Clone);
end;

function TFhirOperationOutcomeIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationOutcomeIssueList.GetItemN(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.IndexOf(value: TFhirOperationOutcomeIssue): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirOperationOutcomeIssueList.Insert(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirOperationOutcomeIssueList.InsertItem(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  Inherited Insert(index, value);
end;

function TFhirOperationOutcomeIssueList.Item(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.Link: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Link);
end;

procedure TFhirOperationOutcomeIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationOutcomeIssueList.SetItemByIndex(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  FhirOperationOutcomeIssues[index] := value;
end;

procedure TFhirOperationOutcomeIssueList.SetItemN(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  ObjectByIndex[index] := value;
end;

{ TFhirOrderWhen }

constructor TFhirOrderWhen.Create;
begin
  inherited;
end;

destructor TFhirOrderWhen.Destroy;
begin
  FCode.free;
  FSchedule.free;
  inherited;
end;

procedure TFhirOrderWhen.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirOrderWhen(oSource).code.Clone;
  schedule := TFhirOrderWhen(oSource).schedule.Clone;
end;

procedure TFhirOrderWhen.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'schedule') Then
     list.add(FSchedule.Link);
end;

procedure TFhirOrderWhen.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'schedule', 'Schedule', FSchedule.Link));{2}
end;

procedure TFhirOrderWhen.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then Code := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'schedule') then Schedule := propValue as TFhirSchedule{4b}
  else inherited;
end;

function TFhirOrderWhen.FhirType : string;
begin
  result := 'when';
end;

function TFhirOrderWhen.Link : TFhirOrderWhen;
begin
  result := TFhirOrderWhen(inherited Link);
end;

function TFhirOrderWhen.Clone : TFhirOrderWhen;
begin
  result := TFhirOrderWhen(inherited Clone);
end;

{ TFhirOrderWhen }

Procedure TFhirOrderWhen.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirOrderWhen.SetSchedule(value : TFhirSchedule);
begin
  FSchedule.free;
  FSchedule := value;
end;


{ TFhirOrderWhenListEnumerator }

Constructor TFhirOrderWhenListEnumerator.Create(list : TFhirOrderWhenList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirOrderWhenListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOrderWhenListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirOrderWhenListEnumerator.GetCurrent : TFhirOrderWhen;
begin
  Result := FList[FIndex];
end;


{ TFhirOrderWhenList }
procedure TFhirOrderWhenList.AddItem(value: TFhirOrderWhen);
begin
  assert(value.ClassName = 'TFhirOrderWhen', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrderWhen');
  add(value);
end;


function TFhirOrderWhenList.Append: TFhirOrderWhen;
begin
  result := TFhirOrderWhen.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirOrderWhenList.ClearItems;
begin
  Clear;
end;

function TFhirOrderWhenList.GetEnumerator : TFhirOrderWhenListEnumerator;
begin
  result := TFhirOrderWhenListEnumerator.Create(self.link);
end;

function TFhirOrderWhenList.Clone: TFhirOrderWhenList;
begin
  result := TFhirOrderWhenList(inherited Clone);
end;

function TFhirOrderWhenList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrderWhenList.GetItemN(index: Integer): TFhirOrderWhen;
begin
  result := TFhirOrderWhen(ObjectByIndex[index]);
end;

function TFhirOrderWhenList.IndexOf(value: TFhirOrderWhen): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirOrderWhenList.Insert(index: Integer): TFhirOrderWhen;
begin
  result := TFhirOrderWhen.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirOrderWhenList.InsertItem(index: Integer; value: TFhirOrderWhen);
begin
  assert(value is TFhirOrderWhen);
  Inherited Insert(index, value);
end;

function TFhirOrderWhenList.Item(index: Integer): TFhirOrderWhen;
begin
  result := TFhirOrderWhen(ObjectByIndex[index]);
end;

function TFhirOrderWhenList.Link: TFhirOrderWhenList;
begin
  result := TFhirOrderWhenList(inherited Link);
end;

procedure TFhirOrderWhenList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrderWhenList.SetItemByIndex(index: Integer; value: TFhirOrderWhen);
begin
  assert(value is TFhirOrderWhen);
  FhirOrderWhens[index] := value;
end;

procedure TFhirOrderWhenList.SetItemN(index: Integer; value: TFhirOrderWhen);
begin
  assert(value is TFhirOrderWhen);
  ObjectByIndex[index] := value;
end;

{ TFhirOrganizationContact }

constructor TFhirOrganizationContact.Create;
begin
  inherited;
  FTelecomList := TFhirContactList.Create;
end;

destructor TFhirOrganizationContact.Destroy;
begin
  FPurpose.free;
  FName.free;
  FTelecomList.Free;
  FAddress.free;
  FGender.free;
  inherited;
end;

procedure TFhirOrganizationContact.Assign(oSource : TAdvObject);
begin
  inherited;
  purpose := TFhirOrganizationContact(oSource).purpose.Clone;
  name := TFhirOrganizationContact(oSource).name.Clone;
  FTelecomList.Assign(TFhirOrganizationContact(oSource).FTelecomList);
  address := TFhirOrganizationContact(oSource).address.Clone;
  gender := TFhirOrganizationContact(oSource).gender.Clone;
end;

procedure TFhirOrganizationContact.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'purpose') Then
     list.add(FPurpose.Link);
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'telecom') Then
     list.addAll(FTelecomList);
  if (child_name = 'address') Then
     list.add(FAddress.Link);
  if (child_name = 'gender') Then
     list.add(FGender.Link);
end;

procedure TFhirOrganizationContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'purpose', 'CodeableConcept', FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'Contact', FTelecomList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'address', 'Address', FAddress.Link));{2}
  oList.add(TFHIRProperty.create(self, 'gender', 'CodeableConcept', FGender.Link));{2}
end;

procedure TFhirOrganizationContact.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'purpose') then Purpose := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'name') then Name := propValue as TFhirHumanName{4b}
  else if (propName = 'telecom') then TelecomList.add(propValue as TFhirContact){2}
  else if (propName = 'address') then Address := propValue as TFhirAddress{4b}
  else if (propName = 'gender') then Gender := propValue as TFhirCodeableConcept{4b}
  else inherited;
end;

function TFhirOrganizationContact.FhirType : string;
begin
  result := 'contact';
end;

function TFhirOrganizationContact.Link : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(inherited Link);
end;

function TFhirOrganizationContact.Clone : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(inherited Clone);
end;

{ TFhirOrganizationContact }

Procedure TFhirOrganizationContact.SetPurpose(value : TFhirCodeableConcept);
begin
  FPurpose.free;
  FPurpose := value;
end;

Procedure TFhirOrganizationContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirOrganizationContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

Procedure TFhirOrganizationContact.SetGender(value : TFhirCodeableConcept);
begin
  FGender.free;
  FGender := value;
end;


{ TFhirOrganizationContactListEnumerator }

Constructor TFhirOrganizationContactListEnumerator.Create(list : TFhirOrganizationContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirOrganizationContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOrganizationContactListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirOrganizationContactListEnumerator.GetCurrent : TFhirOrganizationContact;
begin
  Result := FList[FIndex];
end;


{ TFhirOrganizationContactList }
procedure TFhirOrganizationContactList.AddItem(value: TFhirOrganizationContact);
begin
  assert(value.ClassName = 'TFhirOrganizationContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrganizationContact');
  add(value);
end;


function TFhirOrganizationContactList.Append: TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirOrganizationContactList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationContactList.GetEnumerator : TFhirOrganizationContactListEnumerator;
begin
  result := TFhirOrganizationContactListEnumerator.Create(self.link);
end;

function TFhirOrganizationContactList.Clone: TFhirOrganizationContactList;
begin
  result := TFhirOrganizationContactList(inherited Clone);
end;

function TFhirOrganizationContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationContactList.GetItemN(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(ObjectByIndex[index]);
end;

function TFhirOrganizationContactList.IndexOf(value: TFhirOrganizationContact): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirOrganizationContactList.Insert(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirOrganizationContactList.InsertItem(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  Inherited Insert(index, value);
end;

function TFhirOrganizationContactList.Item(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(ObjectByIndex[index]);
end;

function TFhirOrganizationContactList.Link: TFhirOrganizationContactList;
begin
  result := TFhirOrganizationContactList(inherited Link);
end;

procedure TFhirOrganizationContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationContactList.SetItemByIndex(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  FhirOrganizationContacts[index] := value;
end;

procedure TFhirOrganizationContactList.SetItemN(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientContact }

constructor TFhirPatientContact.Create;
begin
  inherited;
  FRelationshipList := TFhirCodeableConceptList.Create;
  FTelecomList := TFhirContactList.Create;
end;

destructor TFhirPatientContact.Destroy;
begin
  FRelationshipList.Free;
  FName.free;
  FTelecomList.Free;
  FAddress.free;
  FGender.free;
  FOrganization.free;
  inherited;
end;

procedure TFhirPatientContact.Assign(oSource : TAdvObject);
begin
  inherited;
  FRelationshipList.Assign(TFhirPatientContact(oSource).FRelationshipList);
  name := TFhirPatientContact(oSource).name.Clone;
  FTelecomList.Assign(TFhirPatientContact(oSource).FTelecomList);
  address := TFhirPatientContact(oSource).address.Clone;
  gender := TFhirPatientContact(oSource).gender.Clone;
  organization := TFhirPatientContact(oSource).organization.Clone;
end;

procedure TFhirPatientContact.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'relationship') Then
     list.addAll(FRelationshipList);
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'telecom') Then
     list.addAll(FTelecomList);
  if (child_name = 'address') Then
     list.add(FAddress.Link);
  if (child_name = 'gender') Then
     list.add(FGender.Link);
  if (child_name = 'organization') Then
     list.add(FOrganization.Link);
end;

procedure TFhirPatientContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', FRelationshipList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'Contact', FTelecomList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'address', 'Address', FAddress.Link));{2}
  oList.add(TFHIRProperty.create(self, 'gender', 'CodeableConcept', FGender.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Resource(Organization)', FOrganization.Link));{2}
end;

procedure TFhirPatientContact.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'relationship') then RelationshipList.add(propValue as TFhirCodeableConcept){2}
  else if (propName = 'name') then Name := propValue as TFhirHumanName{4b}
  else if (propName = 'telecom') then TelecomList.add(propValue as TFhirContact){2}
  else if (propName = 'address') then Address := propValue as TFhirAddress{4b}
  else if (propName = 'gender') then Gender := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'organization') then Organization := propValue as TFhirResourceReference{TFhirOrganization}{4b}
  else inherited;
end;

function TFhirPatientContact.FhirType : string;
begin
  result := 'contact';
end;

function TFhirPatientContact.Link : TFhirPatientContact;
begin
  result := TFhirPatientContact(inherited Link);
end;

function TFhirPatientContact.Clone : TFhirPatientContact;
begin
  result := TFhirPatientContact(inherited Clone);
end;

{ TFhirPatientContact }

Procedure TFhirPatientContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirPatientContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

Procedure TFhirPatientContact.SetGender(value : TFhirCodeableConcept);
begin
  FGender.free;
  FGender := value;
end;

Procedure TFhirPatientContact.SetOrganization(value : TFhirResourceReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;


{ TFhirPatientContactListEnumerator }

Constructor TFhirPatientContactListEnumerator.Create(list : TFhirPatientContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirPatientContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPatientContactListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirPatientContactListEnumerator.GetCurrent : TFhirPatientContact;
begin
  Result := FList[FIndex];
end;


{ TFhirPatientContactList }
procedure TFhirPatientContactList.AddItem(value: TFhirPatientContact);
begin
  assert(value.ClassName = 'TFhirPatientContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientContact');
  add(value);
end;


function TFhirPatientContactList.Append: TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirPatientContactList.ClearItems;
begin
  Clear;
end;

function TFhirPatientContactList.GetEnumerator : TFhirPatientContactListEnumerator;
begin
  result := TFhirPatientContactListEnumerator.Create(self.link);
end;

function TFhirPatientContactList.Clone: TFhirPatientContactList;
begin
  result := TFhirPatientContactList(inherited Clone);
end;

function TFhirPatientContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientContactList.GetItemN(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact(ObjectByIndex[index]);
end;

function TFhirPatientContactList.IndexOf(value: TFhirPatientContact): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirPatientContactList.Insert(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirPatientContactList.InsertItem(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  Inherited Insert(index, value);
end;

function TFhirPatientContactList.Item(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact(ObjectByIndex[index]);
end;

function TFhirPatientContactList.Link: TFhirPatientContactList;
begin
  result := TFhirPatientContactList(inherited Link);
end;

procedure TFhirPatientContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientContactList.SetItemByIndex(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  FhirPatientContacts[index] := value;
end;

procedure TFhirPatientContactList.SetItemN(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientAnimal }

constructor TFhirPatientAnimal.Create;
begin
  inherited;
end;

destructor TFhirPatientAnimal.Destroy;
begin
  FSpecies.free;
  FBreed.free;
  FGenderStatus.free;
  inherited;
end;

procedure TFhirPatientAnimal.Assign(oSource : TAdvObject);
begin
  inherited;
  species := TFhirPatientAnimal(oSource).species.Clone;
  breed := TFhirPatientAnimal(oSource).breed.Clone;
  genderStatus := TFhirPatientAnimal(oSource).genderStatus.Clone;
end;

procedure TFhirPatientAnimal.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'species') Then
     list.add(FSpecies.Link);
  if (child_name = 'breed') Then
     list.add(FBreed.Link);
  if (child_name = 'genderStatus') Then
     list.add(FGenderStatus.Link);
end;

procedure TFhirPatientAnimal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'species', 'CodeableConcept', FSpecies.Link));{2}
  oList.add(TFHIRProperty.create(self, 'breed', 'CodeableConcept', FBreed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'genderStatus', 'CodeableConcept', FGenderStatus.Link));{2}
end;

procedure TFhirPatientAnimal.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'species') then Species := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'breed') then Breed := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'genderStatus') then GenderStatus := propValue as TFhirCodeableConcept{4b}
  else inherited;
end;

function TFhirPatientAnimal.FhirType : string;
begin
  result := 'animal';
end;

function TFhirPatientAnimal.Link : TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal(inherited Link);
end;

function TFhirPatientAnimal.Clone : TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal(inherited Clone);
end;

{ TFhirPatientAnimal }

Procedure TFhirPatientAnimal.SetSpecies(value : TFhirCodeableConcept);
begin
  FSpecies.free;
  FSpecies := value;
end;

Procedure TFhirPatientAnimal.SetBreed(value : TFhirCodeableConcept);
begin
  FBreed.free;
  FBreed := value;
end;

Procedure TFhirPatientAnimal.SetGenderStatus(value : TFhirCodeableConcept);
begin
  FGenderStatus.free;
  FGenderStatus := value;
end;


{ TFhirPatientAnimalListEnumerator }

Constructor TFhirPatientAnimalListEnumerator.Create(list : TFhirPatientAnimalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirPatientAnimalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPatientAnimalListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirPatientAnimalListEnumerator.GetCurrent : TFhirPatientAnimal;
begin
  Result := FList[FIndex];
end;


{ TFhirPatientAnimalList }
procedure TFhirPatientAnimalList.AddItem(value: TFhirPatientAnimal);
begin
  assert(value.ClassName = 'TFhirPatientAnimal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientAnimal');
  add(value);
end;


function TFhirPatientAnimalList.Append: TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirPatientAnimalList.ClearItems;
begin
  Clear;
end;

function TFhirPatientAnimalList.GetEnumerator : TFhirPatientAnimalListEnumerator;
begin
  result := TFhirPatientAnimalListEnumerator.Create(self.link);
end;

function TFhirPatientAnimalList.Clone: TFhirPatientAnimalList;
begin
  result := TFhirPatientAnimalList(inherited Clone);
end;

function TFhirPatientAnimalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientAnimalList.GetItemN(index: Integer): TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal(ObjectByIndex[index]);
end;

function TFhirPatientAnimalList.IndexOf(value: TFhirPatientAnimal): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirPatientAnimalList.Insert(index: Integer): TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirPatientAnimalList.InsertItem(index: Integer; value: TFhirPatientAnimal);
begin
  assert(value is TFhirPatientAnimal);
  Inherited Insert(index, value);
end;

function TFhirPatientAnimalList.Item(index: Integer): TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal(ObjectByIndex[index]);
end;

function TFhirPatientAnimalList.Link: TFhirPatientAnimalList;
begin
  result := TFhirPatientAnimalList(inherited Link);
end;

procedure TFhirPatientAnimalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientAnimalList.SetItemByIndex(index: Integer; value: TFhirPatientAnimal);
begin
  assert(value is TFhirPatientAnimal);
  FhirPatientAnimals[index] := value;
end;

procedure TFhirPatientAnimalList.SetItemN(index: Integer; value: TFhirPatientAnimal);
begin
  assert(value is TFhirPatientAnimal);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientLink }

constructor TFhirPatientLink.Create;
begin
  inherited;
end;

destructor TFhirPatientLink.Destroy;
begin
  FOther.free;
  FType_.free;
  inherited;
end;

procedure TFhirPatientLink.Assign(oSource : TAdvObject);
begin
  inherited;
  other := TFhirPatientLink(oSource).other.Clone;
  FType_ := TFhirPatientLink(oSource).FType_.Link;
end;

procedure TFhirPatientLink.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'other') Then
     list.add(FOther.Link);
  if (child_name = 'type') Then
     list.add(FType_.Link);
end;

procedure TFhirPatientLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'other', 'Resource(Patient)', FOther.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
end;

procedure TFhirPatientLink.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'other') then Other := propValue as TFhirResourceReference{TFhirPatient}{4b}
  else if (propName = 'type') then Type_Object := propValue as TFHIREnum
  else inherited;
end;

function TFhirPatientLink.FhirType : string;
begin
  result := 'link';
end;

function TFhirPatientLink.Link : TFhirPatientLink;
begin
  result := TFhirPatientLink(inherited Link);
end;

function TFhirPatientLink.Clone : TFhirPatientLink;
begin
  result := TFhirPatientLink(inherited Clone);
end;

{ TFhirPatientLink }

Procedure TFhirPatientLink.SetOther(value : TFhirResourceReference{TFhirPatient});
begin
  FOther.free;
  FOther := value;
end;

Procedure TFhirPatientLink.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirPatientLink.GetType_ST : TFhirLinkType;
begin
  if FType_ = nil then
    result := TFhirLinkType(0)
  else
    result := TFhirLinkType(StringArrayIndexOfSensitive(CODES_TFhirLinkType, FType_.value));
end;

Procedure TFhirPatientLink.SetType_ST(value : TFhirLinkType);
begin
  if ord(value) = 0 then
    Type_Object := nil
  else
    Type_Object := TFhirEnum.create(CODES_TFhirLinkType[value]);
end;


{ TFhirPatientLinkListEnumerator }

Constructor TFhirPatientLinkListEnumerator.Create(list : TFhirPatientLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirPatientLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPatientLinkListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirPatientLinkListEnumerator.GetCurrent : TFhirPatientLink;
begin
  Result := FList[FIndex];
end;


{ TFhirPatientLinkList }
procedure TFhirPatientLinkList.AddItem(value: TFhirPatientLink);
begin
  assert(value.ClassName = 'TFhirPatientLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientLink');
  add(value);
end;


function TFhirPatientLinkList.Append: TFhirPatientLink;
begin
  result := TFhirPatientLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirPatientLinkList.ClearItems;
begin
  Clear;
end;

function TFhirPatientLinkList.GetEnumerator : TFhirPatientLinkListEnumerator;
begin
  result := TFhirPatientLinkListEnumerator.Create(self.link);
end;

function TFhirPatientLinkList.Clone: TFhirPatientLinkList;
begin
  result := TFhirPatientLinkList(inherited Clone);
end;

function TFhirPatientLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientLinkList.GetItemN(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink(ObjectByIndex[index]);
end;

function TFhirPatientLinkList.IndexOf(value: TFhirPatientLink): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirPatientLinkList.Insert(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirPatientLinkList.InsertItem(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  Inherited Insert(index, value);
end;

function TFhirPatientLinkList.Item(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink(ObjectByIndex[index]);
end;

function TFhirPatientLinkList.Link: TFhirPatientLinkList;
begin
  result := TFhirPatientLinkList(inherited Link);
end;

procedure TFhirPatientLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientLinkList.SetItemByIndex(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  FhirPatientLinks[index] := value;
end;

procedure TFhirPatientLinkList.SetItemN(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  ObjectByIndex[index] := value;
end;

{ TFhirPractitionerQualification }

constructor TFhirPractitionerQualification.Create;
begin
  inherited;
end;

destructor TFhirPractitionerQualification.Destroy;
begin
  FCode.free;
  FPeriod.free;
  FIssuer.free;
  inherited;
end;

procedure TFhirPractitionerQualification.Assign(oSource : TAdvObject);
begin
  inherited;
  code := TFhirPractitionerQualification(oSource).code.Clone;
  period := TFhirPractitionerQualification(oSource).period.Clone;
  issuer := TFhirPractitionerQualification(oSource).issuer.Clone;
end;

procedure TFhirPractitionerQualification.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'period') Then
     list.add(FPeriod.Link);
  if (child_name = 'issuer') Then
     list.add(FIssuer.Link);
end;

procedure TFhirPractitionerQualification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'issuer', 'Resource(Organization)', FIssuer.Link));{2}
end;

procedure TFhirPractitionerQualification.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then Code := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'period') then Period := propValue as TFhirPeriod{4b}
  else if (propName = 'issuer') then Issuer := propValue as TFhirResourceReference{TFhirOrganization}{4b}
  else inherited;
end;

function TFhirPractitionerQualification.FhirType : string;
begin
  result := 'qualification';
end;

function TFhirPractitionerQualification.Link : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(inherited Link);
end;

function TFhirPractitionerQualification.Clone : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(inherited Clone);
end;

{ TFhirPractitionerQualification }

Procedure TFhirPractitionerQualification.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirPractitionerQualification.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirPractitionerQualification.SetIssuer(value : TFhirResourceReference{TFhirOrganization});
begin
  FIssuer.free;
  FIssuer := value;
end;


{ TFhirPractitionerQualificationListEnumerator }

Constructor TFhirPractitionerQualificationListEnumerator.Create(list : TFhirPractitionerQualificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirPractitionerQualificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPractitionerQualificationListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirPractitionerQualificationListEnumerator.GetCurrent : TFhirPractitionerQualification;
begin
  Result := FList[FIndex];
end;


{ TFhirPractitionerQualificationList }
procedure TFhirPractitionerQualificationList.AddItem(value: TFhirPractitionerQualification);
begin
  assert(value.ClassName = 'TFhirPractitionerQualification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitionerQualification');
  add(value);
end;


function TFhirPractitionerQualificationList.Append: TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirPractitionerQualificationList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerQualificationList.GetEnumerator : TFhirPractitionerQualificationListEnumerator;
begin
  result := TFhirPractitionerQualificationListEnumerator.Create(self.link);
end;

function TFhirPractitionerQualificationList.Clone: TFhirPractitionerQualificationList;
begin
  result := TFhirPractitionerQualificationList(inherited Clone);
end;

function TFhirPractitionerQualificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerQualificationList.GetItemN(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(ObjectByIndex[index]);
end;

function TFhirPractitionerQualificationList.IndexOf(value: TFhirPractitionerQualification): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirPractitionerQualificationList.Insert(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirPractitionerQualificationList.InsertItem(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  Inherited Insert(index, value);
end;

function TFhirPractitionerQualificationList.Item(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(ObjectByIndex[index]);
end;

function TFhirPractitionerQualificationList.Link: TFhirPractitionerQualificationList;
begin
  result := TFhirPractitionerQualificationList(inherited Link);
end;

procedure TFhirPractitionerQualificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerQualificationList.SetItemByIndex(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  FhirPractitionerQualifications[index] := value;
end;

procedure TFhirPractitionerQualificationList.SetItemN(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedurePerformer }

constructor TFhirProcedurePerformer.Create;
begin
  inherited;
end;

destructor TFhirProcedurePerformer.Destroy;
begin
  FPerson.free;
  FRole.free;
  inherited;
end;

procedure TFhirProcedurePerformer.Assign(oSource : TAdvObject);
begin
  inherited;
  person := TFhirProcedurePerformer(oSource).person.Clone;
  role := TFhirProcedurePerformer(oSource).role.Clone;
end;

procedure TFhirProcedurePerformer.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'person') Then
     list.add(FPerson.Link);
  if (child_name = 'role') Then
     list.add(FRole.Link);
end;

procedure TFhirProcedurePerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'person', 'Resource(Practitioner)', FPerson.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', FRole.Link));{2}
end;

procedure TFhirProcedurePerformer.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'person') then Person := propValue as TFhirResourceReference{TFhirPractitioner}{4b}
  else if (propName = 'role') then Role := propValue as TFhirCodeableConcept{4b}
  else inherited;
end;

function TFhirProcedurePerformer.FhirType : string;
begin
  result := 'performer';
end;

function TFhirProcedurePerformer.Link : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(inherited Link);
end;

function TFhirProcedurePerformer.Clone : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(inherited Clone);
end;

{ TFhirProcedurePerformer }

Procedure TFhirProcedurePerformer.SetPerson(value : TFhirResourceReference{TFhirPractitioner});
begin
  FPerson.free;
  FPerson := value;
end;

Procedure TFhirProcedurePerformer.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;


{ TFhirProcedurePerformerListEnumerator }

Constructor TFhirProcedurePerformerListEnumerator.Create(list : TFhirProcedurePerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProcedurePerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedurePerformerListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProcedurePerformerListEnumerator.GetCurrent : TFhirProcedurePerformer;
begin
  Result := FList[FIndex];
end;


{ TFhirProcedurePerformerList }
procedure TFhirProcedurePerformerList.AddItem(value: TFhirProcedurePerformer);
begin
  assert(value.ClassName = 'TFhirProcedurePerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedurePerformer');
  add(value);
end;


function TFhirProcedurePerformerList.Append: TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProcedurePerformerList.ClearItems;
begin
  Clear;
end;

function TFhirProcedurePerformerList.GetEnumerator : TFhirProcedurePerformerListEnumerator;
begin
  result := TFhirProcedurePerformerListEnumerator.Create(self.link);
end;

function TFhirProcedurePerformerList.Clone: TFhirProcedurePerformerList;
begin
  result := TFhirProcedurePerformerList(inherited Clone);
end;

function TFhirProcedurePerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedurePerformerList.GetItemN(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(ObjectByIndex[index]);
end;

function TFhirProcedurePerformerList.IndexOf(value: TFhirProcedurePerformer): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProcedurePerformerList.Insert(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProcedurePerformerList.InsertItem(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  Inherited Insert(index, value);
end;

function TFhirProcedurePerformerList.Item(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(ObjectByIndex[index]);
end;

function TFhirProcedurePerformerList.Link: TFhirProcedurePerformerList;
begin
  result := TFhirProcedurePerformerList(inherited Link);
end;

procedure TFhirProcedurePerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedurePerformerList.SetItemByIndex(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  FhirProcedurePerformers[index] := value;
end;

procedure TFhirProcedurePerformerList.SetItemN(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedureRelatedItem }

constructor TFhirProcedureRelatedItem.Create;
begin
  inherited;
end;

destructor TFhirProcedureRelatedItem.Destroy;
begin
  FType_.free;
  FTarget.free;
  inherited;
end;

procedure TFhirProcedureRelatedItem.Assign(oSource : TAdvObject);
begin
  inherited;
  FType_ := TFhirProcedureRelatedItem(oSource).FType_.Link;
  target := TFhirProcedureRelatedItem(oSource).target.Clone;
end;

procedure TFhirProcedureRelatedItem.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'target') Then
     list.add(FTarget.Link);
end;

procedure TFhirProcedureRelatedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(AdverseReaction|AllergyIntolerance|CarePlan|Condition|DeviceObservationReport|DiagnosticReport|FamilyHistory|ImagingStudy|Immunization|ImmunizationRecommendation|MedicationAdministration|MedicationDispense|MedicationPrescription|MedicationSt'+'atement|Observation|Procedure)', FTarget.Link));{2}
end;

procedure TFhirProcedureRelatedItem.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'type') then Type_Object := propValue as TFHIREnum
  else if (propName = 'target') then Target := propValue as TFhirResourceReference{Resource}{4b}
  else inherited;
end;

function TFhirProcedureRelatedItem.FhirType : string;
begin
  result := 'relatedItem';
end;

function TFhirProcedureRelatedItem.Link : TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem(inherited Link);
end;

function TFhirProcedureRelatedItem.Clone : TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem(inherited Clone);
end;

{ TFhirProcedureRelatedItem }

Procedure TFhirProcedureRelatedItem.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirProcedureRelatedItem.GetType_ST : TFhirProcedureRelationshipType;
begin
  if FType_ = nil then
    result := TFhirProcedureRelationshipType(0)
  else
    result := TFhirProcedureRelationshipType(StringArrayIndexOfSensitive(CODES_TFhirProcedureRelationshipType, FType_.value));
end;

Procedure TFhirProcedureRelatedItem.SetType_ST(value : TFhirProcedureRelationshipType);
begin
  if ord(value) = 0 then
    Type_Object := nil
  else
    Type_Object := TFhirEnum.create(CODES_TFhirProcedureRelationshipType[value]);
end;

Procedure TFhirProcedureRelatedItem.SetTarget(value : TFhirResourceReference{Resource});
begin
  FTarget.free;
  FTarget := value;
end;


{ TFhirProcedureRelatedItemListEnumerator }

Constructor TFhirProcedureRelatedItemListEnumerator.Create(list : TFhirProcedureRelatedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProcedureRelatedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedureRelatedItemListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProcedureRelatedItemListEnumerator.GetCurrent : TFhirProcedureRelatedItem;
begin
  Result := FList[FIndex];
end;


{ TFhirProcedureRelatedItemList }
procedure TFhirProcedureRelatedItemList.AddItem(value: TFhirProcedureRelatedItem);
begin
  assert(value.ClassName = 'TFhirProcedureRelatedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedureRelatedItem');
  add(value);
end;


function TFhirProcedureRelatedItemList.Append: TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProcedureRelatedItemList.ClearItems;
begin
  Clear;
end;

function TFhirProcedureRelatedItemList.GetEnumerator : TFhirProcedureRelatedItemListEnumerator;
begin
  result := TFhirProcedureRelatedItemListEnumerator.Create(self.link);
end;

function TFhirProcedureRelatedItemList.Clone: TFhirProcedureRelatedItemList;
begin
  result := TFhirProcedureRelatedItemList(inherited Clone);
end;

function TFhirProcedureRelatedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedureRelatedItemList.GetItemN(index: Integer): TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem(ObjectByIndex[index]);
end;

function TFhirProcedureRelatedItemList.IndexOf(value: TFhirProcedureRelatedItem): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProcedureRelatedItemList.Insert(index: Integer): TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProcedureRelatedItemList.InsertItem(index: Integer; value: TFhirProcedureRelatedItem);
begin
  assert(value is TFhirProcedureRelatedItem);
  Inherited Insert(index, value);
end;

function TFhirProcedureRelatedItemList.Item(index: Integer): TFhirProcedureRelatedItem;
begin
  result := TFhirProcedureRelatedItem(ObjectByIndex[index]);
end;

function TFhirProcedureRelatedItemList.Link: TFhirProcedureRelatedItemList;
begin
  result := TFhirProcedureRelatedItemList(inherited Link);
end;

procedure TFhirProcedureRelatedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedureRelatedItemList.SetItemByIndex(index: Integer; value: TFhirProcedureRelatedItem);
begin
  assert(value is TFhirProcedureRelatedItem);
  FhirProcedureRelatedItems[index] := value;
end;

procedure TFhirProcedureRelatedItemList.SetItemN(index: Integer; value: TFhirProcedureRelatedItem);
begin
  assert(value is TFhirProcedureRelatedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileMapping }

constructor TFhirProfileMapping.Create;
begin
  inherited;
end;

destructor TFhirProfileMapping.Destroy;
begin
  FIdentity.free;
  FUri.free;
  FName.free;
  FComments.free;
  inherited;
end;

procedure TFhirProfileMapping.Assign(oSource : TAdvObject);
begin
  inherited;
  identityObject := TFhirProfileMapping(oSource).identityObject.Clone;
  uriObject := TFhirProfileMapping(oSource).uriObject.Clone;
  nameObject := TFhirProfileMapping(oSource).nameObject.Clone;
  commentsObject := TFhirProfileMapping(oSource).commentsObject.Clone;
end;

procedure TFhirProfileMapping.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identity') Then
     list.add(FIdentity.Link);
  if (child_name = 'uri') Then
     list.add(FUri.Link);
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'comments') Then
     list.add(FComments.Link);
end;

procedure TFhirProfileMapping.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identity', 'id', FIdentity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', FUri.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comments', 'string', FComments.Link));{2}
end;

procedure TFhirProfileMapping.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'identity') then IdentityObject := propValue as TFhirId{5a}
  else if (propName = 'uri') then UriObject := propValue as TFhirUri{5a}
  else if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'comments') then CommentsObject := propValue as TFhirString{5a}
  else inherited;
end;

function TFhirProfileMapping.FhirType : string;
begin
  result := 'mapping';
end;

function TFhirProfileMapping.Link : TFhirProfileMapping;
begin
  result := TFhirProfileMapping(inherited Link);
end;

function TFhirProfileMapping.Clone : TFhirProfileMapping;
begin
  result := TFhirProfileMapping(inherited Clone);
end;

{ TFhirProfileMapping }

Procedure TFhirProfileMapping.SetIdentity(value : TFhirId);
begin
  FIdentity.free;
  FIdentity := value;
end;

Function TFhirProfileMapping.GetIdentityST : String;
begin
  if FIdentity = nil then
    result := ''
  else
    result := FIdentity.value;
end;

Procedure TFhirProfileMapping.SetIdentityST(value : String);
begin
  if value <> '' then
  begin
    if FIdentity = nil then
      FIdentity := TFhirId.create;
    FIdentity.value := value
  end
  else if FIdentity <> nil then
    FIdentity.value := '';
end;

Procedure TFhirProfileMapping.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

Function TFhirProfileMapping.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

Procedure TFhirProfileMapping.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

Procedure TFhirProfileMapping.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileMapping.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirProfileMapping.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileMapping.SetComments(value : TFhirString);
begin
  FComments.free;
  FComments := value;
end;

Function TFhirProfileMapping.GetCommentsST : String;
begin
  if FComments = nil then
    result := ''
  else
    result := FComments.value;
end;

Procedure TFhirProfileMapping.SetCommentsST(value : String);
begin
  if value <> '' then
  begin
    if FComments = nil then
      FComments := TFhirString.create;
    FComments.value := value
  end
  else if FComments <> nil then
    FComments.value := '';
end;


{ TFhirProfileMappingListEnumerator }

Constructor TFhirProfileMappingListEnumerator.Create(list : TFhirProfileMappingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProfileMappingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProfileMappingListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProfileMappingListEnumerator.GetCurrent : TFhirProfileMapping;
begin
  Result := FList[FIndex];
end;


{ TFhirProfileMappingList }
procedure TFhirProfileMappingList.AddItem(value: TFhirProfileMapping);
begin
  assert(value.ClassName = 'TFhirProfileMapping', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileMapping');
  add(value);
end;


function TFhirProfileMappingList.Append: TFhirProfileMapping;
begin
  result := TFhirProfileMapping.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileMappingList.ClearItems;
begin
  Clear;
end;

function TFhirProfileMappingList.GetEnumerator : TFhirProfileMappingListEnumerator;
begin
  result := TFhirProfileMappingListEnumerator.Create(self.link);
end;

function TFhirProfileMappingList.Clone: TFhirProfileMappingList;
begin
  result := TFhirProfileMappingList(inherited Clone);
end;

function TFhirProfileMappingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileMappingList.GetItemN(index: Integer): TFhirProfileMapping;
begin
  result := TFhirProfileMapping(ObjectByIndex[index]);
end;

function TFhirProfileMappingList.IndexOf(value: TFhirProfileMapping): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileMappingList.Insert(index: Integer): TFhirProfileMapping;
begin
  result := TFhirProfileMapping.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileMappingList.InsertItem(index: Integer; value: TFhirProfileMapping);
begin
  assert(value is TFhirProfileMapping);
  Inherited Insert(index, value);
end;

function TFhirProfileMappingList.Item(index: Integer): TFhirProfileMapping;
begin
  result := TFhirProfileMapping(ObjectByIndex[index]);
end;

function TFhirProfileMappingList.Link: TFhirProfileMappingList;
begin
  result := TFhirProfileMappingList(inherited Link);
end;

procedure TFhirProfileMappingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileMappingList.SetItemByIndex(index: Integer; value: TFhirProfileMapping);
begin
  assert(value is TFhirProfileMapping);
  FhirProfileMappings[index] := value;
end;

procedure TFhirProfileMappingList.SetItemN(index: Integer; value: TFhirProfileMapping);
begin
  assert(value is TFhirProfileMapping);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructure }

constructor TFhirProfileStructure.Create;
begin
  inherited;
  FElementList := TFhirProfileStructureElementList.Create;
  FSearchParamList := TFhirProfileStructureSearchParamList.Create;
end;

destructor TFhirProfileStructure.Destroy;
begin
  FType_.free;
  FName.free;
  FPublish.free;
  FPurpose.free;
  FElementList.Free;
  FSearchParamList.Free;
  inherited;
end;

procedure TFhirProfileStructure.Assign(oSource : TAdvObject);
begin
  inherited;
  type_Object := TFhirProfileStructure(oSource).type_Object.Clone;
  nameObject := TFhirProfileStructure(oSource).nameObject.Clone;
  publishObject := TFhirProfileStructure(oSource).publishObject.Clone;
  purposeObject := TFhirProfileStructure(oSource).purposeObject.Clone;
  FElementList.Assign(TFhirProfileStructure(oSource).FElementList);
  FSearchParamList.Assign(TFhirProfileStructure(oSource).FSearchParamList);
end;

procedure TFhirProfileStructure.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'publish') Then
     list.add(FPublish.Link);
  if (child_name = 'purpose') Then
     list.add(FPurpose.Link);
  if (child_name = 'element') Then
     list.addAll(FElementList);
  if (child_name = 'searchParam') Then
     list.addAll(FSearchParamList);
end;

procedure TFhirProfileStructure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publish', 'boolean', FPublish.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purpose', 'string', FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'element', '', FElementList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'searchParam', '', FSearchParamList.Link)){3};
end;

procedure TFhirProfileStructure.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'type') then
    if propValue is TFHIRCode then
      Type_Object := propValue as TFhirCode{5}
    else if propValue is TFHIREnum then
      Type_Object := TFHIRCode.create(TFHIREnum(propValue).value)
    else
      raise Exception.Create('Type mismatch: cannot convert from "'+propValue.className+'" to "TFHIRCode"'){5a}
  else if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'publish') then PublishObject := propValue as TFhirBoolean{5a}
  else if (propName = 'purpose') then PurposeObject := propValue as TFhirString{5a}
  else if (propName = 'element') then ElementList.add(propValue as TFhirProfileStructureElement){2}
  else if (propName = 'searchParam') then SearchParamList.add(propValue as TFhirProfileStructureSearchParam){2}
  else inherited;
end;

function TFhirProfileStructure.FhirType : string;
begin
  result := 'structure';
end;

function TFhirProfileStructure.Link : TFhirProfileStructure;
begin
  result := TFhirProfileStructure(inherited Link);
end;

function TFhirProfileStructure.Clone : TFhirProfileStructure;
begin
  result := TFhirProfileStructure(inherited Clone);
end;

{ TFhirProfileStructure }

Procedure TFhirProfileStructure.SetType_(value : TFhirCode);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirProfileStructure.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirProfileStructure.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirCode.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirProfileStructure.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileStructure.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirProfileStructure.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileStructure.SetPublish(value : TFhirBoolean);
begin
  FPublish.free;
  FPublish := value;
end;

Function TFhirProfileStructure.GetPublishST : Boolean;
begin
  if FPublish = nil then
    result := false
  else
    result := FPublish.value;
end;

Procedure TFhirProfileStructure.SetPublishST(value : Boolean);
begin
  if FPublish = nil then
    FPublish := TFhirBoolean.create;
  FPublish.value := value
end;

Procedure TFhirProfileStructure.SetPurpose(value : TFhirString);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirProfileStructure.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirProfileStructure.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirString.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;


{ TFhirProfileStructureListEnumerator }

Constructor TFhirProfileStructureListEnumerator.Create(list : TFhirProfileStructureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProfileStructureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProfileStructureListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProfileStructureListEnumerator.GetCurrent : TFhirProfileStructure;
begin
  Result := FList[FIndex];
end;


{ TFhirProfileStructureList }
procedure TFhirProfileStructureList.AddItem(value: TFhirProfileStructure);
begin
  assert(value.ClassName = 'TFhirProfileStructure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructure');
  add(value);
end;


function TFhirProfileStructureList.Append: TFhirProfileStructure;
begin
  result := TFhirProfileStructure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureList.GetEnumerator : TFhirProfileStructureListEnumerator;
begin
  result := TFhirProfileStructureListEnumerator.Create(self.link);
end;

function TFhirProfileStructureList.Clone: TFhirProfileStructureList;
begin
  result := TFhirProfileStructureList(inherited Clone);
end;

function TFhirProfileStructureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureList.GetItemN(index: Integer): TFhirProfileStructure;
begin
  result := TFhirProfileStructure(ObjectByIndex[index]);
end;

function TFhirProfileStructureList.IndexOf(value: TFhirProfileStructure): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureList.Insert(index: Integer): TFhirProfileStructure;
begin
  result := TFhirProfileStructure.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureList.InsertItem(index: Integer; value: TFhirProfileStructure);
begin
  assert(value is TFhirProfileStructure);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureList.Item(index: Integer): TFhirProfileStructure;
begin
  result := TFhirProfileStructure(ObjectByIndex[index]);
end;

function TFhirProfileStructureList.Link: TFhirProfileStructureList;
begin
  result := TFhirProfileStructureList(inherited Link);
end;

procedure TFhirProfileStructureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureList.SetItemByIndex(index: Integer; value: TFhirProfileStructure);
begin
  assert(value is TFhirProfileStructure);
  FhirProfileStructures[index] := value;
end;

procedure TFhirProfileStructureList.SetItemN(index: Integer; value: TFhirProfileStructure);
begin
  assert(value is TFhirProfileStructure);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElement }

constructor TFhirProfileStructureElement.Create;
begin
  inherited;
  FRepresentation := TFHIREnumList.Create;
end;

destructor TFhirProfileStructureElement.Destroy;
begin
  FPath.free;
  FRepresentation.Free;
  FName.free;
  FSlicing.free;
  FDefinition.free;
  inherited;
end;

procedure TFhirProfileStructureElement.Assign(oSource : TAdvObject);
begin
  inherited;
  pathObject := TFhirProfileStructureElement(oSource).pathObject.Clone;
  FRepresentation.Assign(TFhirProfileStructureElement(oSource).FRepresentation);
  nameObject := TFhirProfileStructureElement(oSource).nameObject.Clone;
  slicing := TFhirProfileStructureElement(oSource).slicing.Clone;
  definition := TFhirProfileStructureElement(oSource).definition.Clone;
end;

procedure TFhirProfileStructureElement.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(FPath.Link);
  if (child_name = 'representation') Then
     list.addAll(FRepresentation);
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'slicing') Then
     list.add(FSlicing.Link);
  if (child_name = 'definition') Then
     list.add(FDefinition.Link);
end;

procedure TFhirProfileStructureElement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', FPath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'representation', 'code', FRepresentation.Link)){3};
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'slicing', '', FSlicing.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', '', FDefinition.Link));{2}
end;

procedure TFhirProfileStructureElement.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'path') then PathObject := propValue as TFhirString{5a}
  else if (propName = 'representation') then FRepresentation.add(propValue as TFHIREnum) {1}
  else if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'slicing') then Slicing := propValue as TFhirProfileStructureElementSlicing{4b}
  else if (propName = 'definition') then Definition := propValue as TFhirProfileStructureElementDefinition{4b}
  else inherited;
end;

function TFhirProfileStructureElement.FhirType : string;
begin
  result := 'element';
end;

function TFhirProfileStructureElement.Link : TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement(inherited Link);
end;

function TFhirProfileStructureElement.Clone : TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement(inherited Clone);
end;

{ TFhirProfileStructureElement }

Procedure TFhirProfileStructureElement.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirProfileStructureElement.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirProfileStructureElement.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Function TFhirProfileStructureElement.GetRepresentationST : TFhirPropertyRepresentationList;
  var i : integer;
begin
  result := [];
  for i := 0 to Frepresentation.count - 1 do
    result := result + [TFhirPropertyRepresentation(StringArrayIndexOfSensitive(CODES_TFhirPropertyRepresentation, Frepresentation[i].value))];
end;

Procedure TFhirProfileStructureElement.SetRepresentationST(value : TFhirPropertyRepresentationList);
var a : TFhirPropertyRepresentation;
begin
  Frepresentation.clear;
  for a := low(TFhirPropertyRepresentation) to high(TFhirPropertyRepresentation) do
    if a in value then
      Frepresentation.add(TFhirEnum.create(CODES_TFhirPropertyRepresentation[a]));
end;

Procedure TFhirProfileStructureElement.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileStructureElement.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirProfileStructureElement.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileStructureElement.SetSlicing(value : TFhirProfileStructureElementSlicing);
begin
  FSlicing.free;
  FSlicing := value;
end;

Procedure TFhirProfileStructureElement.SetDefinition(value : TFhirProfileStructureElementDefinition);
begin
  FDefinition.free;
  FDefinition := value;
end;


{ TFhirProfileStructureElementListEnumerator }

Constructor TFhirProfileStructureElementListEnumerator.Create(list : TFhirProfileStructureElementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProfileStructureElementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProfileStructureElementListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProfileStructureElementListEnumerator.GetCurrent : TFhirProfileStructureElement;
begin
  Result := FList[FIndex];
end;


{ TFhirProfileStructureElementList }
procedure TFhirProfileStructureElementList.AddItem(value: TFhirProfileStructureElement);
begin
  assert(value.ClassName = 'TFhirProfileStructureElement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElement');
  add(value);
end;


function TFhirProfileStructureElementList.Append: TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementList.GetEnumerator : TFhirProfileStructureElementListEnumerator;
begin
  result := TFhirProfileStructureElementListEnumerator.Create(self.link);
end;

function TFhirProfileStructureElementList.Clone: TFhirProfileStructureElementList;
begin
  result := TFhirProfileStructureElementList(inherited Clone);
end;

function TFhirProfileStructureElementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementList.GetItemN(index: Integer): TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementList.IndexOf(value: TFhirProfileStructureElement): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementList.Insert(index: Integer): TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementList.InsertItem(index: Integer; value: TFhirProfileStructureElement);
begin
  assert(value is TFhirProfileStructureElement);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementList.Item(index: Integer): TFhirProfileStructureElement;
begin
  result := TFhirProfileStructureElement(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementList.Link: TFhirProfileStructureElementList;
begin
  result := TFhirProfileStructureElementList(inherited Link);
end;

procedure TFhirProfileStructureElementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElement);
begin
  assert(value is TFhirProfileStructureElement);
  FhirProfileStructureElements[index] := value;
end;

procedure TFhirProfileStructureElementList.SetItemN(index: Integer; value: TFhirProfileStructureElement);
begin
  assert(value is TFhirProfileStructureElement);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementSlicing }

constructor TFhirProfileStructureElementSlicing.Create;
begin
  inherited;
end;

destructor TFhirProfileStructureElementSlicing.Destroy;
begin
  FDiscriminator.free;
  FOrdered.free;
  FRules.free;
  inherited;
end;

procedure TFhirProfileStructureElementSlicing.Assign(oSource : TAdvObject);
begin
  inherited;
  discriminatorObject := TFhirProfileStructureElementSlicing(oSource).discriminatorObject.Clone;
  orderedObject := TFhirProfileStructureElementSlicing(oSource).orderedObject.Clone;
  FRules := TFhirProfileStructureElementSlicing(oSource).FRules.Link;
end;

procedure TFhirProfileStructureElementSlicing.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'discriminator') Then
     list.add(FDiscriminator.Link);
  if (child_name = 'ordered') Then
     list.add(FOrdered.Link);
  if (child_name = 'rules') Then
     list.add(FRules.Link);
end;

procedure TFhirProfileStructureElementSlicing.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'discriminator', 'id', FDiscriminator.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ordered', 'boolean', FOrdered.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rules', 'code', FRules.Link));{1}
end;

procedure TFhirProfileStructureElementSlicing.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'discriminator') then DiscriminatorObject := propValue as TFhirId{5a}
  else if (propName = 'ordered') then OrderedObject := propValue as TFhirBoolean{5a}
  else if (propName = 'rules') then RulesObject := propValue as TFHIREnum
  else inherited;
end;

function TFhirProfileStructureElementSlicing.FhirType : string;
begin
  result := 'slicing';
end;

function TFhirProfileStructureElementSlicing.Link : TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing(inherited Link);
end;

function TFhirProfileStructureElementSlicing.Clone : TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing(inherited Clone);
end;

{ TFhirProfileStructureElementSlicing }

Procedure TFhirProfileStructureElementSlicing.SetDiscriminator(value : TFhirId);
begin
  FDiscriminator.free;
  FDiscriminator := value;
end;

Function TFhirProfileStructureElementSlicing.GetDiscriminatorST : String;
begin
  if FDiscriminator = nil then
    result := ''
  else
    result := FDiscriminator.value;
end;

Procedure TFhirProfileStructureElementSlicing.SetDiscriminatorST(value : String);
begin
  if value <> '' then
  begin
    if FDiscriminator = nil then
      FDiscriminator := TFhirId.create;
    FDiscriminator.value := value
  end
  else if FDiscriminator <> nil then
    FDiscriminator.value := '';
end;

Procedure TFhirProfileStructureElementSlicing.SetOrdered(value : TFhirBoolean);
begin
  FOrdered.free;
  FOrdered := value;
end;

Function TFhirProfileStructureElementSlicing.GetOrderedST : Boolean;
begin
  if FOrdered = nil then
    result := false
  else
    result := FOrdered.value;
end;

Procedure TFhirProfileStructureElementSlicing.SetOrderedST(value : Boolean);
begin
  if FOrdered = nil then
    FOrdered := TFhirBoolean.create;
  FOrdered.value := value
end;

Procedure TFhirProfileStructureElementSlicing.SetRules(value : TFhirEnum);
begin
  FRules.free;
  FRules := value;
end;

Function TFhirProfileStructureElementSlicing.GetRulesST : TFhirResourceSlicingRules;
begin
  if FRules = nil then
    result := TFhirResourceSlicingRules(0)
  else
    result := TFhirResourceSlicingRules(StringArrayIndexOfSensitive(CODES_TFhirResourceSlicingRules, FRules.value));
end;

Procedure TFhirProfileStructureElementSlicing.SetRulesST(value : TFhirResourceSlicingRules);
begin
  if ord(value) = 0 then
    RulesObject := nil
  else
    RulesObject := TFhirEnum.create(CODES_TFhirResourceSlicingRules[value]);
end;


{ TFhirProfileStructureElementSlicingListEnumerator }

Constructor TFhirProfileStructureElementSlicingListEnumerator.Create(list : TFhirProfileStructureElementSlicingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProfileStructureElementSlicingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProfileStructureElementSlicingListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProfileStructureElementSlicingListEnumerator.GetCurrent : TFhirProfileStructureElementSlicing;
begin
  Result := FList[FIndex];
end;


{ TFhirProfileStructureElementSlicingList }
procedure TFhirProfileStructureElementSlicingList.AddItem(value: TFhirProfileStructureElementSlicing);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementSlicing', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementSlicing');
  add(value);
end;


function TFhirProfileStructureElementSlicingList.Append: TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementSlicingList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementSlicingList.GetEnumerator : TFhirProfileStructureElementSlicingListEnumerator;
begin
  result := TFhirProfileStructureElementSlicingListEnumerator.Create(self.link);
end;

function TFhirProfileStructureElementSlicingList.Clone: TFhirProfileStructureElementSlicingList;
begin
  result := TFhirProfileStructureElementSlicingList(inherited Clone);
end;

function TFhirProfileStructureElementSlicingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementSlicingList.GetItemN(index: Integer): TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementSlicingList.IndexOf(value: TFhirProfileStructureElementSlicing): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementSlicingList.Insert(index: Integer): TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementSlicingList.InsertItem(index: Integer; value: TFhirProfileStructureElementSlicing);
begin
  assert(value is TFhirProfileStructureElementSlicing);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementSlicingList.Item(index: Integer): TFhirProfileStructureElementSlicing;
begin
  result := TFhirProfileStructureElementSlicing(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementSlicingList.Link: TFhirProfileStructureElementSlicingList;
begin
  result := TFhirProfileStructureElementSlicingList(inherited Link);
end;

procedure TFhirProfileStructureElementSlicingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementSlicingList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementSlicing);
begin
  assert(value is TFhirProfileStructureElementSlicing);
  FhirProfileStructureElementSlicings[index] := value;
end;

procedure TFhirProfileStructureElementSlicingList.SetItemN(index: Integer; value: TFhirProfileStructureElementSlicing);
begin
  assert(value is TFhirProfileStructureElementSlicing);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementDefinition }

constructor TFhirProfileStructureElementDefinition.Create;
begin
  inherited;
  FSynonymList := TFhirStringList.Create;
  FType_List := TFhirProfileStructureElementDefinitionTypeList.Create;
  FConditionList := TFhirIdList.Create;
  FConstraintList := TFhirProfileStructureElementDefinitionConstraintList.Create;
  FMappingList := TFhirProfileStructureElementDefinitionMappingList.Create;
end;

destructor TFhirProfileStructureElementDefinition.Destroy;
begin
  FShort.free;
  FFormal.free;
  FComments.free;
  FRequirements.free;
  FSynonymList.Free;
  FMin.free;
  FMax.free;
  FType_List.Free;
  FNameReference.free;
  FValue.free;
  FExample.free;
  FMaxLength.free;
  FConditionList.Free;
  FConstraintList.Free;
  FMustSupport.free;
  FIsModifier.free;
  FBinding.free;
  FMappingList.Free;
  inherited;
end;

procedure TFhirProfileStructureElementDefinition.Assign(oSource : TAdvObject);
begin
  inherited;
  shortObject := TFhirProfileStructureElementDefinition(oSource).shortObject.Clone;
  formalObject := TFhirProfileStructureElementDefinition(oSource).formalObject.Clone;
  commentsObject := TFhirProfileStructureElementDefinition(oSource).commentsObject.Clone;
  requirementsObject := TFhirProfileStructureElementDefinition(oSource).requirementsObject.Clone;
  FSynonymList.Assign(TFhirProfileStructureElementDefinition(oSource).FSynonymList);
  minObject := TFhirProfileStructureElementDefinition(oSource).minObject.Clone;
  maxObject := TFhirProfileStructureElementDefinition(oSource).maxObject.Clone;
  FType_List.Assign(TFhirProfileStructureElementDefinition(oSource).FType_List);
  nameReferenceObject := TFhirProfileStructureElementDefinition(oSource).nameReferenceObject.Clone;
  value := TFhirProfileStructureElementDefinition(oSource).value.Clone;
  example := TFhirProfileStructureElementDefinition(oSource).example.Clone;
  maxLengthObject := TFhirProfileStructureElementDefinition(oSource).maxLengthObject.Clone;
  FConditionList.Assign(TFhirProfileStructureElementDefinition(oSource).FConditionList);
  FConstraintList.Assign(TFhirProfileStructureElementDefinition(oSource).FConstraintList);
  mustSupportObject := TFhirProfileStructureElementDefinition(oSource).mustSupportObject.Clone;
  isModifierObject := TFhirProfileStructureElementDefinition(oSource).isModifierObject.Clone;
  binding := TFhirProfileStructureElementDefinition(oSource).binding.Clone;
  FMappingList.Assign(TFhirProfileStructureElementDefinition(oSource).FMappingList);
end;

procedure TFhirProfileStructureElementDefinition.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'short') Then
     list.add(FShort.Link);
  if (child_name = 'formal') Then
     list.add(FFormal.Link);
  if (child_name = 'comments') Then
     list.add(FComments.Link);
  if (child_name = 'requirements') Then
     list.add(FRequirements.Link);
  if (child_name = 'synonym') Then
     list.addAll(FSynonymList);
  if (child_name = 'min') Then
     list.add(FMin.Link);
  if (child_name = 'max') Then
     list.add(FMax.Link);
  if (child_name = 'type') Then
     list.addAll(FType_List);
  if (child_name = 'nameReference') Then
     list.add(FNameReference.Link);
  if (child_name = 'value[x]') Then
     list.add(FValue.Link);
  if (child_name = 'example[x]') Then
     list.add(FExample.Link);
  if (child_name = 'maxLength') Then
     list.add(FMaxLength.Link);
  if (child_name = 'condition') Then
     list.addAll(FConditionList);
  if (child_name = 'constraint') Then
     list.addAll(FConstraintList);
  if (child_name = 'mustSupport') Then
     list.add(FMustSupport.Link);
  if (child_name = 'isModifier') Then
     list.add(FIsModifier.Link);
  if (child_name = 'binding') Then
     list.add(FBinding.Link);
  if (child_name = 'mapping') Then
     list.addAll(FMappingList);
end;

procedure TFhirProfileStructureElementDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'short', 'string', FShort.Link));{2}
  oList.add(TFHIRProperty.create(self, 'formal', 'string', FFormal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comments', 'string', FComments.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requirements', 'string', FRequirements.Link));{2}
  oList.add(TFHIRProperty.create(self, 'synonym', 'string', FSynonymList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'min', 'integer', FMin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'max', 'string', FMax.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', '', FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'nameReference', 'string', FNameReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', '*', FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'example[x]', '*', FExample.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxLength', 'integer', FMaxLength.Link));{2}
  oList.add(TFHIRProperty.create(self, 'condition', 'id', FConditionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'constraint', '', FConstraintList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'mustSupport', 'boolean', FMustSupport.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isModifier', 'boolean', FIsModifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'binding', '', FBinding.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mapping', '', FMappingList.Link)){3};
end;

procedure TFhirProfileStructureElementDefinition.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'short') then ShortObject := propValue as TFhirString{5a}
  else if (propName = 'formal') then FormalObject := propValue as TFhirString{5a}
  else if (propName = 'comments') then CommentsObject := propValue as TFhirString{5a}
  else if (propName = 'requirements') then RequirementsObject := propValue as TFhirString{5a}
  else if (propName = 'synonym') then SynonymList.add(propValue as TFhirString){2}
  else if (propName = 'min') then MinObject := propValue as TFhirInteger{5a}
  else if (propName = 'max') then MaxObject := propValue as TFhirString{5a}
  else if (propName = 'type') then Type_List.add(propValue as TFhirProfileStructureElementDefinitionType){2}
  else if (propName = 'nameReference') then NameReferenceObject := propValue as TFhirString{5a}
  else if (propName.startsWith('value')) then Value := propValue as TFhirType{4}
  else if (propName.startsWith('example')) then Example := propValue as TFhirType{4}
  else if (propName = 'maxLength') then MaxLengthObject := propValue as TFhirInteger{5a}
  else if (propName = 'condition') then ConditionList.add(propValue as TFhirId){2}
  else if (propName = 'constraint') then ConstraintList.add(propValue as TFhirProfileStructureElementDefinitionConstraint){2}
  else if (propName = 'mustSupport') then MustSupportObject := propValue as TFhirBoolean{5a}
  else if (propName = 'isModifier') then IsModifierObject := propValue as TFhirBoolean{5a}
  else if (propName = 'binding') then Binding := propValue as TFhirProfileStructureElementDefinitionBinding{4b}
  else if (propName = 'mapping') then MappingList.add(propValue as TFhirProfileStructureElementDefinitionMapping){2}
  else inherited;
end;

function TFhirProfileStructureElementDefinition.FhirType : string;
begin
  result := 'definition';
end;

function TFhirProfileStructureElementDefinition.Link : TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition(inherited Link);
end;

function TFhirProfileStructureElementDefinition.Clone : TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition(inherited Clone);
end;

{ TFhirProfileStructureElementDefinition }

Procedure TFhirProfileStructureElementDefinition.SetShort(value : TFhirString);
begin
  FShort.free;
  FShort := value;
end;

Function TFhirProfileStructureElementDefinition.GetShortST : String;
begin
  if FShort = nil then
    result := ''
  else
    result := FShort.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetShortST(value : String);
begin
  if value <> '' then
  begin
    if FShort = nil then
      FShort := TFhirString.create;
    FShort.value := value
  end
  else if FShort <> nil then
    FShort.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetFormal(value : TFhirString);
begin
  FFormal.free;
  FFormal := value;
end;

Function TFhirProfileStructureElementDefinition.GetFormalST : String;
begin
  if FFormal = nil then
    result := ''
  else
    result := FFormal.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetFormalST(value : String);
begin
  if value <> '' then
  begin
    if FFormal = nil then
      FFormal := TFhirString.create;
    FFormal.value := value
  end
  else if FFormal <> nil then
    FFormal.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetComments(value : TFhirString);
begin
  FComments.free;
  FComments := value;
end;

Function TFhirProfileStructureElementDefinition.GetCommentsST : String;
begin
  if FComments = nil then
    result := ''
  else
    result := FComments.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetCommentsST(value : String);
begin
  if value <> '' then
  begin
    if FComments = nil then
      FComments := TFhirString.create;
    FComments.value := value
  end
  else if FComments <> nil then
    FComments.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetRequirements(value : TFhirString);
begin
  FRequirements.free;
  FRequirements := value;
end;

Function TFhirProfileStructureElementDefinition.GetRequirementsST : String;
begin
  if FRequirements = nil then
    result := ''
  else
    result := FRequirements.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetRequirementsST(value : String);
begin
  if value <> '' then
  begin
    if FRequirements = nil then
      FRequirements := TFhirString.create;
    FRequirements.value := value
  end
  else if FRequirements <> nil then
    FRequirements.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetMin(value : TFhirInteger);
begin
  FMin.free;
  FMin := value;
end;

Function TFhirProfileStructureElementDefinition.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := FMin.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirInteger.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

Function TFhirProfileStructureElementDefinition.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := FMax.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetNameReference(value : TFhirString);
begin
  FNameReference.free;
  FNameReference := value;
end;

Function TFhirProfileStructureElementDefinition.GetNameReferenceST : String;
begin
  if FNameReference = nil then
    result := ''
  else
    result := FNameReference.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetNameReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FNameReference = nil then
      FNameReference := TFhirString.create;
    FNameReference.value := value
  end
  else if FNameReference <> nil then
    FNameReference.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirProfileStructureElementDefinition.SetExample(value : TFhirType);
begin
  FExample.free;
  FExample := value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMaxLength(value : TFhirInteger);
begin
  FMaxLength.free;
  FMaxLength := value;
end;

Function TFhirProfileStructureElementDefinition.GetMaxLengthST : String;
begin
  if FMaxLength = nil then
    result := ''
  else
    result := FMaxLength.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMaxLengthST(value : String);
begin
  if value <> '' then
  begin
    if FMaxLength = nil then
      FMaxLength := TFhirInteger.create;
    FMaxLength.value := value
  end
  else if FMaxLength <> nil then
    FMaxLength.value := '';
end;

Procedure TFhirProfileStructureElementDefinition.SetMustSupport(value : TFhirBoolean);
begin
  FMustSupport.free;
  FMustSupport := value;
end;

Function TFhirProfileStructureElementDefinition.GetMustSupportST : Boolean;
begin
  if FMustSupport = nil then
    result := false
  else
    result := FMustSupport.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetMustSupportST(value : Boolean);
begin
  if FMustSupport = nil then
    FMustSupport := TFhirBoolean.create;
  FMustSupport.value := value
end;

Procedure TFhirProfileStructureElementDefinition.SetIsModifier(value : TFhirBoolean);
begin
  FIsModifier.free;
  FIsModifier := value;
end;

Function TFhirProfileStructureElementDefinition.GetIsModifierST : Boolean;
begin
  if FIsModifier = nil then
    result := false
  else
    result := FIsModifier.value;
end;

Procedure TFhirProfileStructureElementDefinition.SetIsModifierST(value : Boolean);
begin
  if FIsModifier = nil then
    FIsModifier := TFhirBoolean.create;
  FIsModifier.value := value
end;

Procedure TFhirProfileStructureElementDefinition.SetBinding(value : TFhirProfileStructureElementDefinitionBinding);
begin
  FBinding.free;
  FBinding := value;
end;


{ TFhirProfileStructureElementDefinitionListEnumerator }

Constructor TFhirProfileStructureElementDefinitionListEnumerator.Create(list : TFhirProfileStructureElementDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProfileStructureElementDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProfileStructureElementDefinitionListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProfileStructureElementDefinitionListEnumerator.GetCurrent : TFhirProfileStructureElementDefinition;
begin
  Result := FList[FIndex];
end;


{ TFhirProfileStructureElementDefinitionList }
procedure TFhirProfileStructureElementDefinitionList.AddItem(value: TFhirProfileStructureElementDefinition);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementDefinition');
  add(value);
end;


function TFhirProfileStructureElementDefinitionList.Append: TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementDefinitionList.GetEnumerator : TFhirProfileStructureElementDefinitionListEnumerator;
begin
  result := TFhirProfileStructureElementDefinitionListEnumerator.Create(self.link);
end;

function TFhirProfileStructureElementDefinitionList.Clone: TFhirProfileStructureElementDefinitionList;
begin
  result := TFhirProfileStructureElementDefinitionList(inherited Clone);
end;

function TFhirProfileStructureElementDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementDefinitionList.GetItemN(index: Integer): TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionList.IndexOf(value: TFhirProfileStructureElementDefinition): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementDefinitionList.Insert(index: Integer): TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionList.InsertItem(index: Integer; value: TFhirProfileStructureElementDefinition);
begin
  assert(value is TFhirProfileStructureElementDefinition);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementDefinitionList.Item(index: Integer): TFhirProfileStructureElementDefinition;
begin
  result := TFhirProfileStructureElementDefinition(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionList.Link: TFhirProfileStructureElementDefinitionList;
begin
  result := TFhirProfileStructureElementDefinitionList(inherited Link);
end;

procedure TFhirProfileStructureElementDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementDefinitionList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementDefinition);
begin
  assert(value is TFhirProfileStructureElementDefinition);
  FhirProfileStructureElementDefinitions[index] := value;
end;

procedure TFhirProfileStructureElementDefinitionList.SetItemN(index: Integer; value: TFhirProfileStructureElementDefinition);
begin
  assert(value is TFhirProfileStructureElementDefinition);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementDefinitionType }

constructor TFhirProfileStructureElementDefinitionType.Create;
begin
  inherited;
  FAggregation := TFHIREnumList.Create;
end;

destructor TFhirProfileStructureElementDefinitionType.Destroy;
begin
  FCode.free;
  FProfile.free;
  FAggregation.Free;
  inherited;
end;

procedure TFhirProfileStructureElementDefinitionType.Assign(oSource : TAdvObject);
begin
  inherited;
  codeObject := TFhirProfileStructureElementDefinitionType(oSource).codeObject.Clone;
  profileObject := TFhirProfileStructureElementDefinitionType(oSource).profileObject.Clone;
  FAggregation.Assign(TFhirProfileStructureElementDefinitionType(oSource).FAggregation);
end;

procedure TFhirProfileStructureElementDefinitionType.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'profile') Then
     list.add(FProfile.Link);
  if (child_name = 'aggregation') Then
     list.addAll(FAggregation);
end;

procedure TFhirProfileStructureElementDefinitionType.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'uri', FProfile.Link));{2}
  oList.add(TFHIRProperty.create(self, 'aggregation', 'code', FAggregation.Link)){3};
end;

procedure TFhirProfileStructureElementDefinitionType.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then
    if propValue is TFHIRCode then
      CodeObject := propValue as TFhirCode{5}
    else if propValue is TFHIREnum then
      CodeObject := TFHIRCode.create(TFHIREnum(propValue).value)
    else
      raise Exception.Create('Type mismatch: cannot convert from "'+propValue.className+'" to "TFHIRCode"'){5a}
  else if (propName = 'profile') then ProfileObject := propValue as TFhirUri{5a}
  else if (propName = 'aggregation') then FAggregation.add(propValue as TFHIREnum) {1}
  else inherited;
end;

function TFhirProfileStructureElementDefinitionType.FhirType : string;
begin
  result := 'type';
end;

function TFhirProfileStructureElementDefinitionType.Link : TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType(inherited Link);
end;

function TFhirProfileStructureElementDefinitionType.Clone : TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType(inherited Clone);
end;

{ TFhirProfileStructureElementDefinitionType }

Procedure TFhirProfileStructureElementDefinitionType.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirProfileStructureElementDefinitionType.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirProfileStructureElementDefinitionType.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionType.SetProfile(value : TFhirUri);
begin
  FProfile.free;
  FProfile := value;
end;

Function TFhirProfileStructureElementDefinitionType.GetProfileST : String;
begin
  if FProfile = nil then
    result := ''
  else
    result := FProfile.value;
end;

Procedure TFhirProfileStructureElementDefinitionType.SetProfileST(value : String);
begin
  if value <> '' then
  begin
    if FProfile = nil then
      FProfile := TFhirUri.create;
    FProfile.value := value
  end
  else if FProfile <> nil then
    FProfile.value := '';
end;

Function TFhirProfileStructureElementDefinitionType.GetAggregationST : TFhirResourceAggregationModeList;
  var i : integer;
begin
  result := [];
  for i := 0 to Faggregation.count - 1 do
    result := result + [TFhirResourceAggregationMode(StringArrayIndexOfSensitive(CODES_TFhirResourceAggregationMode, Faggregation[i].value))];
end;

Procedure TFhirProfileStructureElementDefinitionType.SetAggregationST(value : TFhirResourceAggregationModeList);
var a : TFhirResourceAggregationMode;
begin
  Faggregation.clear;
  for a := low(TFhirResourceAggregationMode) to high(TFhirResourceAggregationMode) do
    if a in value then
      Faggregation.add(TFhirEnum.create(CODES_TFhirResourceAggregationMode[a]));
end;


{ TFhirProfileStructureElementDefinitionTypeListEnumerator }

Constructor TFhirProfileStructureElementDefinitionTypeListEnumerator.Create(list : TFhirProfileStructureElementDefinitionTypeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProfileStructureElementDefinitionTypeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProfileStructureElementDefinitionTypeListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProfileStructureElementDefinitionTypeListEnumerator.GetCurrent : TFhirProfileStructureElementDefinitionType;
begin
  Result := FList[FIndex];
end;


{ TFhirProfileStructureElementDefinitionTypeList }
procedure TFhirProfileStructureElementDefinitionTypeList.AddItem(value: TFhirProfileStructureElementDefinitionType);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementDefinitionType', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementDefinitionType');
  add(value);
end;


function TFhirProfileStructureElementDefinitionTypeList.Append: TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionTypeList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementDefinitionTypeList.GetEnumerator : TFhirProfileStructureElementDefinitionTypeListEnumerator;
begin
  result := TFhirProfileStructureElementDefinitionTypeListEnumerator.Create(self.link);
end;

function TFhirProfileStructureElementDefinitionTypeList.Clone: TFhirProfileStructureElementDefinitionTypeList;
begin
  result := TFhirProfileStructureElementDefinitionTypeList(inherited Clone);
end;

function TFhirProfileStructureElementDefinitionTypeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementDefinitionTypeList.GetItemN(index: Integer): TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionTypeList.IndexOf(value: TFhirProfileStructureElementDefinitionType): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementDefinitionTypeList.Insert(index: Integer): TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionTypeList.InsertItem(index: Integer; value: TFhirProfileStructureElementDefinitionType);
begin
  assert(value is TFhirProfileStructureElementDefinitionType);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementDefinitionTypeList.Item(index: Integer): TFhirProfileStructureElementDefinitionType;
begin
  result := TFhirProfileStructureElementDefinitionType(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionTypeList.Link: TFhirProfileStructureElementDefinitionTypeList;
begin
  result := TFhirProfileStructureElementDefinitionTypeList(inherited Link);
end;

procedure TFhirProfileStructureElementDefinitionTypeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementDefinitionTypeList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementDefinitionType);
begin
  assert(value is TFhirProfileStructureElementDefinitionType);
  FhirProfileStructureElementDefinitionTypes[index] := value;
end;

procedure TFhirProfileStructureElementDefinitionTypeList.SetItemN(index: Integer; value: TFhirProfileStructureElementDefinitionType);
begin
  assert(value is TFhirProfileStructureElementDefinitionType);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementDefinitionConstraint }

constructor TFhirProfileStructureElementDefinitionConstraint.Create;
begin
  inherited;
end;

destructor TFhirProfileStructureElementDefinitionConstraint.Destroy;
begin
  FKey.free;
  FName.free;
  FSeverity.free;
  FHuman.free;
  FXpath.free;
  inherited;
end;

procedure TFhirProfileStructureElementDefinitionConstraint.Assign(oSource : TAdvObject);
begin
  inherited;
  keyObject := TFhirProfileStructureElementDefinitionConstraint(oSource).keyObject.Clone;
  nameObject := TFhirProfileStructureElementDefinitionConstraint(oSource).nameObject.Clone;
  FSeverity := TFhirProfileStructureElementDefinitionConstraint(oSource).FSeverity.Link;
  humanObject := TFhirProfileStructureElementDefinitionConstraint(oSource).humanObject.Clone;
  xpathObject := TFhirProfileStructureElementDefinitionConstraint(oSource).xpathObject.Clone;
end;

procedure TFhirProfileStructureElementDefinitionConstraint.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'key') Then
     list.add(FKey.Link);
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'severity') Then
     list.add(FSeverity.Link);
  if (child_name = 'human') Then
     list.add(FHuman.Link);
  if (child_name = 'xpath') Then
     list.add(FXpath.Link);
end;

procedure TFhirProfileStructureElementDefinitionConstraint.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'key', 'id', FKey.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'severity', 'code', FSeverity.Link));{1}
  oList.add(TFHIRProperty.create(self, 'human', 'string', FHuman.Link));{2}
  oList.add(TFHIRProperty.create(self, 'xpath', 'string', FXpath.Link));{2}
end;

procedure TFhirProfileStructureElementDefinitionConstraint.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'key') then KeyObject := propValue as TFhirId{5a}
  else if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'severity') then SeverityObject := propValue as TFHIREnum
  else if (propName = 'human') then HumanObject := propValue as TFhirString{5a}
  else if (propName = 'xpath') then XpathObject := propValue as TFhirString{5a}
  else inherited;
end;

function TFhirProfileStructureElementDefinitionConstraint.FhirType : string;
begin
  result := 'constraint';
end;

function TFhirProfileStructureElementDefinitionConstraint.Link : TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint(inherited Link);
end;

function TFhirProfileStructureElementDefinitionConstraint.Clone : TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint(inherited Clone);
end;

{ TFhirProfileStructureElementDefinitionConstraint }

Procedure TFhirProfileStructureElementDefinitionConstraint.SetKey(value : TFhirId);
begin
  FKey.free;
  FKey := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetKeyST : String;
begin
  if FKey = nil then
    result := ''
  else
    result := FKey.value;
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetKeyST(value : String);
begin
  if value <> '' then
  begin
    if FKey = nil then
      FKey := TFhirId.create;
    FKey.value := value
  end
  else if FKey <> nil then
    FKey.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetSeverityST : TFhirConstraintSeverity;
begin
  if FSeverity = nil then
    result := TFhirConstraintSeverity(0)
  else
    result := TFhirConstraintSeverity(StringArrayIndexOfSensitive(CODES_TFhirConstraintSeverity, FSeverity.value));
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetSeverityST(value : TFhirConstraintSeverity);
begin
  if ord(value) = 0 then
    SeverityObject := nil
  else
    SeverityObject := TFhirEnum.create(CODES_TFhirConstraintSeverity[value]);
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetHuman(value : TFhirString);
begin
  FHuman.free;
  FHuman := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetHumanST : String;
begin
  if FHuman = nil then
    result := ''
  else
    result := FHuman.value;
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetHumanST(value : String);
begin
  if value <> '' then
  begin
    if FHuman = nil then
      FHuman := TFhirString.create;
    FHuman.value := value
  end
  else if FHuman <> nil then
    FHuman.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetXpath(value : TFhirString);
begin
  FXpath.free;
  FXpath := value;
end;

Function TFhirProfileStructureElementDefinitionConstraint.GetXpathST : String;
begin
  if FXpath = nil then
    result := ''
  else
    result := FXpath.value;
end;

Procedure TFhirProfileStructureElementDefinitionConstraint.SetXpathST(value : String);
begin
  if value <> '' then
  begin
    if FXpath = nil then
      FXpath := TFhirString.create;
    FXpath.value := value
  end
  else if FXpath <> nil then
    FXpath.value := '';
end;


{ TFhirProfileStructureElementDefinitionConstraintListEnumerator }

Constructor TFhirProfileStructureElementDefinitionConstraintListEnumerator.Create(list : TFhirProfileStructureElementDefinitionConstraintList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProfileStructureElementDefinitionConstraintListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProfileStructureElementDefinitionConstraintListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProfileStructureElementDefinitionConstraintListEnumerator.GetCurrent : TFhirProfileStructureElementDefinitionConstraint;
begin
  Result := FList[FIndex];
end;


{ TFhirProfileStructureElementDefinitionConstraintList }
procedure TFhirProfileStructureElementDefinitionConstraintList.AddItem(value: TFhirProfileStructureElementDefinitionConstraint);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementDefinitionConstraint', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementDefinitionConstraint');
  add(value);
end;


function TFhirProfileStructureElementDefinitionConstraintList.Append: TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionConstraintList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementDefinitionConstraintList.GetEnumerator : TFhirProfileStructureElementDefinitionConstraintListEnumerator;
begin
  result := TFhirProfileStructureElementDefinitionConstraintListEnumerator.Create(self.link);
end;

function TFhirProfileStructureElementDefinitionConstraintList.Clone: TFhirProfileStructureElementDefinitionConstraintList;
begin
  result := TFhirProfileStructureElementDefinitionConstraintList(inherited Clone);
end;

function TFhirProfileStructureElementDefinitionConstraintList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementDefinitionConstraintList.GetItemN(index: Integer): TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionConstraintList.IndexOf(value: TFhirProfileStructureElementDefinitionConstraint): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementDefinitionConstraintList.Insert(index: Integer): TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionConstraintList.InsertItem(index: Integer; value: TFhirProfileStructureElementDefinitionConstraint);
begin
  assert(value is TFhirProfileStructureElementDefinitionConstraint);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementDefinitionConstraintList.Item(index: Integer): TFhirProfileStructureElementDefinitionConstraint;
begin
  result := TFhirProfileStructureElementDefinitionConstraint(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionConstraintList.Link: TFhirProfileStructureElementDefinitionConstraintList;
begin
  result := TFhirProfileStructureElementDefinitionConstraintList(inherited Link);
end;

procedure TFhirProfileStructureElementDefinitionConstraintList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementDefinitionConstraintList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementDefinitionConstraint);
begin
  assert(value is TFhirProfileStructureElementDefinitionConstraint);
  FhirProfileStructureElementDefinitionConstraints[index] := value;
end;

procedure TFhirProfileStructureElementDefinitionConstraintList.SetItemN(index: Integer; value: TFhirProfileStructureElementDefinitionConstraint);
begin
  assert(value is TFhirProfileStructureElementDefinitionConstraint);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementDefinitionBinding }

constructor TFhirProfileStructureElementDefinitionBinding.Create;
begin
  inherited;
end;

destructor TFhirProfileStructureElementDefinitionBinding.Destroy;
begin
  FName.free;
  FIsExtensible.free;
  FConformance.free;
  FDescription.free;
  FReference.free;
  inherited;
end;

procedure TFhirProfileStructureElementDefinitionBinding.Assign(oSource : TAdvObject);
begin
  inherited;
  nameObject := TFhirProfileStructureElementDefinitionBinding(oSource).nameObject.Clone;
  isExtensibleObject := TFhirProfileStructureElementDefinitionBinding(oSource).isExtensibleObject.Clone;
  FConformance := TFhirProfileStructureElementDefinitionBinding(oSource).FConformance.Link;
  descriptionObject := TFhirProfileStructureElementDefinitionBinding(oSource).descriptionObject.Clone;
  reference := TFhirProfileStructureElementDefinitionBinding(oSource).reference.Clone;
end;

procedure TFhirProfileStructureElementDefinitionBinding.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'isExtensible') Then
     list.add(FIsExtensible.Link);
  if (child_name = 'conformance') Then
     list.add(FConformance.Link);
  if (child_name = 'description') Then
     list.add(FDescription.Link);
  if (child_name = 'reference[x]') Then
     list.add(FReference.Link);
end;

procedure TFhirProfileStructureElementDefinitionBinding.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isExtensible', 'boolean', FIsExtensible.Link));{2}
  oList.add(TFHIRProperty.create(self, 'conformance', 'code', FConformance.Link));{1}
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference[x]', 'uri|Resource(ValueSet)', FReference.Link));{2}
end;

procedure TFhirProfileStructureElementDefinitionBinding.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'isExtensible') then IsExtensibleObject := propValue as TFhirBoolean{5a}
  else if (propName = 'conformance') then ConformanceObject := propValue as TFHIREnum
  else if (propName = 'description') then DescriptionObject := propValue as TFhirString{5a}
  else if (propName.startsWith('reference')) then Reference := propValue as TFhirType{4}
  else inherited;
end;

function TFhirProfileStructureElementDefinitionBinding.FhirType : string;
begin
  result := 'binding';
end;

function TFhirProfileStructureElementDefinitionBinding.Link : TFhirProfileStructureElementDefinitionBinding;
begin
  result := TFhirProfileStructureElementDefinitionBinding(inherited Link);
end;

function TFhirProfileStructureElementDefinitionBinding.Clone : TFhirProfileStructureElementDefinitionBinding;
begin
  result := TFhirProfileStructureElementDefinitionBinding(inherited Clone);
end;

{ TFhirProfileStructureElementDefinitionBinding }

Procedure TFhirProfileStructureElementDefinitionBinding.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileStructureElementDefinitionBinding.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetIsExtensible(value : TFhirBoolean);
begin
  FIsExtensible.free;
  FIsExtensible := value;
end;

Function TFhirProfileStructureElementDefinitionBinding.GetIsExtensibleST : Boolean;
begin
  if FIsExtensible = nil then
    result := false
  else
    result := FIsExtensible.value;
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetIsExtensibleST(value : Boolean);
begin
  if FIsExtensible = nil then
    FIsExtensible := TFhirBoolean.create;
  FIsExtensible.value := value
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetConformance(value : TFhirEnum);
begin
  FConformance.free;
  FConformance := value;
end;

Function TFhirProfileStructureElementDefinitionBinding.GetConformanceST : TFhirBindingConformance;
begin
  if FConformance = nil then
    result := TFhirBindingConformance(0)
  else
    result := TFhirBindingConformance(StringArrayIndexOfSensitive(CODES_TFhirBindingConformance, FConformance.value));
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetConformanceST(value : TFhirBindingConformance);
begin
  if ord(value) = 0 then
    ConformanceObject := nil
  else
    ConformanceObject := TFhirEnum.create(CODES_TFhirBindingConformance[value]);
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirProfileStructureElementDefinitionBinding.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionBinding.SetReference(value : TFhirType);
begin
  FReference.free;
  FReference := value;
end;


{ TFhirProfileStructureElementDefinitionBindingListEnumerator }

Constructor TFhirProfileStructureElementDefinitionBindingListEnumerator.Create(list : TFhirProfileStructureElementDefinitionBindingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProfileStructureElementDefinitionBindingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProfileStructureElementDefinitionBindingListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProfileStructureElementDefinitionBindingListEnumerator.GetCurrent : TFhirProfileStructureElementDefinitionBinding;
begin
  Result := FList[FIndex];
end;


{ TFhirProfileStructureElementDefinitionBindingList }
procedure TFhirProfileStructureElementDefinitionBindingList.AddItem(value: TFhirProfileStructureElementDefinitionBinding);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementDefinitionBinding', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementDefinitionBinding');
  add(value);
end;


function TFhirProfileStructureElementDefinitionBindingList.Append: TFhirProfileStructureElementDefinitionBinding;
begin
  result := TFhirProfileStructureElementDefinitionBinding.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionBindingList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementDefinitionBindingList.GetEnumerator : TFhirProfileStructureElementDefinitionBindingListEnumerator;
begin
  result := TFhirProfileStructureElementDefinitionBindingListEnumerator.Create(self.link);
end;

function TFhirProfileStructureElementDefinitionBindingList.Clone: TFhirProfileStructureElementDefinitionBindingList;
begin
  result := TFhirProfileStructureElementDefinitionBindingList(inherited Clone);
end;

function TFhirProfileStructureElementDefinitionBindingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementDefinitionBindingList.GetItemN(index: Integer): TFhirProfileStructureElementDefinitionBinding;
begin
  result := TFhirProfileStructureElementDefinitionBinding(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionBindingList.IndexOf(value: TFhirProfileStructureElementDefinitionBinding): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementDefinitionBindingList.Insert(index: Integer): TFhirProfileStructureElementDefinitionBinding;
begin
  result := TFhirProfileStructureElementDefinitionBinding.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionBindingList.InsertItem(index: Integer; value: TFhirProfileStructureElementDefinitionBinding);
begin
  assert(value is TFhirProfileStructureElementDefinitionBinding);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementDefinitionBindingList.Item(index: Integer): TFhirProfileStructureElementDefinitionBinding;
begin
  result := TFhirProfileStructureElementDefinitionBinding(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionBindingList.Link: TFhirProfileStructureElementDefinitionBindingList;
begin
  result := TFhirProfileStructureElementDefinitionBindingList(inherited Link);
end;

procedure TFhirProfileStructureElementDefinitionBindingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementDefinitionBindingList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementDefinitionBinding);
begin
  assert(value is TFhirProfileStructureElementDefinitionBinding);
  FhirProfileStructureElementDefinitionBindings[index] := value;
end;

procedure TFhirProfileStructureElementDefinitionBindingList.SetItemN(index: Integer; value: TFhirProfileStructureElementDefinitionBinding);
begin
  assert(value is TFhirProfileStructureElementDefinitionBinding);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureElementDefinitionMapping }

constructor TFhirProfileStructureElementDefinitionMapping.Create;
begin
  inherited;
end;

destructor TFhirProfileStructureElementDefinitionMapping.Destroy;
begin
  FIdentity.free;
  FMap.free;
  inherited;
end;

procedure TFhirProfileStructureElementDefinitionMapping.Assign(oSource : TAdvObject);
begin
  inherited;
  identityObject := TFhirProfileStructureElementDefinitionMapping(oSource).identityObject.Clone;
  mapObject := TFhirProfileStructureElementDefinitionMapping(oSource).mapObject.Clone;
end;

procedure TFhirProfileStructureElementDefinitionMapping.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identity') Then
     list.add(FIdentity.Link);
  if (child_name = 'map') Then
     list.add(FMap.Link);
end;

procedure TFhirProfileStructureElementDefinitionMapping.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identity', 'id', FIdentity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'map', 'string', FMap.Link));{2}
end;

procedure TFhirProfileStructureElementDefinitionMapping.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'identity') then IdentityObject := propValue as TFhirId{5a}
  else if (propName = 'map') then MapObject := propValue as TFhirString{5a}
  else inherited;
end;

function TFhirProfileStructureElementDefinitionMapping.FhirType : string;
begin
  result := 'mapping';
end;

function TFhirProfileStructureElementDefinitionMapping.Link : TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping(inherited Link);
end;

function TFhirProfileStructureElementDefinitionMapping.Clone : TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping(inherited Clone);
end;

{ TFhirProfileStructureElementDefinitionMapping }

Procedure TFhirProfileStructureElementDefinitionMapping.SetIdentity(value : TFhirId);
begin
  FIdentity.free;
  FIdentity := value;
end;

Function TFhirProfileStructureElementDefinitionMapping.GetIdentityST : String;
begin
  if FIdentity = nil then
    result := ''
  else
    result := FIdentity.value;
end;

Procedure TFhirProfileStructureElementDefinitionMapping.SetIdentityST(value : String);
begin
  if value <> '' then
  begin
    if FIdentity = nil then
      FIdentity := TFhirId.create;
    FIdentity.value := value
  end
  else if FIdentity <> nil then
    FIdentity.value := '';
end;

Procedure TFhirProfileStructureElementDefinitionMapping.SetMap(value : TFhirString);
begin
  FMap.free;
  FMap := value;
end;

Function TFhirProfileStructureElementDefinitionMapping.GetMapST : String;
begin
  if FMap = nil then
    result := ''
  else
    result := FMap.value;
end;

Procedure TFhirProfileStructureElementDefinitionMapping.SetMapST(value : String);
begin
  if value <> '' then
  begin
    if FMap = nil then
      FMap := TFhirString.create;
    FMap.value := value
  end
  else if FMap <> nil then
    FMap.value := '';
end;


{ TFhirProfileStructureElementDefinitionMappingListEnumerator }

Constructor TFhirProfileStructureElementDefinitionMappingListEnumerator.Create(list : TFhirProfileStructureElementDefinitionMappingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProfileStructureElementDefinitionMappingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProfileStructureElementDefinitionMappingListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProfileStructureElementDefinitionMappingListEnumerator.GetCurrent : TFhirProfileStructureElementDefinitionMapping;
begin
  Result := FList[FIndex];
end;


{ TFhirProfileStructureElementDefinitionMappingList }
procedure TFhirProfileStructureElementDefinitionMappingList.AddItem(value: TFhirProfileStructureElementDefinitionMapping);
begin
  assert(value.ClassName = 'TFhirProfileStructureElementDefinitionMapping', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureElementDefinitionMapping');
  add(value);
end;


function TFhirProfileStructureElementDefinitionMappingList.Append: TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionMappingList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureElementDefinitionMappingList.GetEnumerator : TFhirProfileStructureElementDefinitionMappingListEnumerator;
begin
  result := TFhirProfileStructureElementDefinitionMappingListEnumerator.Create(self.link);
end;

function TFhirProfileStructureElementDefinitionMappingList.Clone: TFhirProfileStructureElementDefinitionMappingList;
begin
  result := TFhirProfileStructureElementDefinitionMappingList(inherited Clone);
end;

function TFhirProfileStructureElementDefinitionMappingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureElementDefinitionMappingList.GetItemN(index: Integer): TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionMappingList.IndexOf(value: TFhirProfileStructureElementDefinitionMapping): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureElementDefinitionMappingList.Insert(index: Integer): TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureElementDefinitionMappingList.InsertItem(index: Integer; value: TFhirProfileStructureElementDefinitionMapping);
begin
  assert(value is TFhirProfileStructureElementDefinitionMapping);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureElementDefinitionMappingList.Item(index: Integer): TFhirProfileStructureElementDefinitionMapping;
begin
  result := TFhirProfileStructureElementDefinitionMapping(ObjectByIndex[index]);
end;

function TFhirProfileStructureElementDefinitionMappingList.Link: TFhirProfileStructureElementDefinitionMappingList;
begin
  result := TFhirProfileStructureElementDefinitionMappingList(inherited Link);
end;

procedure TFhirProfileStructureElementDefinitionMappingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureElementDefinitionMappingList.SetItemByIndex(index: Integer; value: TFhirProfileStructureElementDefinitionMapping);
begin
  assert(value is TFhirProfileStructureElementDefinitionMapping);
  FhirProfileStructureElementDefinitionMappings[index] := value;
end;

procedure TFhirProfileStructureElementDefinitionMappingList.SetItemN(index: Integer; value: TFhirProfileStructureElementDefinitionMapping);
begin
  assert(value is TFhirProfileStructureElementDefinitionMapping);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileStructureSearchParam }

constructor TFhirProfileStructureSearchParam.Create;
begin
  inherited;
  FTargetList := TFhirCodeList.Create;
end;

destructor TFhirProfileStructureSearchParam.Destroy;
begin
  FName.free;
  FType_.free;
  FDocumentation.free;
  FXpath.free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirProfileStructureSearchParam.Assign(oSource : TAdvObject);
begin
  inherited;
  nameObject := TFhirProfileStructureSearchParam(oSource).nameObject.Clone;
  FType_ := TFhirProfileStructureSearchParam(oSource).FType_.Link;
  documentationObject := TFhirProfileStructureSearchParam(oSource).documentationObject.Clone;
  xpathObject := TFhirProfileStructureSearchParam(oSource).xpathObject.Clone;
  FTargetList.Assign(TFhirProfileStructureSearchParam(oSource).FTargetList);
end;

procedure TFhirProfileStructureSearchParam.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'documentation') Then
     list.add(FDocumentation.Link);
  if (child_name = 'xpath') Then
     list.add(FXpath.Link);
  if (child_name = 'target') Then
     list.addAll(FTargetList);
end;

procedure TFhirProfileStructureSearchParam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'xpath', 'string', FXpath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'code', FTargetList.Link)){3};
end;

procedure TFhirProfileStructureSearchParam.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'type') then Type_Object := propValue as TFHIREnum
  else if (propName = 'documentation') then DocumentationObject := propValue as TFhirString{5a}
  else if (propName = 'xpath') then XpathObject := propValue as TFhirString{5a}
  else if (propName = 'target') then TargetList.add(propValue as TFhirCode){2}
  else inherited;
end;

function TFhirProfileStructureSearchParam.FhirType : string;
begin
  result := 'searchParam';
end;

function TFhirProfileStructureSearchParam.Link : TFhirProfileStructureSearchParam;
begin
  result := TFhirProfileStructureSearchParam(inherited Link);
end;

function TFhirProfileStructureSearchParam.Clone : TFhirProfileStructureSearchParam;
begin
  result := TFhirProfileStructureSearchParam(inherited Clone);
end;

{ TFhirProfileStructureSearchParam }

Procedure TFhirProfileStructureSearchParam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileStructureSearchParam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirProfileStructureSearchParam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileStructureSearchParam.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirProfileStructureSearchParam.GetType_ST : TFhirSearchParamType;
begin
  if FType_ = nil then
    result := TFhirSearchParamType(0)
  else
    result := TFhirSearchParamType(StringArrayIndexOfSensitive(CODES_TFhirSearchParamType, FType_.value));
end;

Procedure TFhirProfileStructureSearchParam.SetType_ST(value : TFhirSearchParamType);
begin
  if ord(value) = 0 then
    Type_Object := nil
  else
    Type_Object := TFhirEnum.create(CODES_TFhirSearchParamType[value]);
end;

Procedure TFhirProfileStructureSearchParam.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirProfileStructureSearchParam.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirProfileStructureSearchParam.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirProfileStructureSearchParam.SetXpath(value : TFhirString);
begin
  FXpath.free;
  FXpath := value;
end;

Function TFhirProfileStructureSearchParam.GetXpathST : String;
begin
  if FXpath = nil then
    result := ''
  else
    result := FXpath.value;
end;

Procedure TFhirProfileStructureSearchParam.SetXpathST(value : String);
begin
  if value <> '' then
  begin
    if FXpath = nil then
      FXpath := TFhirString.create;
    FXpath.value := value
  end
  else if FXpath <> nil then
    FXpath.value := '';
end;


{ TFhirProfileStructureSearchParamListEnumerator }

Constructor TFhirProfileStructureSearchParamListEnumerator.Create(list : TFhirProfileStructureSearchParamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProfileStructureSearchParamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProfileStructureSearchParamListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProfileStructureSearchParamListEnumerator.GetCurrent : TFhirProfileStructureSearchParam;
begin
  Result := FList[FIndex];
end;


{ TFhirProfileStructureSearchParamList }
procedure TFhirProfileStructureSearchParamList.AddItem(value: TFhirProfileStructureSearchParam);
begin
  assert(value.ClassName = 'TFhirProfileStructureSearchParam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileStructureSearchParam');
  add(value);
end;


function TFhirProfileStructureSearchParamList.Append: TFhirProfileStructureSearchParam;
begin
  result := TFhirProfileStructureSearchParam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureSearchParamList.ClearItems;
begin
  Clear;
end;

function TFhirProfileStructureSearchParamList.GetEnumerator : TFhirProfileStructureSearchParamListEnumerator;
begin
  result := TFhirProfileStructureSearchParamListEnumerator.Create(self.link);
end;

function TFhirProfileStructureSearchParamList.Clone: TFhirProfileStructureSearchParamList;
begin
  result := TFhirProfileStructureSearchParamList(inherited Clone);
end;

function TFhirProfileStructureSearchParamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileStructureSearchParamList.GetItemN(index: Integer): TFhirProfileStructureSearchParam;
begin
  result := TFhirProfileStructureSearchParam(ObjectByIndex[index]);
end;

function TFhirProfileStructureSearchParamList.IndexOf(value: TFhirProfileStructureSearchParam): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileStructureSearchParamList.Insert(index: Integer): TFhirProfileStructureSearchParam;
begin
  result := TFhirProfileStructureSearchParam.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileStructureSearchParamList.InsertItem(index: Integer; value: TFhirProfileStructureSearchParam);
begin
  assert(value is TFhirProfileStructureSearchParam);
  Inherited Insert(index, value);
end;

function TFhirProfileStructureSearchParamList.Item(index: Integer): TFhirProfileStructureSearchParam;
begin
  result := TFhirProfileStructureSearchParam(ObjectByIndex[index]);
end;

function TFhirProfileStructureSearchParamList.Link: TFhirProfileStructureSearchParamList;
begin
  result := TFhirProfileStructureSearchParamList(inherited Link);
end;

procedure TFhirProfileStructureSearchParamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileStructureSearchParamList.SetItemByIndex(index: Integer; value: TFhirProfileStructureSearchParam);
begin
  assert(value is TFhirProfileStructureSearchParam);
  FhirProfileStructureSearchParams[index] := value;
end;

procedure TFhirProfileStructureSearchParamList.SetItemN(index: Integer; value: TFhirProfileStructureSearchParam);
begin
  assert(value is TFhirProfileStructureSearchParam);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileExtensionDefn }

constructor TFhirProfileExtensionDefn.Create;
begin
  inherited;
  FContextList := TFhirStringList.Create;
end;

destructor TFhirProfileExtensionDefn.Destroy;
begin
  FCode.free;
  FDisplay.free;
  FContextType.free;
  FContextList.Free;
  FDefinition.free;
  inherited;
end;

procedure TFhirProfileExtensionDefn.Assign(oSource : TAdvObject);
begin
  inherited;
  codeObject := TFhirProfileExtensionDefn(oSource).codeObject.Clone;
  displayObject := TFhirProfileExtensionDefn(oSource).displayObject.Clone;
  FContextType := TFhirProfileExtensionDefn(oSource).FContextType.Link;
  FContextList.Assign(TFhirProfileExtensionDefn(oSource).FContextList);
  definition := TFhirProfileExtensionDefn(oSource).definition.Clone;
end;

procedure TFhirProfileExtensionDefn.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'display') Then
     list.add(FDisplay.Link);
  if (child_name = 'contextType') Then
     list.add(FContextType.Link);
  if (child_name = 'context') Then
     list.addAll(FContextList);
  if (child_name = 'definition') Then
     list.add(FDefinition.Link);
end;

procedure TFhirProfileExtensionDefn.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contextType', 'code', FContextType.Link));{1}
  oList.add(TFHIRProperty.create(self, 'context', 'string', FContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition', '@Profile.structure.element.definition', FDefinition.Link));{2}
end;

procedure TFhirProfileExtensionDefn.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then
    if propValue is TFHIRCode then
      CodeObject := propValue as TFhirCode{5}
    else if propValue is TFHIREnum then
      CodeObject := TFHIRCode.create(TFHIREnum(propValue).value)
    else
      raise Exception.Create('Type mismatch: cannot convert from "'+propValue.className+'" to "TFHIRCode"'){5a}
  else if (propName = 'display') then DisplayObject := propValue as TFhirString{5a}
  else if (propName = 'contextType') then ContextTypeObject := propValue as TFHIREnum
  else if (propName = 'context') then ContextList.add(propValue as TFhirString){2}
  else if (propName = 'definition') then Definition := propValue as TFhirProfileStructureElementDefinition{4b}
  else inherited;
end;

function TFhirProfileExtensionDefn.FhirType : string;
begin
  result := 'extensionDefn';
end;

function TFhirProfileExtensionDefn.Link : TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn(inherited Link);
end;

function TFhirProfileExtensionDefn.Clone : TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn(inherited Clone);
end;

{ TFhirProfileExtensionDefn }

Procedure TFhirProfileExtensionDefn.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirProfileExtensionDefn.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirProfileExtensionDefn.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirProfileExtensionDefn.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirProfileExtensionDefn.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirProfileExtensionDefn.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirProfileExtensionDefn.SetContextType(value : TFhirEnum);
begin
  FContextType.free;
  FContextType := value;
end;

Function TFhirProfileExtensionDefn.GetContextTypeST : TFhirExtensionContext;
begin
  if FContextType = nil then
    result := TFhirExtensionContext(0)
  else
    result := TFhirExtensionContext(StringArrayIndexOfSensitive(CODES_TFhirExtensionContext, FContextType.value));
end;

Procedure TFhirProfileExtensionDefn.SetContextTypeST(value : TFhirExtensionContext);
begin
  if ord(value) = 0 then
    ContextTypeObject := nil
  else
    ContextTypeObject := TFhirEnum.create(CODES_TFhirExtensionContext[value]);
end;

Procedure TFhirProfileExtensionDefn.SetDefinition(value : TFhirProfileStructureElementDefinition);
begin
  FDefinition.free;
  FDefinition := value;
end;


{ TFhirProfileExtensionDefnListEnumerator }

Constructor TFhirProfileExtensionDefnListEnumerator.Create(list : TFhirProfileExtensionDefnList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProfileExtensionDefnListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProfileExtensionDefnListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProfileExtensionDefnListEnumerator.GetCurrent : TFhirProfileExtensionDefn;
begin
  Result := FList[FIndex];
end;


{ TFhirProfileExtensionDefnList }
procedure TFhirProfileExtensionDefnList.AddItem(value: TFhirProfileExtensionDefn);
begin
  assert(value.ClassName = 'TFhirProfileExtensionDefn', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileExtensionDefn');
  add(value);
end;


function TFhirProfileExtensionDefnList.Append: TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileExtensionDefnList.ClearItems;
begin
  Clear;
end;

function TFhirProfileExtensionDefnList.GetEnumerator : TFhirProfileExtensionDefnListEnumerator;
begin
  result := TFhirProfileExtensionDefnListEnumerator.Create(self.link);
end;

function TFhirProfileExtensionDefnList.Clone: TFhirProfileExtensionDefnList;
begin
  result := TFhirProfileExtensionDefnList(inherited Clone);
end;

function TFhirProfileExtensionDefnList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileExtensionDefnList.GetItemN(index: Integer): TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn(ObjectByIndex[index]);
end;

function TFhirProfileExtensionDefnList.IndexOf(value: TFhirProfileExtensionDefn): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileExtensionDefnList.Insert(index: Integer): TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileExtensionDefnList.InsertItem(index: Integer; value: TFhirProfileExtensionDefn);
begin
  assert(value is TFhirProfileExtensionDefn);
  Inherited Insert(index, value);
end;

function TFhirProfileExtensionDefnList.Item(index: Integer): TFhirProfileExtensionDefn;
begin
  result := TFhirProfileExtensionDefn(ObjectByIndex[index]);
end;

function TFhirProfileExtensionDefnList.Link: TFhirProfileExtensionDefnList;
begin
  result := TFhirProfileExtensionDefnList(inherited Link);
end;

procedure TFhirProfileExtensionDefnList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileExtensionDefnList.SetItemByIndex(index: Integer; value: TFhirProfileExtensionDefn);
begin
  assert(value is TFhirProfileExtensionDefn);
  FhirProfileExtensionDefns[index] := value;
end;

procedure TFhirProfileExtensionDefnList.SetItemN(index: Integer; value: TFhirProfileExtensionDefn);
begin
  assert(value is TFhirProfileExtensionDefn);
  ObjectByIndex[index] := value;
end;

{ TFhirProfileQuery }

constructor TFhirProfileQuery.Create;
begin
  inherited;
  FParameterList := TFhirProfileStructureSearchParamList.Create;
end;

destructor TFhirProfileQuery.Destroy;
begin
  FName.free;
  FDocumentation.free;
  FParameterList.Free;
  inherited;
end;

procedure TFhirProfileQuery.Assign(oSource : TAdvObject);
begin
  inherited;
  nameObject := TFhirProfileQuery(oSource).nameObject.Clone;
  documentationObject := TFhirProfileQuery(oSource).documentationObject.Clone;
  FParameterList.Assign(TFhirProfileQuery(oSource).FParameterList);
end;

procedure TFhirProfileQuery.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'documentation') Then
     list.add(FDocumentation.Link);
  if (child_name = 'parameter') Then
     list.addAll(FParameterList);
end;

procedure TFhirProfileQuery.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', '@Profile.structure.searchParam', FParameterList.Link)){3};
end;

procedure TFhirProfileQuery.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'documentation') then DocumentationObject := propValue as TFhirString{5a}
  else if (propName = 'parameter') then ParameterList.add(propValue as TFhirProfileStructureSearchParam){2}
  else inherited;
end;

function TFhirProfileQuery.FhirType : string;
begin
  result := 'query';
end;

function TFhirProfileQuery.Link : TFhirProfileQuery;
begin
  result := TFhirProfileQuery(inherited Link);
end;

function TFhirProfileQuery.Clone : TFhirProfileQuery;
begin
  result := TFhirProfileQuery(inherited Clone);
end;

{ TFhirProfileQuery }

Procedure TFhirProfileQuery.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirProfileQuery.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirProfileQuery.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirProfileQuery.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirProfileQuery.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirProfileQuery.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;


{ TFhirProfileQueryListEnumerator }

Constructor TFhirProfileQueryListEnumerator.Create(list : TFhirProfileQueryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProfileQueryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProfileQueryListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProfileQueryListEnumerator.GetCurrent : TFhirProfileQuery;
begin
  Result := FList[FIndex];
end;


{ TFhirProfileQueryList }
procedure TFhirProfileQueryList.AddItem(value: TFhirProfileQuery);
begin
  assert(value.ClassName = 'TFhirProfileQuery', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProfileQuery');
  add(value);
end;


function TFhirProfileQueryList.Append: TFhirProfileQuery;
begin
  result := TFhirProfileQuery.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProfileQueryList.ClearItems;
begin
  Clear;
end;

function TFhirProfileQueryList.GetEnumerator : TFhirProfileQueryListEnumerator;
begin
  result := TFhirProfileQueryListEnumerator.Create(self.link);
end;

function TFhirProfileQueryList.Clone: TFhirProfileQueryList;
begin
  result := TFhirProfileQueryList(inherited Clone);
end;

function TFhirProfileQueryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProfileQueryList.GetItemN(index: Integer): TFhirProfileQuery;
begin
  result := TFhirProfileQuery(ObjectByIndex[index]);
end;

function TFhirProfileQueryList.IndexOf(value: TFhirProfileQuery): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProfileQueryList.Insert(index: Integer): TFhirProfileQuery;
begin
  result := TFhirProfileQuery.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProfileQueryList.InsertItem(index: Integer; value: TFhirProfileQuery);
begin
  assert(value is TFhirProfileQuery);
  Inherited Insert(index, value);
end;

function TFhirProfileQueryList.Item(index: Integer): TFhirProfileQuery;
begin
  result := TFhirProfileQuery(ObjectByIndex[index]);
end;

function TFhirProfileQueryList.Link: TFhirProfileQueryList;
begin
  result := TFhirProfileQueryList(inherited Link);
end;

procedure TFhirProfileQueryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProfileQueryList.SetItemByIndex(index: Integer; value: TFhirProfileQuery);
begin
  assert(value is TFhirProfileQuery);
  FhirProfileQueries[index] := value;
end;

procedure TFhirProfileQueryList.SetItemN(index: Integer; value: TFhirProfileQuery);
begin
  assert(value is TFhirProfileQuery);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenanceAgent }

constructor TFhirProvenanceAgent.Create;
begin
  inherited;
end;

destructor TFhirProvenanceAgent.Destroy;
begin
  FRole.free;
  FType_.free;
  FReference.free;
  FDisplay.free;
  inherited;
end;

procedure TFhirProvenanceAgent.Assign(oSource : TAdvObject);
begin
  inherited;
  role := TFhirProvenanceAgent(oSource).role.Clone;
  type_ := TFhirProvenanceAgent(oSource).type_.Clone;
  referenceObject := TFhirProvenanceAgent(oSource).referenceObject.Clone;
  displayObject := TFhirProvenanceAgent(oSource).displayObject.Clone;
end;

procedure TFhirProvenanceAgent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(FRole.Link);
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'reference') Then
     list.add(FReference.Link);
  if (child_name = 'display') Then
     list.add(FDisplay.Link);
end;

procedure TFhirProvenanceAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'Coding', FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', FDisplay.Link));{2}
end;

procedure TFhirProvenanceAgent.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'role') then Role := propValue as TFhirCoding{4b}
  else if (propName = 'type') then Type_ := propValue as TFhirCoding{4b}
  else if (propName = 'reference') then ReferenceObject := propValue as TFhirUri{5a}
  else if (propName = 'display') then DisplayObject := propValue as TFhirString{5a}
  else inherited;
end;

function TFhirProvenanceAgent.FhirType : string;
begin
  result := 'agent';
end;

function TFhirProvenanceAgent.Link : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Link);
end;

function TFhirProvenanceAgent.Clone : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Clone);
end;

{ TFhirProvenanceAgent }

Procedure TFhirProvenanceAgent.SetRole(value : TFhirCoding);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirProvenanceAgent.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirProvenanceAgent.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value;
end;

Function TFhirProvenanceAgent.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := FReference.value;
end;

Procedure TFhirProvenanceAgent.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

Procedure TFhirProvenanceAgent.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirProvenanceAgent.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirProvenanceAgent.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;


{ TFhirProvenanceAgentListEnumerator }

Constructor TFhirProvenanceAgentListEnumerator.Create(list : TFhirProvenanceAgentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProvenanceAgentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceAgentListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProvenanceAgentListEnumerator.GetCurrent : TFhirProvenanceAgent;
begin
  Result := FList[FIndex];
end;


{ TFhirProvenanceAgentList }
procedure TFhirProvenanceAgentList.AddItem(value: TFhirProvenanceAgent);
begin
  assert(value.ClassName = 'TFhirProvenanceAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceAgent');
  add(value);
end;


function TFhirProvenanceAgentList.Append: TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProvenanceAgentList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceAgentList.GetEnumerator : TFhirProvenanceAgentListEnumerator;
begin
  result := TFhirProvenanceAgentListEnumerator.Create(self.link);
end;

function TFhirProvenanceAgentList.Clone: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Clone);
end;

function TFhirProvenanceAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceAgentList.GetItemN(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.IndexOf(value: TFhirProvenanceAgent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProvenanceAgentList.Insert(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProvenanceAgentList.InsertItem(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  Inherited Insert(index, value);
end;

function TFhirProvenanceAgentList.Item(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.Link: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Link);
end;

procedure TFhirProvenanceAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceAgentList.SetItemByIndex(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  FhirProvenanceAgents[index] := value;
end;

procedure TFhirProvenanceAgentList.SetItemN(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenanceEntity }

constructor TFhirProvenanceEntity.Create;
begin
  inherited;
end;

destructor TFhirProvenanceEntity.Destroy;
begin
  FRole.free;
  FType_.free;
  FReference.free;
  FDisplay.free;
  FAgent.free;
  inherited;
end;

procedure TFhirProvenanceEntity.Assign(oSource : TAdvObject);
begin
  inherited;
  FRole := TFhirProvenanceEntity(oSource).FRole.Link;
  type_ := TFhirProvenanceEntity(oSource).type_.Clone;
  referenceObject := TFhirProvenanceEntity(oSource).referenceObject.Clone;
  displayObject := TFhirProvenanceEntity(oSource).displayObject.Clone;
  agent := TFhirProvenanceEntity(oSource).agent.Clone;
end;

procedure TFhirProvenanceEntity.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(FRole.Link);
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'reference') Then
     list.add(FReference.Link);
  if (child_name = 'display') Then
     list.add(FDisplay.Link);
  if (child_name = 'agent') Then
     list.add(FAgent.Link);
end;

procedure TFhirProvenanceEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'code', FRole.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'agent', '@Provenance.agent', FAgent.Link));{2}
end;

procedure TFhirProvenanceEntity.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'role') then RoleObject := propValue as TFHIREnum
  else if (propName = 'type') then Type_ := propValue as TFhirCoding{4b}
  else if (propName = 'reference') then ReferenceObject := propValue as TFhirUri{5a}
  else if (propName = 'display') then DisplayObject := propValue as TFhirString{5a}
  else if (propName = 'agent') then Agent := propValue as TFhirProvenanceAgent{4b}
  else inherited;
end;

function TFhirProvenanceEntity.FhirType : string;
begin
  result := 'entity';
end;

function TFhirProvenanceEntity.Link : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Link);
end;

function TFhirProvenanceEntity.Clone : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Clone);
end;

{ TFhirProvenanceEntity }

Procedure TFhirProvenanceEntity.SetRole(value : TFhirEnum);
begin
  FRole.free;
  FRole := value;
end;

Function TFhirProvenanceEntity.GetRoleST : TFhirProvenanceEntityRole;
begin
  if FRole = nil then
    result := TFhirProvenanceEntityRole(0)
  else
    result := TFhirProvenanceEntityRole(StringArrayIndexOfSensitive(CODES_TFhirProvenanceEntityRole, FRole.value));
end;

Procedure TFhirProvenanceEntity.SetRoleST(value : TFhirProvenanceEntityRole);
begin
  if ord(value) = 0 then
    RoleObject := nil
  else
    RoleObject := TFhirEnum.create(CODES_TFhirProvenanceEntityRole[value]);
end;

Procedure TFhirProvenanceEntity.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirProvenanceEntity.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value;
end;

Function TFhirProvenanceEntity.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := FReference.value;
end;

Procedure TFhirProvenanceEntity.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

Procedure TFhirProvenanceEntity.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirProvenanceEntity.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirProvenanceEntity.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirProvenanceEntity.SetAgent(value : TFhirProvenanceAgent);
begin
  FAgent.free;
  FAgent := value;
end;


{ TFhirProvenanceEntityListEnumerator }

Constructor TFhirProvenanceEntityListEnumerator.Create(list : TFhirProvenanceEntityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirProvenanceEntityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceEntityListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirProvenanceEntityListEnumerator.GetCurrent : TFhirProvenanceEntity;
begin
  Result := FList[FIndex];
end;


{ TFhirProvenanceEntityList }
procedure TFhirProvenanceEntityList.AddItem(value: TFhirProvenanceEntity);
begin
  assert(value.ClassName = 'TFhirProvenanceEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceEntity');
  add(value);
end;


function TFhirProvenanceEntityList.Append: TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirProvenanceEntityList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceEntityList.GetEnumerator : TFhirProvenanceEntityListEnumerator;
begin
  result := TFhirProvenanceEntityListEnumerator.Create(self.link);
end;

function TFhirProvenanceEntityList.Clone: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Clone);
end;

function TFhirProvenanceEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceEntityList.GetItemN(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.IndexOf(value: TFhirProvenanceEntity): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirProvenanceEntityList.Insert(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirProvenanceEntityList.InsertItem(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  Inherited Insert(index, value);
end;

function TFhirProvenanceEntityList.Item(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.Link: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Link);
end;

procedure TFhirProvenanceEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceEntityList.SetItemByIndex(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  FhirProvenanceEntities[index] := value;
end;

procedure TFhirProvenanceEntityList.SetItemN(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirQueryResponse }

constructor TFhirQueryResponse.Create;
begin
  inherited;
  FParameterList := TFhirExtensionList.Create;
  FFirstList := TFhirExtensionList.Create;
  FPreviousList := TFhirExtensionList.Create;
  FNextList := TFhirExtensionList.Create;
  FLastList := TFhirExtensionList.Create;
  FReferenceList := TFhirResourceReferenceList{Resource}.Create;
end;

destructor TFhirQueryResponse.Destroy;
begin
  FIdentifier.free;
  FOutcome.free;
  FTotal.free;
  FParameterList.Free;
  FFirstList.Free;
  FPreviousList.Free;
  FNextList.Free;
  FLastList.Free;
  FReferenceList.Free;
  inherited;
end;

procedure TFhirQueryResponse.Assign(oSource : TAdvObject);
begin
  inherited;
  identifierObject := TFhirQueryResponse(oSource).identifierObject.Clone;
  FOutcome := TFhirQueryResponse(oSource).FOutcome.Link;
  totalObject := TFhirQueryResponse(oSource).totalObject.Clone;
  FParameterList.Assign(TFhirQueryResponse(oSource).FParameterList);
  FFirstList.Assign(TFhirQueryResponse(oSource).FFirstList);
  FPreviousList.Assign(TFhirQueryResponse(oSource).FPreviousList);
  FNextList.Assign(TFhirQueryResponse(oSource).FNextList);
  FLastList.Assign(TFhirQueryResponse(oSource).FLastList);
  FReferenceList.Assign(TFhirQueryResponse(oSource).FReferenceList);
end;

procedure TFhirQueryResponse.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(FIdentifier.Link);
  if (child_name = 'outcome') Then
     list.add(FOutcome.Link);
  if (child_name = 'total') Then
     list.add(FTotal.Link);
  if (child_name = 'parameter') Then
     list.addAll(FParameterList);
  if (child_name = 'first') Then
     list.addAll(FFirstList);
  if (child_name = 'previous') Then
     list.addAll(FPreviousList);
  if (child_name = 'next') Then
     list.addAll(FNextList);
  if (child_name = 'last') Then
     list.addAll(FLastList);
  if (child_name = 'reference') Then
     list.addAll(FReferenceList);
end;

procedure TFhirQueryResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'uri', FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'total', 'integer', FTotal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', 'Extension', FParameterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'first', 'Extension', FFirstList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'previous', 'Extension', FPreviousList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'next', 'Extension', FNextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'last', 'Extension', FLastList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reference', 'Resource(Any)', FReferenceList.Link)){3};
end;

procedure TFhirQueryResponse.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierObject := propValue as TFhirUri{5a}
  else if (propName = 'outcome') then OutcomeObject := propValue as TFHIREnum
  else if (propName = 'total') then TotalObject := propValue as TFhirInteger{5a}
  else if (propName = 'parameter') then ParameterList.add(propValue as TFhirExtension){2}
  else if (propName = 'first') then FirstList.add(propValue as TFhirExtension){2}
  else if (propName = 'previous') then PreviousList.add(propValue as TFhirExtension){2}
  else if (propName = 'next') then NextList.add(propValue as TFhirExtension){2}
  else if (propName = 'last') then LastList.add(propValue as TFhirExtension){2}
  else if (propName = 'reference') then ReferenceList.add(propValue as TFhirResourceReference{Resource}){2}
  else inherited;
end;

function TFhirQueryResponse.FhirType : string;
begin
  result := 'response';
end;

function TFhirQueryResponse.Link : TFhirQueryResponse;
begin
  result := TFhirQueryResponse(inherited Link);
end;

function TFhirQueryResponse.Clone : TFhirQueryResponse;
begin
  result := TFhirQueryResponse(inherited Clone);
end;

{ TFhirQueryResponse }

Procedure TFhirQueryResponse.SetIdentifier(value : TFhirUri);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirQueryResponse.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := FIdentifier.value;
end;

Procedure TFhirQueryResponse.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirUri.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

Procedure TFhirQueryResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirQueryResponse.GetOutcomeST : TFhirQueryOutcome;
begin
  if FOutcome = nil then
    result := TFhirQueryOutcome(0)
  else
    result := TFhirQueryOutcome(StringArrayIndexOfSensitive(CODES_TFhirQueryOutcome, FOutcome.value));
end;

Procedure TFhirQueryResponse.SetOutcomeST(value : TFhirQueryOutcome);
begin
  if ord(value) = 0 then
    OutcomeObject := nil
  else
    OutcomeObject := TFhirEnum.create(CODES_TFhirQueryOutcome[value]);
end;

Procedure TFhirQueryResponse.SetTotal(value : TFhirInteger);
begin
  FTotal.free;
  FTotal := value;
end;

Function TFhirQueryResponse.GetTotalST : String;
begin
  if FTotal = nil then
    result := ''
  else
    result := FTotal.value;
end;

Procedure TFhirQueryResponse.SetTotalST(value : String);
begin
  if value <> '' then
  begin
    if FTotal = nil then
      FTotal := TFhirInteger.create;
    FTotal.value := value
  end
  else if FTotal <> nil then
    FTotal.value := '';
end;


{ TFhirQueryResponseListEnumerator }

Constructor TFhirQueryResponseListEnumerator.Create(list : TFhirQueryResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirQueryResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQueryResponseListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirQueryResponseListEnumerator.GetCurrent : TFhirQueryResponse;
begin
  Result := FList[FIndex];
end;


{ TFhirQueryResponseList }
procedure TFhirQueryResponseList.AddItem(value: TFhirQueryResponse);
begin
  assert(value.ClassName = 'TFhirQueryResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQueryResponse');
  add(value);
end;


function TFhirQueryResponseList.Append: TFhirQueryResponse;
begin
  result := TFhirQueryResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirQueryResponseList.ClearItems;
begin
  Clear;
end;

function TFhirQueryResponseList.GetEnumerator : TFhirQueryResponseListEnumerator;
begin
  result := TFhirQueryResponseListEnumerator.Create(self.link);
end;

function TFhirQueryResponseList.Clone: TFhirQueryResponseList;
begin
  result := TFhirQueryResponseList(inherited Clone);
end;

function TFhirQueryResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQueryResponseList.GetItemN(index: Integer): TFhirQueryResponse;
begin
  result := TFhirQueryResponse(ObjectByIndex[index]);
end;

function TFhirQueryResponseList.IndexOf(value: TFhirQueryResponse): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirQueryResponseList.Insert(index: Integer): TFhirQueryResponse;
begin
  result := TFhirQueryResponse.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirQueryResponseList.InsertItem(index: Integer; value: TFhirQueryResponse);
begin
  assert(value is TFhirQueryResponse);
  Inherited Insert(index, value);
end;

function TFhirQueryResponseList.Item(index: Integer): TFhirQueryResponse;
begin
  result := TFhirQueryResponse(ObjectByIndex[index]);
end;

function TFhirQueryResponseList.Link: TFhirQueryResponseList;
begin
  result := TFhirQueryResponseList(inherited Link);
end;

procedure TFhirQueryResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQueryResponseList.SetItemByIndex(index: Integer; value: TFhirQueryResponse);
begin
  assert(value is TFhirQueryResponse);
  FhirQueryResponses[index] := value;
end;

procedure TFhirQueryResponseList.SetItemN(index: Integer; value: TFhirQueryResponse);
begin
  assert(value is TFhirQueryResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireGroup }

constructor TFhirQuestionnaireGroup.Create;
begin
  inherited;
  FGroupList := TFhirQuestionnaireGroupList.Create;
  FQuestionList := TFhirQuestionnaireGroupQuestionList.Create;
end;

destructor TFhirQuestionnaireGroup.Destroy;
begin
  FName.free;
  FHeader.free;
  FText.free;
  FSubject.free;
  FGroupList.Free;
  FQuestionList.Free;
  inherited;
end;

procedure TFhirQuestionnaireGroup.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirQuestionnaireGroup(oSource).name.Clone;
  headerObject := TFhirQuestionnaireGroup(oSource).headerObject.Clone;
  textObject := TFhirQuestionnaireGroup(oSource).textObject.Clone;
  subject := TFhirQuestionnaireGroup(oSource).subject.Clone;
  FGroupList.Assign(TFhirQuestionnaireGroup(oSource).FGroupList);
  FQuestionList.Assign(TFhirQuestionnaireGroup(oSource).FQuestionList);
end;

procedure TFhirQuestionnaireGroup.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'header') Then
     list.add(FHeader.Link);
  if (child_name = 'text') Then
     list.add(FText.Link);
  if (child_name = 'subject') Then
     list.add(FSubject.Link);
  if (child_name = 'group') Then
     list.addAll(FGroupList);
  if (child_name = 'question') Then
     list.addAll(FQuestionList);
end;

procedure TFhirQuestionnaireGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'CodeableConcept', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'header', 'string', FHeader.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Resource(Any)', FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'group', '@Questionnaire.group', FGroupList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'question', '', FQuestionList.Link)){3};
end;

procedure TFhirQuestionnaireGroup.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'name') then Name := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'header') then HeaderObject := propValue as TFhirString{5a}
  else if (propName = 'text') then TextObject := propValue as TFhirString{5a}
  else if (propName = 'subject') then Subject := propValue as TFhirResourceReference{Resource}{4b}
  else if (propName = 'group') then GroupList.add(propValue as TFhirQuestionnaireGroup){2}
  else if (propName = 'question') then QuestionList.add(propValue as TFhirQuestionnaireGroupQuestion){2}
  else inherited;
end;

function TFhirQuestionnaireGroup.FhirType : string;
begin
  result := 'group';
end;

function TFhirQuestionnaireGroup.Link : TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(inherited Link);
end;

function TFhirQuestionnaireGroup.Clone : TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(inherited Clone);
end;

{ TFhirQuestionnaireGroup }

Procedure TFhirQuestionnaireGroup.SetName(value : TFhirCodeableConcept);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirQuestionnaireGroup.SetHeader(value : TFhirString);
begin
  FHeader.free;
  FHeader := value;
end;

Function TFhirQuestionnaireGroup.GetHeaderST : String;
begin
  if FHeader = nil then
    result := ''
  else
    result := FHeader.value;
end;

Procedure TFhirQuestionnaireGroup.SetHeaderST(value : String);
begin
  if value <> '' then
  begin
    if FHeader = nil then
      FHeader := TFhirString.create;
    FHeader.value := value
  end
  else if FHeader <> nil then
    FHeader.value := '';
end;

Procedure TFhirQuestionnaireGroup.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirQuestionnaireGroup.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirQuestionnaireGroup.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirQuestionnaireGroup.SetSubject(value : TFhirResourceReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;


{ TFhirQuestionnaireGroupListEnumerator }

Constructor TFhirQuestionnaireGroupListEnumerator.Create(list : TFhirQuestionnaireGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirQuestionnaireGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireGroupListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirQuestionnaireGroupListEnumerator.GetCurrent : TFhirQuestionnaireGroup;
begin
  Result := FList[FIndex];
end;


{ TFhirQuestionnaireGroupList }
procedure TFhirQuestionnaireGroupList.AddItem(value: TFhirQuestionnaireGroup);
begin
  assert(value.ClassName = 'TFhirQuestionnaireGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireGroup');
  add(value);
end;


function TFhirQuestionnaireGroupList.Append: TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirQuestionnaireGroupList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireGroupList.GetEnumerator : TFhirQuestionnaireGroupListEnumerator;
begin
  result := TFhirQuestionnaireGroupListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireGroupList.Clone: TFhirQuestionnaireGroupList;
begin
  result := TFhirQuestionnaireGroupList(inherited Clone);
end;

function TFhirQuestionnaireGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireGroupList.GetItemN(index: Integer): TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(ObjectByIndex[index]);
end;

function TFhirQuestionnaireGroupList.IndexOf(value: TFhirQuestionnaireGroup): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirQuestionnaireGroupList.Insert(index: Integer): TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirQuestionnaireGroupList.InsertItem(index: Integer; value: TFhirQuestionnaireGroup);
begin
  assert(value is TFhirQuestionnaireGroup);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireGroupList.Item(index: Integer): TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(ObjectByIndex[index]);
end;

function TFhirQuestionnaireGroupList.Link: TFhirQuestionnaireGroupList;
begin
  result := TFhirQuestionnaireGroupList(inherited Link);
end;

procedure TFhirQuestionnaireGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireGroupList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireGroup);
begin
  assert(value is TFhirQuestionnaireGroup);
  FhirQuestionnaireGroups[index] := value;
end;

procedure TFhirQuestionnaireGroupList.SetItemN(index: Integer; value: TFhirQuestionnaireGroup);
begin
  assert(value is TFhirQuestionnaireGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireGroupQuestion }

constructor TFhirQuestionnaireGroupQuestion.Create;
begin
  inherited;
  FChoiceList := TFhirCodingList.Create;
  FGroupList := TFhirQuestionnaireGroupList.Create;
end;

destructor TFhirQuestionnaireGroupQuestion.Destroy;
begin
  FName.free;
  FText.free;
  FAnswer.free;
  FChoiceList.Free;
  FOptions.free;
  FData.free;
  FRemarks.free;
  FGroupList.Free;
  inherited;
end;

procedure TFhirQuestionnaireGroupQuestion.Assign(oSource : TAdvObject);
begin
  inherited;
  name := TFhirQuestionnaireGroupQuestion(oSource).name.Clone;
  textObject := TFhirQuestionnaireGroupQuestion(oSource).textObject.Clone;
  answer := TFhirQuestionnaireGroupQuestion(oSource).answer.Clone;
  FChoiceList.Assign(TFhirQuestionnaireGroupQuestion(oSource).FChoiceList);
  options := TFhirQuestionnaireGroupQuestion(oSource).options.Clone;
  data := TFhirQuestionnaireGroupQuestion(oSource).data.Clone;
  remarksObject := TFhirQuestionnaireGroupQuestion(oSource).remarksObject.Clone;
  FGroupList.Assign(TFhirQuestionnaireGroupQuestion(oSource).FGroupList);
end;

procedure TFhirQuestionnaireGroupQuestion.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'text') Then
     list.add(FText.Link);
  if (child_name = 'answer[x]') Then
     list.add(FAnswer.Link);
  if (child_name = 'choice') Then
     list.addAll(FChoiceList);
  if (child_name = 'options') Then
     list.add(FOptions.Link);
  if (child_name = 'data[x]') Then
     list.add(FData.Link);
  if (child_name = 'remarks') Then
     list.add(FRemarks.Link);
  if (child_name = 'group') Then
     list.addAll(FGroupList);
end;

procedure TFhirQuestionnaireGroupQuestion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'CodeableConcept', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'answer[x]', 'decimal|integer|boolean|date|string|dateTime|instant', FAnswer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'choice', 'Coding', FChoiceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'options', 'Resource(ValueSet)', FOptions.Link));{2}
  oList.add(TFHIRProperty.create(self, 'data[x]', '*', FData.Link));{2}
  oList.add(TFHIRProperty.create(self, 'remarks', 'string', FRemarks.Link));{2}
  oList.add(TFHIRProperty.create(self, 'group', '@Questionnaire.group', FGroupList.Link)){3};
end;

procedure TFhirQuestionnaireGroupQuestion.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'name') then Name := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'text') then TextObject := propValue as TFhirString{5a}
  else if (propName.startsWith('answer')) then Answer := propValue as TFhirType{4}
  else if (propName = 'choice') then ChoiceList.add(propValue as TFhirCoding){2}
  else if (propName = 'options') then Options := propValue as TFhirResourceReference{TFhirValueSet}{4b}
  else if (propName.startsWith('data')) then Data := propValue as TFhirType{4}
  else if (propName = 'remarks') then RemarksObject := propValue as TFhirString{5a}
  else if (propName = 'group') then GroupList.add(propValue as TFhirQuestionnaireGroup){2}
  else inherited;
end;

function TFhirQuestionnaireGroupQuestion.FhirType : string;
begin
  result := 'question';
end;

function TFhirQuestionnaireGroupQuestion.Link : TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion(inherited Link);
end;

function TFhirQuestionnaireGroupQuestion.Clone : TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion(inherited Clone);
end;

{ TFhirQuestionnaireGroupQuestion }

Procedure TFhirQuestionnaireGroupQuestion.SetName(value : TFhirCodeableConcept);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirQuestionnaireGroupQuestion.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirQuestionnaireGroupQuestion.SetAnswer(value : TFhirType);
begin
  FAnswer.free;
  FAnswer := value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetOptions(value : TFhirResourceReference{TFhirValueSet});
begin
  FOptions.free;
  FOptions := value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetData(value : TFhirType);
begin
  FData.free;
  FData := value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetRemarks(value : TFhirString);
begin
  FRemarks.free;
  FRemarks := value;
end;

Function TFhirQuestionnaireGroupQuestion.GetRemarksST : String;
begin
  if FRemarks = nil then
    result := ''
  else
    result := FRemarks.value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetRemarksST(value : String);
begin
  if value <> '' then
  begin
    if FRemarks = nil then
      FRemarks := TFhirString.create;
    FRemarks.value := value
  end
  else if FRemarks <> nil then
    FRemarks.value := '';
end;


{ TFhirQuestionnaireGroupQuestionListEnumerator }

Constructor TFhirQuestionnaireGroupQuestionListEnumerator.Create(list : TFhirQuestionnaireGroupQuestionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirQuestionnaireGroupQuestionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireGroupQuestionListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirQuestionnaireGroupQuestionListEnumerator.GetCurrent : TFhirQuestionnaireGroupQuestion;
begin
  Result := FList[FIndex];
end;


{ TFhirQuestionnaireGroupQuestionList }
procedure TFhirQuestionnaireGroupQuestionList.AddItem(value: TFhirQuestionnaireGroupQuestion);
begin
  assert(value.ClassName = 'TFhirQuestionnaireGroupQuestion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireGroupQuestion');
  add(value);
end;


function TFhirQuestionnaireGroupQuestionList.Append: TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirQuestionnaireGroupQuestionList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireGroupQuestionList.GetEnumerator : TFhirQuestionnaireGroupQuestionListEnumerator;
begin
  result := TFhirQuestionnaireGroupQuestionListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireGroupQuestionList.Clone: TFhirQuestionnaireGroupQuestionList;
begin
  result := TFhirQuestionnaireGroupQuestionList(inherited Clone);
end;

function TFhirQuestionnaireGroupQuestionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireGroupQuestionList.GetItemN(index: Integer): TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion(ObjectByIndex[index]);
end;

function TFhirQuestionnaireGroupQuestionList.IndexOf(value: TFhirQuestionnaireGroupQuestion): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirQuestionnaireGroupQuestionList.Insert(index: Integer): TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirQuestionnaireGroupQuestionList.InsertItem(index: Integer; value: TFhirQuestionnaireGroupQuestion);
begin
  assert(value is TFhirQuestionnaireGroupQuestion);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireGroupQuestionList.Item(index: Integer): TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion(ObjectByIndex[index]);
end;

function TFhirQuestionnaireGroupQuestionList.Link: TFhirQuestionnaireGroupQuestionList;
begin
  result := TFhirQuestionnaireGroupQuestionList(inherited Link);
end;

procedure TFhirQuestionnaireGroupQuestionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireGroupQuestionList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireGroupQuestion);
begin
  assert(value is TFhirQuestionnaireGroupQuestion);
  FhirQuestionnaireGroupQuestions[index] := value;
end;

procedure TFhirQuestionnaireGroupQuestionList.SetItemN(index: Integer; value: TFhirQuestionnaireGroupQuestion);
begin
  assert(value is TFhirQuestionnaireGroupQuestion);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventEvent }

constructor TFhirSecurityEventEvent.Create;
begin
  inherited;
  FSubtypeList := TFhirCodeableConceptList.Create;
end;

destructor TFhirSecurityEventEvent.Destroy;
begin
  FType_.free;
  FSubtypeList.Free;
  FAction.free;
  FDateTime.free;
  FOutcome.free;
  FOutcomeDesc.free;
  inherited;
end;

procedure TFhirSecurityEventEvent.Assign(oSource : TAdvObject);
begin
  inherited;
  type_ := TFhirSecurityEventEvent(oSource).type_.Clone;
  FSubtypeList.Assign(TFhirSecurityEventEvent(oSource).FSubtypeList);
  FAction := TFhirSecurityEventEvent(oSource).FAction.Link;
  dateTimeObject := TFhirSecurityEventEvent(oSource).dateTimeObject.Clone;
  FOutcome := TFhirSecurityEventEvent(oSource).FOutcome.Link;
  outcomeDescObject := TFhirSecurityEventEvent(oSource).outcomeDescObject.Clone;
end;

procedure TFhirSecurityEventEvent.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'subtype') Then
     list.addAll(FSubtypeList);
  if (child_name = 'action') Then
     list.add(FAction.Link);
  if (child_name = 'dateTime') Then
     list.add(FDateTime.Link);
  if (child_name = 'outcome') Then
     list.add(FOutcome.Link);
  if (child_name = 'outcomeDesc') Then
     list.add(FOutcomeDesc.Link);
end;

procedure TFhirSecurityEventEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subtype', 'CodeableConcept', FSubtypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', 'code', FAction.Link));{1}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'instant', FDateTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'outcomeDesc', 'string', FOutcomeDesc.Link));{2}
end;

procedure TFhirSecurityEventEvent.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'type') then Type_ := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'subtype') then SubtypeList.add(propValue as TFhirCodeableConcept){2}
  else if (propName = 'action') then ActionObject := propValue as TFHIREnum
  else if (propName = 'dateTime') then DateTimeObject := propValue as TFhirInstant{5a}
  else if (propName = 'outcome') then OutcomeObject := propValue as TFHIREnum
  else if (propName = 'outcomeDesc') then OutcomeDescObject := propValue as TFhirString{5a}
  else inherited;
end;

function TFhirSecurityEventEvent.FhirType : string;
begin
  result := 'event';
end;

function TFhirSecurityEventEvent.Link : TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent(inherited Link);
end;

function TFhirSecurityEventEvent.Clone : TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent(inherited Clone);
end;

{ TFhirSecurityEventEvent }

Procedure TFhirSecurityEventEvent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSecurityEventEvent.SetAction(value : TFhirEnum);
begin
  FAction.free;
  FAction := value;
end;

Function TFhirSecurityEventEvent.GetActionST : TFhirSecurityEventAction;
begin
  if FAction = nil then
    result := TFhirSecurityEventAction(0)
  else
    result := TFhirSecurityEventAction(StringArrayIndexOfSensitive(CODES_TFhirSecurityEventAction, FAction.value));
end;

Procedure TFhirSecurityEventEvent.SetActionST(value : TFhirSecurityEventAction);
begin
  if ord(value) = 0 then
    ActionObject := nil
  else
    ActionObject := TFhirEnum.create(CODES_TFhirSecurityEventAction[value]);
end;

Procedure TFhirSecurityEventEvent.SetDateTime(value : TFhirInstant);
begin
  FDateTime.free;
  FDateTime := value;
end;

Function TFhirSecurityEventEvent.GetDateTimeST : TDateTimeEx;
begin
  if FDateTime = nil then
    result := nil
  else
    result := FDateTime.value;
end;

Procedure TFhirSecurityEventEvent.SetDateTimeST(value : TDateTimeEx);
begin
  if value <> nil then
  begin
    if FDateTime = nil then
      FDateTime := TFhirInstant.create;
    FDateTime.value := value
  end
  else if FDateTime <> nil then
    FDateTime.value := nil;
end;

Procedure TFhirSecurityEventEvent.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirSecurityEventEvent.GetOutcomeST : TFhirSecurityEventOutcome;
begin
  if FOutcome = nil then
    result := TFhirSecurityEventOutcome(0)
  else
    result := TFhirSecurityEventOutcome(StringArrayIndexOfSensitive(CODES_TFhirSecurityEventOutcome, FOutcome.value));
end;

Procedure TFhirSecurityEventEvent.SetOutcomeST(value : TFhirSecurityEventOutcome);
begin
  if ord(value) = 0 then
    OutcomeObject := nil
  else
    OutcomeObject := TFhirEnum.create(CODES_TFhirSecurityEventOutcome[value]);
end;

Procedure TFhirSecurityEventEvent.SetOutcomeDesc(value : TFhirString);
begin
  FOutcomeDesc.free;
  FOutcomeDesc := value;
end;

Function TFhirSecurityEventEvent.GetOutcomeDescST : String;
begin
  if FOutcomeDesc = nil then
    result := ''
  else
    result := FOutcomeDesc.value;
end;

Procedure TFhirSecurityEventEvent.SetOutcomeDescST(value : String);
begin
  if value <> '' then
  begin
    if FOutcomeDesc = nil then
      FOutcomeDesc := TFhirString.create;
    FOutcomeDesc.value := value
  end
  else if FOutcomeDesc <> nil then
    FOutcomeDesc.value := '';
end;


{ TFhirSecurityEventEventListEnumerator }

Constructor TFhirSecurityEventEventListEnumerator.Create(list : TFhirSecurityEventEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirSecurityEventEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSecurityEventEventListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirSecurityEventEventListEnumerator.GetCurrent : TFhirSecurityEventEvent;
begin
  Result := FList[FIndex];
end;


{ TFhirSecurityEventEventList }
procedure TFhirSecurityEventEventList.AddItem(value: TFhirSecurityEventEvent);
begin
  assert(value.ClassName = 'TFhirSecurityEventEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventEvent');
  add(value);
end;


function TFhirSecurityEventEventList.Append: TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventEventList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventEventList.GetEnumerator : TFhirSecurityEventEventListEnumerator;
begin
  result := TFhirSecurityEventEventListEnumerator.Create(self.link);
end;

function TFhirSecurityEventEventList.Clone: TFhirSecurityEventEventList;
begin
  result := TFhirSecurityEventEventList(inherited Clone);
end;

function TFhirSecurityEventEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventEventList.GetItemN(index: Integer): TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent(ObjectByIndex[index]);
end;

function TFhirSecurityEventEventList.IndexOf(value: TFhirSecurityEventEvent): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventEventList.Insert(index: Integer): TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventEventList.InsertItem(index: Integer; value: TFhirSecurityEventEvent);
begin
  assert(value is TFhirSecurityEventEvent);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventEventList.Item(index: Integer): TFhirSecurityEventEvent;
begin
  result := TFhirSecurityEventEvent(ObjectByIndex[index]);
end;

function TFhirSecurityEventEventList.Link: TFhirSecurityEventEventList;
begin
  result := TFhirSecurityEventEventList(inherited Link);
end;

procedure TFhirSecurityEventEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventEventList.SetItemByIndex(index: Integer; value: TFhirSecurityEventEvent);
begin
  assert(value is TFhirSecurityEventEvent);
  FhirSecurityEventEvents[index] := value;
end;

procedure TFhirSecurityEventEventList.SetItemN(index: Integer; value: TFhirSecurityEventEvent);
begin
  assert(value is TFhirSecurityEventEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventParticipant }

constructor TFhirSecurityEventParticipant.Create;
begin
  inherited;
  FRoleList := TFhirCodeableConceptList.Create;
end;

destructor TFhirSecurityEventParticipant.Destroy;
begin
  FRoleList.Free;
  FReference.free;
  FUserId.free;
  FAltId.free;
  FName.free;
  FRequestor.free;
  FMedia.free;
  FNetwork.free;
  inherited;
end;

procedure TFhirSecurityEventParticipant.Assign(oSource : TAdvObject);
begin
  inherited;
  FRoleList.Assign(TFhirSecurityEventParticipant(oSource).FRoleList);
  reference := TFhirSecurityEventParticipant(oSource).reference.Clone;
  userIdObject := TFhirSecurityEventParticipant(oSource).userIdObject.Clone;
  altIdObject := TFhirSecurityEventParticipant(oSource).altIdObject.Clone;
  nameObject := TFhirSecurityEventParticipant(oSource).nameObject.Clone;
  requestorObject := TFhirSecurityEventParticipant(oSource).requestorObject.Clone;
  media := TFhirSecurityEventParticipant(oSource).media.Clone;
  network := TFhirSecurityEventParticipant(oSource).network.Clone;
end;

procedure TFhirSecurityEventParticipant.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'role') Then
     list.addAll(FRoleList);
  if (child_name = 'reference') Then
     list.add(FReference.Link);
  if (child_name = 'userId') Then
     list.add(FUserId.Link);
  if (child_name = 'altId') Then
     list.add(FAltId.Link);
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'requestor') Then
     list.add(FRequestor.Link);
  if (child_name = 'media') Then
     list.add(FMedia.Link);
  if (child_name = 'network') Then
     list.add(FNetwork.Link);
end;

procedure TFhirSecurityEventParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', FRoleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reference', 'Resource(Practitioner|Patient|Device)', FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'userId', 'string', FUserId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'altId', 'string', FAltId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestor', 'boolean', FRequestor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'media', 'Coding', FMedia.Link));{2}
  oList.add(TFHIRProperty.create(self, 'network', '', FNetwork.Link));{2}
end;

procedure TFhirSecurityEventParticipant.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'role') then RoleList.add(propValue as TFhirCodeableConcept){2}
  else if (propName = 'reference') then Reference := propValue as TFhirResourceReference{Resource}{4b}
  else if (propName = 'userId') then UserIdObject := propValue as TFhirString{5a}
  else if (propName = 'altId') then AltIdObject := propValue as TFhirString{5a}
  else if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'requestor') then RequestorObject := propValue as TFhirBoolean{5a}
  else if (propName = 'media') then Media := propValue as TFhirCoding{4b}
  else if (propName = 'network') then Network := propValue as TFhirSecurityEventParticipantNetwork{4b}
  else inherited;
end;

function TFhirSecurityEventParticipant.FhirType : string;
begin
  result := 'participant';
end;

function TFhirSecurityEventParticipant.Link : TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant(inherited Link);
end;

function TFhirSecurityEventParticipant.Clone : TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant(inherited Clone);
end;

{ TFhirSecurityEventParticipant }

Procedure TFhirSecurityEventParticipant.SetReference(value : TFhirResourceReference{Resource});
begin
  FReference.free;
  FReference := value;
end;

Procedure TFhirSecurityEventParticipant.SetUserId(value : TFhirString);
begin
  FUserId.free;
  FUserId := value;
end;

Function TFhirSecurityEventParticipant.GetUserIdST : String;
begin
  if FUserId = nil then
    result := ''
  else
    result := FUserId.value;
end;

Procedure TFhirSecurityEventParticipant.SetUserIdST(value : String);
begin
  if value <> '' then
  begin
    if FUserId = nil then
      FUserId := TFhirString.create;
    FUserId.value := value
  end
  else if FUserId <> nil then
    FUserId.value := '';
end;

Procedure TFhirSecurityEventParticipant.SetAltId(value : TFhirString);
begin
  FAltId.free;
  FAltId := value;
end;

Function TFhirSecurityEventParticipant.GetAltIdST : String;
begin
  if FAltId = nil then
    result := ''
  else
    result := FAltId.value;
end;

Procedure TFhirSecurityEventParticipant.SetAltIdST(value : String);
begin
  if value <> '' then
  begin
    if FAltId = nil then
      FAltId := TFhirString.create;
    FAltId.value := value
  end
  else if FAltId <> nil then
    FAltId.value := '';
end;

Procedure TFhirSecurityEventParticipant.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirSecurityEventParticipant.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirSecurityEventParticipant.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirSecurityEventParticipant.SetRequestor(value : TFhirBoolean);
begin
  FRequestor.free;
  FRequestor := value;
end;

Function TFhirSecurityEventParticipant.GetRequestorST : Boolean;
begin
  if FRequestor = nil then
    result := false
  else
    result := FRequestor.value;
end;

Procedure TFhirSecurityEventParticipant.SetRequestorST(value : Boolean);
begin
  if FRequestor = nil then
    FRequestor := TFhirBoolean.create;
  FRequestor.value := value
end;

Procedure TFhirSecurityEventParticipant.SetMedia(value : TFhirCoding);
begin
  FMedia.free;
  FMedia := value;
end;

Procedure TFhirSecurityEventParticipant.SetNetwork(value : TFhirSecurityEventParticipantNetwork);
begin
  FNetwork.free;
  FNetwork := value;
end;


{ TFhirSecurityEventParticipantListEnumerator }

Constructor TFhirSecurityEventParticipantListEnumerator.Create(list : TFhirSecurityEventParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirSecurityEventParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSecurityEventParticipantListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirSecurityEventParticipantListEnumerator.GetCurrent : TFhirSecurityEventParticipant;
begin
  Result := FList[FIndex];
end;


{ TFhirSecurityEventParticipantList }
procedure TFhirSecurityEventParticipantList.AddItem(value: TFhirSecurityEventParticipant);
begin
  assert(value.ClassName = 'TFhirSecurityEventParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventParticipant');
  add(value);
end;


function TFhirSecurityEventParticipantList.Append: TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventParticipantList.GetEnumerator : TFhirSecurityEventParticipantListEnumerator;
begin
  result := TFhirSecurityEventParticipantListEnumerator.Create(self.link);
end;

function TFhirSecurityEventParticipantList.Clone: TFhirSecurityEventParticipantList;
begin
  result := TFhirSecurityEventParticipantList(inherited Clone);
end;

function TFhirSecurityEventParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventParticipantList.GetItemN(index: Integer): TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant(ObjectByIndex[index]);
end;

function TFhirSecurityEventParticipantList.IndexOf(value: TFhirSecurityEventParticipant): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventParticipantList.Insert(index: Integer): TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventParticipantList.InsertItem(index: Integer; value: TFhirSecurityEventParticipant);
begin
  assert(value is TFhirSecurityEventParticipant);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventParticipantList.Item(index: Integer): TFhirSecurityEventParticipant;
begin
  result := TFhirSecurityEventParticipant(ObjectByIndex[index]);
end;

function TFhirSecurityEventParticipantList.Link: TFhirSecurityEventParticipantList;
begin
  result := TFhirSecurityEventParticipantList(inherited Link);
end;

procedure TFhirSecurityEventParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventParticipantList.SetItemByIndex(index: Integer; value: TFhirSecurityEventParticipant);
begin
  assert(value is TFhirSecurityEventParticipant);
  FhirSecurityEventParticipants[index] := value;
end;

procedure TFhirSecurityEventParticipantList.SetItemN(index: Integer; value: TFhirSecurityEventParticipant);
begin
  assert(value is TFhirSecurityEventParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventParticipantNetwork }

constructor TFhirSecurityEventParticipantNetwork.Create;
begin
  inherited;
end;

destructor TFhirSecurityEventParticipantNetwork.Destroy;
begin
  FIdentifier.free;
  FType_.free;
  inherited;
end;

procedure TFhirSecurityEventParticipantNetwork.Assign(oSource : TAdvObject);
begin
  inherited;
  identifierObject := TFhirSecurityEventParticipantNetwork(oSource).identifierObject.Clone;
  FType_ := TFhirSecurityEventParticipantNetwork(oSource).FType_.Link;
end;

procedure TFhirSecurityEventParticipantNetwork.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(FIdentifier.Link);
  if (child_name = 'type') Then
     list.add(FType_.Link);
end;

procedure TFhirSecurityEventParticipantNetwork.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'string', FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
end;

procedure TFhirSecurityEventParticipantNetwork.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierObject := propValue as TFhirString{5a}
  else if (propName = 'type') then Type_Object := propValue as TFHIREnum
  else inherited;
end;

function TFhirSecurityEventParticipantNetwork.FhirType : string;
begin
  result := 'network';
end;

function TFhirSecurityEventParticipantNetwork.Link : TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork(inherited Link);
end;

function TFhirSecurityEventParticipantNetwork.Clone : TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork(inherited Clone);
end;

{ TFhirSecurityEventParticipantNetwork }

Procedure TFhirSecurityEventParticipantNetwork.SetIdentifier(value : TFhirString);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirSecurityEventParticipantNetwork.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := FIdentifier.value;
end;

Procedure TFhirSecurityEventParticipantNetwork.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirString.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

Procedure TFhirSecurityEventParticipantNetwork.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSecurityEventParticipantNetwork.GetType_ST : TFhirNetworkType;
begin
  if FType_ = nil then
    result := TFhirNetworkType(0)
  else
    result := TFhirNetworkType(StringArrayIndexOfSensitive(CODES_TFhirNetworkType, FType_.value));
end;

Procedure TFhirSecurityEventParticipantNetwork.SetType_ST(value : TFhirNetworkType);
begin
  if ord(value) = 0 then
    Type_Object := nil
  else
    Type_Object := TFhirEnum.create(CODES_TFhirNetworkType[value]);
end;


{ TFhirSecurityEventParticipantNetworkListEnumerator }

Constructor TFhirSecurityEventParticipantNetworkListEnumerator.Create(list : TFhirSecurityEventParticipantNetworkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirSecurityEventParticipantNetworkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSecurityEventParticipantNetworkListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirSecurityEventParticipantNetworkListEnumerator.GetCurrent : TFhirSecurityEventParticipantNetwork;
begin
  Result := FList[FIndex];
end;


{ TFhirSecurityEventParticipantNetworkList }
procedure TFhirSecurityEventParticipantNetworkList.AddItem(value: TFhirSecurityEventParticipantNetwork);
begin
  assert(value.ClassName = 'TFhirSecurityEventParticipantNetwork', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventParticipantNetwork');
  add(value);
end;


function TFhirSecurityEventParticipantNetworkList.Append: TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventParticipantNetworkList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventParticipantNetworkList.GetEnumerator : TFhirSecurityEventParticipantNetworkListEnumerator;
begin
  result := TFhirSecurityEventParticipantNetworkListEnumerator.Create(self.link);
end;

function TFhirSecurityEventParticipantNetworkList.Clone: TFhirSecurityEventParticipantNetworkList;
begin
  result := TFhirSecurityEventParticipantNetworkList(inherited Clone);
end;

function TFhirSecurityEventParticipantNetworkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventParticipantNetworkList.GetItemN(index: Integer): TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork(ObjectByIndex[index]);
end;

function TFhirSecurityEventParticipantNetworkList.IndexOf(value: TFhirSecurityEventParticipantNetwork): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventParticipantNetworkList.Insert(index: Integer): TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventParticipantNetworkList.InsertItem(index: Integer; value: TFhirSecurityEventParticipantNetwork);
begin
  assert(value is TFhirSecurityEventParticipantNetwork);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventParticipantNetworkList.Item(index: Integer): TFhirSecurityEventParticipantNetwork;
begin
  result := TFhirSecurityEventParticipantNetwork(ObjectByIndex[index]);
end;

function TFhirSecurityEventParticipantNetworkList.Link: TFhirSecurityEventParticipantNetworkList;
begin
  result := TFhirSecurityEventParticipantNetworkList(inherited Link);
end;

procedure TFhirSecurityEventParticipantNetworkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventParticipantNetworkList.SetItemByIndex(index: Integer; value: TFhirSecurityEventParticipantNetwork);
begin
  assert(value is TFhirSecurityEventParticipantNetwork);
  FhirSecurityEventParticipantNetworks[index] := value;
end;

procedure TFhirSecurityEventParticipantNetworkList.SetItemN(index: Integer; value: TFhirSecurityEventParticipantNetwork);
begin
  assert(value is TFhirSecurityEventParticipantNetwork);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventSource }

constructor TFhirSecurityEventSource.Create;
begin
  inherited;
  FType_List := TFhirCodingList.Create;
end;

destructor TFhirSecurityEventSource.Destroy;
begin
  FSite.free;
  FIdentifier.free;
  FType_List.Free;
  inherited;
end;

procedure TFhirSecurityEventSource.Assign(oSource : TAdvObject);
begin
  inherited;
  siteObject := TFhirSecurityEventSource(oSource).siteObject.Clone;
  identifierObject := TFhirSecurityEventSource(oSource).identifierObject.Clone;
  FType_List.Assign(TFhirSecurityEventSource(oSource).FType_List);
end;

procedure TFhirSecurityEventSource.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'site') Then
     list.add(FSite.Link);
  if (child_name = 'identifier') Then
     list.add(FIdentifier.Link);
  if (child_name = 'type') Then
     list.addAll(FType_List);
end;

procedure TFhirSecurityEventSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'site', 'string', FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'string', FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', FType_List.Link)){3};
end;

procedure TFhirSecurityEventSource.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'site') then SiteObject := propValue as TFhirString{5a}
  else if (propName = 'identifier') then IdentifierObject := propValue as TFhirString{5a}
  else if (propName = 'type') then Type_List.add(propValue as TFhirCoding){2}
  else inherited;
end;

function TFhirSecurityEventSource.FhirType : string;
begin
  result := 'source';
end;

function TFhirSecurityEventSource.Link : TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource(inherited Link);
end;

function TFhirSecurityEventSource.Clone : TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource(inherited Clone);
end;

{ TFhirSecurityEventSource }

Procedure TFhirSecurityEventSource.SetSite(value : TFhirString);
begin
  FSite.free;
  FSite := value;
end;

Function TFhirSecurityEventSource.GetSiteST : String;
begin
  if FSite = nil then
    result := ''
  else
    result := FSite.value;
end;

Procedure TFhirSecurityEventSource.SetSiteST(value : String);
begin
  if value <> '' then
  begin
    if FSite = nil then
      FSite := TFhirString.create;
    FSite.value := value
  end
  else if FSite <> nil then
    FSite.value := '';
end;

Procedure TFhirSecurityEventSource.SetIdentifier(value : TFhirString);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirSecurityEventSource.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := FIdentifier.value;
end;

Procedure TFhirSecurityEventSource.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirString.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;


{ TFhirSecurityEventSourceListEnumerator }

Constructor TFhirSecurityEventSourceListEnumerator.Create(list : TFhirSecurityEventSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirSecurityEventSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSecurityEventSourceListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirSecurityEventSourceListEnumerator.GetCurrent : TFhirSecurityEventSource;
begin
  Result := FList[FIndex];
end;


{ TFhirSecurityEventSourceList }
procedure TFhirSecurityEventSourceList.AddItem(value: TFhirSecurityEventSource);
begin
  assert(value.ClassName = 'TFhirSecurityEventSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventSource');
  add(value);
end;


function TFhirSecurityEventSourceList.Append: TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventSourceList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventSourceList.GetEnumerator : TFhirSecurityEventSourceListEnumerator;
begin
  result := TFhirSecurityEventSourceListEnumerator.Create(self.link);
end;

function TFhirSecurityEventSourceList.Clone: TFhirSecurityEventSourceList;
begin
  result := TFhirSecurityEventSourceList(inherited Clone);
end;

function TFhirSecurityEventSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventSourceList.GetItemN(index: Integer): TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource(ObjectByIndex[index]);
end;

function TFhirSecurityEventSourceList.IndexOf(value: TFhirSecurityEventSource): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventSourceList.Insert(index: Integer): TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventSourceList.InsertItem(index: Integer; value: TFhirSecurityEventSource);
begin
  assert(value is TFhirSecurityEventSource);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventSourceList.Item(index: Integer): TFhirSecurityEventSource;
begin
  result := TFhirSecurityEventSource(ObjectByIndex[index]);
end;

function TFhirSecurityEventSourceList.Link: TFhirSecurityEventSourceList;
begin
  result := TFhirSecurityEventSourceList(inherited Link);
end;

procedure TFhirSecurityEventSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventSourceList.SetItemByIndex(index: Integer; value: TFhirSecurityEventSource);
begin
  assert(value is TFhirSecurityEventSource);
  FhirSecurityEventSources[index] := value;
end;

procedure TFhirSecurityEventSourceList.SetItemN(index: Integer; value: TFhirSecurityEventSource);
begin
  assert(value is TFhirSecurityEventSource);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventObject }

constructor TFhirSecurityEventObject.Create;
begin
  inherited;
  FDetailList := TFhirSecurityEventObjectDetailList.Create;
end;

destructor TFhirSecurityEventObject.Destroy;
begin
  FIdentifier.free;
  FReference.free;
  FType_.free;
  FRole.free;
  FLifecycle.free;
  FSensitivity.free;
  FName.free;
  FDescription.free;
  FQuery.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirSecurityEventObject.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirSecurityEventObject(oSource).identifier.Clone;
  reference := TFhirSecurityEventObject(oSource).reference.Clone;
  FType_ := TFhirSecurityEventObject(oSource).FType_.Link;
  FRole := TFhirSecurityEventObject(oSource).FRole.Link;
  FLifecycle := TFhirSecurityEventObject(oSource).FLifecycle.Link;
  sensitivity := TFhirSecurityEventObject(oSource).sensitivity.Clone;
  nameObject := TFhirSecurityEventObject(oSource).nameObject.Clone;
  descriptionObject := TFhirSecurityEventObject(oSource).descriptionObject.Clone;
  queryObject := TFhirSecurityEventObject(oSource).queryObject.Clone;
  FDetailList.Assign(TFhirSecurityEventObject(oSource).FDetailList);
end;

procedure TFhirSecurityEventObject.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(FIdentifier.Link);
  if (child_name = 'reference') Then
     list.add(FReference.Link);
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'role') Then
     list.add(FRole.Link);
  if (child_name = 'lifecycle') Then
     list.add(FLifecycle.Link);
  if (child_name = 'sensitivity') Then
     list.add(FSensitivity.Link);
  if (child_name = 'name') Then
     list.add(FName.Link);
  if (child_name = 'description') Then
     list.add(FDescription.Link);
  if (child_name = 'query') Then
     list.add(FQuery.Link);
  if (child_name = 'detail') Then
     list.addAll(FDetailList);
end;

procedure TFhirSecurityEventObject.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'Resource(Any)', FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'role', 'code', FRole.Link));{1}
  oList.add(TFHIRProperty.create(self, 'lifecycle', 'code', FLifecycle.Link));{1}
  oList.add(TFHIRProperty.create(self, 'sensitivity', 'CodeableConcept', FSensitivity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'query', 'base64Binary', FQuery.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', '', FDetailList.Link)){3};
end;

procedure TFhirSecurityEventObject.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'identifier') then Identifier := propValue as TFhirIdentifier{4b}
  else if (propName = 'reference') then Reference := propValue as TFhirResourceReference{Resource}{4b}
  else if (propName = 'type') then Type_Object := propValue as TFHIREnum
  else if (propName = 'role') then RoleObject := propValue as TFHIREnum
  else if (propName = 'lifecycle') then LifecycleObject := propValue as TFHIREnum
  else if (propName = 'sensitivity') then Sensitivity := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'name') then NameObject := propValue as TFhirString{5a}
  else if (propName = 'description') then DescriptionObject := propValue as TFhirString{5a}
  else if (propName = 'query') then QueryObject := propValue as TFhirBase64Binary{5a}
  else if (propName = 'detail') then DetailList.add(propValue as TFhirSecurityEventObjectDetail){2}
  else inherited;
end;

function TFhirSecurityEventObject.FhirType : string;
begin
  result := 'object';
end;

function TFhirSecurityEventObject.Link : TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject(inherited Link);
end;

function TFhirSecurityEventObject.Clone : TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject(inherited Clone);
end;

{ TFhirSecurityEventObject }

Procedure TFhirSecurityEventObject.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSecurityEventObject.SetReference(value : TFhirResourceReference{Resource});
begin
  FReference.free;
  FReference := value;
end;

Procedure TFhirSecurityEventObject.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSecurityEventObject.GetType_ST : TFhirObjectType;
begin
  if FType_ = nil then
    result := TFhirObjectType(0)
  else
    result := TFhirObjectType(StringArrayIndexOfSensitive(CODES_TFhirObjectType, FType_.value));
end;

Procedure TFhirSecurityEventObject.SetType_ST(value : TFhirObjectType);
begin
  if ord(value) = 0 then
    Type_Object := nil
  else
    Type_Object := TFhirEnum.create(CODES_TFhirObjectType[value]);
end;

Procedure TFhirSecurityEventObject.SetRole(value : TFhirEnum);
begin
  FRole.free;
  FRole := value;
end;

Function TFhirSecurityEventObject.GetRoleST : TFhirObjectRole;
begin
  if FRole = nil then
    result := TFhirObjectRole(0)
  else
    result := TFhirObjectRole(StringArrayIndexOfSensitive(CODES_TFhirObjectRole, FRole.value));
end;

Procedure TFhirSecurityEventObject.SetRoleST(value : TFhirObjectRole);
begin
  if ord(value) = 0 then
    RoleObject := nil
  else
    RoleObject := TFhirEnum.create(CODES_TFhirObjectRole[value]);
end;

Procedure TFhirSecurityEventObject.SetLifecycle(value : TFhirEnum);
begin
  FLifecycle.free;
  FLifecycle := value;
end;

Function TFhirSecurityEventObject.GetLifecycleST : TFhirObjectLifecycle;
begin
  if FLifecycle = nil then
    result := TFhirObjectLifecycle(0)
  else
    result := TFhirObjectLifecycle(StringArrayIndexOfSensitive(CODES_TFhirObjectLifecycle, FLifecycle.value));
end;

Procedure TFhirSecurityEventObject.SetLifecycleST(value : TFhirObjectLifecycle);
begin
  if ord(value) = 0 then
    LifecycleObject := nil
  else
    LifecycleObject := TFhirEnum.create(CODES_TFhirObjectLifecycle[value]);
end;

Procedure TFhirSecurityEventObject.SetSensitivity(value : TFhirCodeableConcept);
begin
  FSensitivity.free;
  FSensitivity := value;
end;

Procedure TFhirSecurityEventObject.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirSecurityEventObject.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirSecurityEventObject.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirSecurityEventObject.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSecurityEventObject.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirSecurityEventObject.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirSecurityEventObject.SetQuery(value : TFhirBase64Binary);
begin
  FQuery.free;
  FQuery := value;
end;

Function TFhirSecurityEventObject.GetQueryST : String;
begin
  if FQuery = nil then
    result := ''
  else
    result := FQuery.value;
end;

Procedure TFhirSecurityEventObject.SetQueryST(value : String);
begin
  if value <> '' then
  begin
    if FQuery = nil then
      FQuery := TFhirBase64Binary.create;
    FQuery.value := value
  end
  else if FQuery <> nil then
    FQuery.value := '';
end;


{ TFhirSecurityEventObjectListEnumerator }

Constructor TFhirSecurityEventObjectListEnumerator.Create(list : TFhirSecurityEventObjectList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirSecurityEventObjectListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSecurityEventObjectListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirSecurityEventObjectListEnumerator.GetCurrent : TFhirSecurityEventObject;
begin
  Result := FList[FIndex];
end;


{ TFhirSecurityEventObjectList }
procedure TFhirSecurityEventObjectList.AddItem(value: TFhirSecurityEventObject);
begin
  assert(value.ClassName = 'TFhirSecurityEventObject', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventObject');
  add(value);
end;


function TFhirSecurityEventObjectList.Append: TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventObjectList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventObjectList.GetEnumerator : TFhirSecurityEventObjectListEnumerator;
begin
  result := TFhirSecurityEventObjectListEnumerator.Create(self.link);
end;

function TFhirSecurityEventObjectList.Clone: TFhirSecurityEventObjectList;
begin
  result := TFhirSecurityEventObjectList(inherited Clone);
end;

function TFhirSecurityEventObjectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventObjectList.GetItemN(index: Integer): TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject(ObjectByIndex[index]);
end;

function TFhirSecurityEventObjectList.IndexOf(value: TFhirSecurityEventObject): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventObjectList.Insert(index: Integer): TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventObjectList.InsertItem(index: Integer; value: TFhirSecurityEventObject);
begin
  assert(value is TFhirSecurityEventObject);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventObjectList.Item(index: Integer): TFhirSecurityEventObject;
begin
  result := TFhirSecurityEventObject(ObjectByIndex[index]);
end;

function TFhirSecurityEventObjectList.Link: TFhirSecurityEventObjectList;
begin
  result := TFhirSecurityEventObjectList(inherited Link);
end;

procedure TFhirSecurityEventObjectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventObjectList.SetItemByIndex(index: Integer; value: TFhirSecurityEventObject);
begin
  assert(value is TFhirSecurityEventObject);
  FhirSecurityEventObjects[index] := value;
end;

procedure TFhirSecurityEventObjectList.SetItemN(index: Integer; value: TFhirSecurityEventObject);
begin
  assert(value is TFhirSecurityEventObject);
  ObjectByIndex[index] := value;
end;

{ TFhirSecurityEventObjectDetail }

constructor TFhirSecurityEventObjectDetail.Create;
begin
  inherited;
end;

destructor TFhirSecurityEventObjectDetail.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirSecurityEventObjectDetail.Assign(oSource : TAdvObject);
begin
  inherited;
  type_Object := TFhirSecurityEventObjectDetail(oSource).type_Object.Clone;
  valueObject := TFhirSecurityEventObjectDetail(oSource).valueObject.Clone;
end;

procedure TFhirSecurityEventObjectDetail.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'value') Then
     list.add(FValue.Link);
end;

procedure TFhirSecurityEventObjectDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'string', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'base64Binary', FValue.Link));{2}
end;

procedure TFhirSecurityEventObjectDetail.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'type') then Type_Object := propValue as TFhirString{5a}
  else if (propName = 'value') then ValueObject := propValue as TFhirBase64Binary{5a}
  else inherited;
end;

function TFhirSecurityEventObjectDetail.FhirType : string;
begin
  result := 'detail';
end;

function TFhirSecurityEventObjectDetail.Link : TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail(inherited Link);
end;

function TFhirSecurityEventObjectDetail.Clone : TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail(inherited Clone);
end;

{ TFhirSecurityEventObjectDetail }

Procedure TFhirSecurityEventObjectDetail.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSecurityEventObjectDetail.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirSecurityEventObjectDetail.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirSecurityEventObjectDetail.SetValue(value : TFhirBase64Binary);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirSecurityEventObjectDetail.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirSecurityEventObjectDetail.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirBase64Binary.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;


{ TFhirSecurityEventObjectDetailListEnumerator }

Constructor TFhirSecurityEventObjectDetailListEnumerator.Create(list : TFhirSecurityEventObjectDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirSecurityEventObjectDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSecurityEventObjectDetailListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirSecurityEventObjectDetailListEnumerator.GetCurrent : TFhirSecurityEventObjectDetail;
begin
  Result := FList[FIndex];
end;


{ TFhirSecurityEventObjectDetailList }
procedure TFhirSecurityEventObjectDetailList.AddItem(value: TFhirSecurityEventObjectDetail);
begin
  assert(value.ClassName = 'TFhirSecurityEventObjectDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSecurityEventObjectDetail');
  add(value);
end;


function TFhirSecurityEventObjectDetailList.Append: TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventObjectDetailList.ClearItems;
begin
  Clear;
end;

function TFhirSecurityEventObjectDetailList.GetEnumerator : TFhirSecurityEventObjectDetailListEnumerator;
begin
  result := TFhirSecurityEventObjectDetailListEnumerator.Create(self.link);
end;

function TFhirSecurityEventObjectDetailList.Clone: TFhirSecurityEventObjectDetailList;
begin
  result := TFhirSecurityEventObjectDetailList(inherited Clone);
end;

function TFhirSecurityEventObjectDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSecurityEventObjectDetailList.GetItemN(index: Integer): TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail(ObjectByIndex[index]);
end;

function TFhirSecurityEventObjectDetailList.IndexOf(value: TFhirSecurityEventObjectDetail): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSecurityEventObjectDetailList.Insert(index: Integer): TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSecurityEventObjectDetailList.InsertItem(index: Integer; value: TFhirSecurityEventObjectDetail);
begin
  assert(value is TFhirSecurityEventObjectDetail);
  Inherited Insert(index, value);
end;

function TFhirSecurityEventObjectDetailList.Item(index: Integer): TFhirSecurityEventObjectDetail;
begin
  result := TFhirSecurityEventObjectDetail(ObjectByIndex[index]);
end;

function TFhirSecurityEventObjectDetailList.Link: TFhirSecurityEventObjectDetailList;
begin
  result := TFhirSecurityEventObjectDetailList(inherited Link);
end;

procedure TFhirSecurityEventObjectDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSecurityEventObjectDetailList.SetItemByIndex(index: Integer; value: TFhirSecurityEventObjectDetail);
begin
  assert(value is TFhirSecurityEventObjectDetail);
  FhirSecurityEventObjectDetails[index] := value;
end;

procedure TFhirSecurityEventObjectDetailList.SetItemN(index: Integer; value: TFhirSecurityEventObjectDetail);
begin
  assert(value is TFhirSecurityEventObjectDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenSource }

constructor TFhirSpecimenSource.Create;
begin
  inherited;
  FTargetList := TFhirResourceReferenceList{TFhirSpecimen}.Create;
end;

destructor TFhirSpecimenSource.Destroy;
begin
  FRelationship.free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirSpecimenSource.Assign(oSource : TAdvObject);
begin
  inherited;
  FRelationship := TFhirSpecimenSource(oSource).FRelationship.Link;
  FTargetList.Assign(TFhirSpecimenSource(oSource).FTargetList);
end;

procedure TFhirSpecimenSource.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'relationship') Then
     list.add(FRelationship.Link);
  if (child_name = 'target') Then
     list.addAll(FTargetList);
end;

procedure TFhirSpecimenSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relationship', 'code', FRelationship.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Resource(Specimen)', FTargetList.Link)){3};
end;

procedure TFhirSpecimenSource.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'relationship') then RelationshipObject := propValue as TFHIREnum
  else if (propName = 'target') then TargetList.add(propValue as TFhirResourceReference{TFhirSpecimen}){2}
  else inherited;
end;

function TFhirSpecimenSource.FhirType : string;
begin
  result := 'source';
end;

function TFhirSpecimenSource.Link : TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource(inherited Link);
end;

function TFhirSpecimenSource.Clone : TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource(inherited Clone);
end;

{ TFhirSpecimenSource }

Procedure TFhirSpecimenSource.SetRelationship(value : TFhirEnum);
begin
  FRelationship.free;
  FRelationship := value;
end;

Function TFhirSpecimenSource.GetRelationshipST : TFhirHierarchicalRelationshipType;
begin
  if FRelationship = nil then
    result := TFhirHierarchicalRelationshipType(0)
  else
    result := TFhirHierarchicalRelationshipType(StringArrayIndexOfSensitive(CODES_TFhirHierarchicalRelationshipType, FRelationship.value));
end;

Procedure TFhirSpecimenSource.SetRelationshipST(value : TFhirHierarchicalRelationshipType);
begin
  if ord(value) = 0 then
    RelationshipObject := nil
  else
    RelationshipObject := TFhirEnum.create(CODES_TFhirHierarchicalRelationshipType[value]);
end;


{ TFhirSpecimenSourceListEnumerator }

Constructor TFhirSpecimenSourceListEnumerator.Create(list : TFhirSpecimenSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirSpecimenSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenSourceListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirSpecimenSourceListEnumerator.GetCurrent : TFhirSpecimenSource;
begin
  Result := FList[FIndex];
end;


{ TFhirSpecimenSourceList }
procedure TFhirSpecimenSourceList.AddItem(value: TFhirSpecimenSource);
begin
  assert(value.ClassName = 'TFhirSpecimenSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenSource');
  add(value);
end;


function TFhirSpecimenSourceList.Append: TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenSourceList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenSourceList.GetEnumerator : TFhirSpecimenSourceListEnumerator;
begin
  result := TFhirSpecimenSourceListEnumerator.Create(self.link);
end;

function TFhirSpecimenSourceList.Clone: TFhirSpecimenSourceList;
begin
  result := TFhirSpecimenSourceList(inherited Clone);
end;

function TFhirSpecimenSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenSourceList.GetItemN(index: Integer): TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource(ObjectByIndex[index]);
end;

function TFhirSpecimenSourceList.IndexOf(value: TFhirSpecimenSource): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSpecimenSourceList.Insert(index: Integer): TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenSourceList.InsertItem(index: Integer; value: TFhirSpecimenSource);
begin
  assert(value is TFhirSpecimenSource);
  Inherited Insert(index, value);
end;

function TFhirSpecimenSourceList.Item(index: Integer): TFhirSpecimenSource;
begin
  result := TFhirSpecimenSource(ObjectByIndex[index]);
end;

function TFhirSpecimenSourceList.Link: TFhirSpecimenSourceList;
begin
  result := TFhirSpecimenSourceList(inherited Link);
end;

procedure TFhirSpecimenSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenSourceList.SetItemByIndex(index: Integer; value: TFhirSpecimenSource);
begin
  assert(value is TFhirSpecimenSource);
  FhirSpecimenSources[index] := value;
end;

procedure TFhirSpecimenSourceList.SetItemN(index: Integer; value: TFhirSpecimenSource);
begin
  assert(value is TFhirSpecimenSource);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenCollection }

constructor TFhirSpecimenCollection.Create;
begin
  inherited;
  FCommentList := TFhirStringList.Create;
end;

destructor TFhirSpecimenCollection.Destroy;
begin
  FCollector.free;
  FCommentList.Free;
  FCollected.free;
  FQuantity.free;
  FMethod.free;
  FSourceSite.free;
  inherited;
end;

procedure TFhirSpecimenCollection.Assign(oSource : TAdvObject);
begin
  inherited;
  collector := TFhirSpecimenCollection(oSource).collector.Clone;
  FCommentList.Assign(TFhirSpecimenCollection(oSource).FCommentList);
  collected := TFhirSpecimenCollection(oSource).collected.Clone;
  quantity := TFhirSpecimenCollection(oSource).quantity.Clone;
  method := TFhirSpecimenCollection(oSource).method.Clone;
  sourceSite := TFhirSpecimenCollection(oSource).sourceSite.Clone;
end;

procedure TFhirSpecimenCollection.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'collector') Then
     list.add(FCollector.Link);
  if (child_name = 'comment') Then
     list.addAll(FCommentList);
  if (child_name = 'collected[x]') Then
     list.add(FCollected.Link);
  if (child_name = 'quantity') Then
     list.add(FQuantity.Link);
  if (child_name = 'method') Then
     list.add(FMethod.Link);
  if (child_name = 'sourceSite') Then
     list.add(FSourceSite.Link);
end;

procedure TFhirSpecimenCollection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'collector', 'Resource(Practitioner)', FCollector.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', FCommentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'collected[x]', 'dateTime|Period', FCollected.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceSite', 'CodeableConcept', FSourceSite.Link));{2}
end;

procedure TFhirSpecimenCollection.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'collector') then Collector := propValue as TFhirResourceReference{TFhirPractitioner}{4b}
  else if (propName = 'comment') then CommentList.add(propValue as TFhirString){2}
  else if (propName.startsWith('collected')) then Collected := propValue as TFhirType{4}
  else if (propName = 'quantity') then Quantity := propValue as TFhirQuantity{4b}
  else if (propName = 'method') then Method := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'sourceSite') then SourceSite := propValue as TFhirCodeableConcept{4b}
  else inherited;
end;

function TFhirSpecimenCollection.FhirType : string;
begin
  result := 'collection';
end;

function TFhirSpecimenCollection.Link : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(inherited Link);
end;

function TFhirSpecimenCollection.Clone : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(inherited Clone);
end;

{ TFhirSpecimenCollection }

Procedure TFhirSpecimenCollection.SetCollector(value : TFhirResourceReference{TFhirPractitioner});
begin
  FCollector.free;
  FCollector := value;
end;

Procedure TFhirSpecimenCollection.SetCollected(value : TFhirType);
begin
  FCollected.free;
  FCollected := value;
end;

Procedure TFhirSpecimenCollection.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSpecimenCollection.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirSpecimenCollection.SetSourceSite(value : TFhirCodeableConcept);
begin
  FSourceSite.free;
  FSourceSite := value;
end;


{ TFhirSpecimenCollectionListEnumerator }

Constructor TFhirSpecimenCollectionListEnumerator.Create(list : TFhirSpecimenCollectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirSpecimenCollectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenCollectionListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirSpecimenCollectionListEnumerator.GetCurrent : TFhirSpecimenCollection;
begin
  Result := FList[FIndex];
end;


{ TFhirSpecimenCollectionList }
procedure TFhirSpecimenCollectionList.AddItem(value: TFhirSpecimenCollection);
begin
  assert(value.ClassName = 'TFhirSpecimenCollection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenCollection');
  add(value);
end;


function TFhirSpecimenCollectionList.Append: TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenCollectionList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenCollectionList.GetEnumerator : TFhirSpecimenCollectionListEnumerator;
begin
  result := TFhirSpecimenCollectionListEnumerator.Create(self.link);
end;

function TFhirSpecimenCollectionList.Clone: TFhirSpecimenCollectionList;
begin
  result := TFhirSpecimenCollectionList(inherited Clone);
end;

function TFhirSpecimenCollectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenCollectionList.GetItemN(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(ObjectByIndex[index]);
end;

function TFhirSpecimenCollectionList.IndexOf(value: TFhirSpecimenCollection): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSpecimenCollectionList.Insert(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenCollectionList.InsertItem(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  Inherited Insert(index, value);
end;

function TFhirSpecimenCollectionList.Item(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(ObjectByIndex[index]);
end;

function TFhirSpecimenCollectionList.Link: TFhirSpecimenCollectionList;
begin
  result := TFhirSpecimenCollectionList(inherited Link);
end;

procedure TFhirSpecimenCollectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenCollectionList.SetItemByIndex(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  FhirSpecimenCollections[index] := value;
end;

procedure TFhirSpecimenCollectionList.SetItemN(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenTreatment }

constructor TFhirSpecimenTreatment.Create;
begin
  inherited;
  FAdditiveList := TFhirResourceReferenceList{TFhirSubstance}.Create;
end;

destructor TFhirSpecimenTreatment.Destroy;
begin
  FDescription.free;
  FProcedure_.free;
  FAdditiveList.Free;
  inherited;
end;

procedure TFhirSpecimenTreatment.Assign(oSource : TAdvObject);
begin
  inherited;
  descriptionObject := TFhirSpecimenTreatment(oSource).descriptionObject.Clone;
  procedure_ := TFhirSpecimenTreatment(oSource).procedure_.Clone;
  FAdditiveList.Assign(TFhirSpecimenTreatment(oSource).FAdditiveList);
end;

procedure TFhirSpecimenTreatment.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(FDescription.Link);
  if (child_name = 'procedure') Then
     list.add(FProcedure_.Link);
  if (child_name = 'additive') Then
     list.addAll(FAdditiveList);
end;

procedure TFhirSpecimenTreatment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'procedure', 'CodeableConcept', FProcedure_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additive', 'Resource(Substance)', FAdditiveList.Link)){3};
end;

procedure TFhirSpecimenTreatment.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'description') then DescriptionObject := propValue as TFhirString{5a}
  else if (propName = 'procedure') then Procedure_ := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'additive') then AdditiveList.add(propValue as TFhirResourceReference{TFhirSubstance}){2}
  else inherited;
end;

function TFhirSpecimenTreatment.FhirType : string;
begin
  result := 'treatment';
end;

function TFhirSpecimenTreatment.Link : TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(inherited Link);
end;

function TFhirSpecimenTreatment.Clone : TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(inherited Clone);
end;

{ TFhirSpecimenTreatment }

Procedure TFhirSpecimenTreatment.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSpecimenTreatment.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirSpecimenTreatment.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirSpecimenTreatment.SetProcedure_(value : TFhirCodeableConcept);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;


{ TFhirSpecimenTreatmentListEnumerator }

Constructor TFhirSpecimenTreatmentListEnumerator.Create(list : TFhirSpecimenTreatmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirSpecimenTreatmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenTreatmentListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirSpecimenTreatmentListEnumerator.GetCurrent : TFhirSpecimenTreatment;
begin
  Result := FList[FIndex];
end;


{ TFhirSpecimenTreatmentList }
procedure TFhirSpecimenTreatmentList.AddItem(value: TFhirSpecimenTreatment);
begin
  assert(value.ClassName = 'TFhirSpecimenTreatment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenTreatment');
  add(value);
end;


function TFhirSpecimenTreatmentList.Append: TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenTreatmentList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenTreatmentList.GetEnumerator : TFhirSpecimenTreatmentListEnumerator;
begin
  result := TFhirSpecimenTreatmentListEnumerator.Create(self.link);
end;

function TFhirSpecimenTreatmentList.Clone: TFhirSpecimenTreatmentList;
begin
  result := TFhirSpecimenTreatmentList(inherited Clone);
end;

function TFhirSpecimenTreatmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenTreatmentList.GetItemN(index: Integer): TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(ObjectByIndex[index]);
end;

function TFhirSpecimenTreatmentList.IndexOf(value: TFhirSpecimenTreatment): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSpecimenTreatmentList.Insert(index: Integer): TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenTreatmentList.InsertItem(index: Integer; value: TFhirSpecimenTreatment);
begin
  assert(value is TFhirSpecimenTreatment);
  Inherited Insert(index, value);
end;

function TFhirSpecimenTreatmentList.Item(index: Integer): TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(ObjectByIndex[index]);
end;

function TFhirSpecimenTreatmentList.Link: TFhirSpecimenTreatmentList;
begin
  result := TFhirSpecimenTreatmentList(inherited Link);
end;

procedure TFhirSpecimenTreatmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenTreatmentList.SetItemByIndex(index: Integer; value: TFhirSpecimenTreatment);
begin
  assert(value is TFhirSpecimenTreatment);
  FhirSpecimenTreatments[index] := value;
end;

procedure TFhirSpecimenTreatmentList.SetItemN(index: Integer; value: TFhirSpecimenTreatment);
begin
  assert(value is TFhirSpecimenTreatment);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenContainer }

constructor TFhirSpecimenContainer.Create;
begin
  inherited;
  FIdentifierList := TFhirIdentifierList.Create;
end;

destructor TFhirSpecimenContainer.Destroy;
begin
  FIdentifierList.Free;
  FDescription.free;
  FType_.free;
  FCapacity.free;
  FSpecimenQuantity.free;
  FAdditive.free;
  inherited;
end;

procedure TFhirSpecimenContainer.Assign(oSource : TAdvObject);
begin
  inherited;
  FIdentifierList.Assign(TFhirSpecimenContainer(oSource).FIdentifierList);
  descriptionObject := TFhirSpecimenContainer(oSource).descriptionObject.Clone;
  type_ := TFhirSpecimenContainer(oSource).type_.Clone;
  capacity := TFhirSpecimenContainer(oSource).capacity.Clone;
  specimenQuantity := TFhirSpecimenContainer(oSource).specimenQuantity.Clone;
  additive := TFhirSpecimenContainer(oSource).additive.Clone;
end;

procedure TFhirSpecimenContainer.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.addAll(FIdentifierList);
  if (child_name = 'description') Then
     list.add(FDescription.Link);
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'capacity') Then
     list.add(FCapacity.Link);
  if (child_name = 'specimenQuantity') Then
     list.add(FSpecimenQuantity.Link);
  if (child_name = 'additive') Then
     list.add(FAdditive.Link);
end;

procedure TFhirSpecimenContainer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'capacity', 'Quantity', FCapacity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specimenQuantity', 'Quantity', FSpecimenQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additive', 'Resource(Substance)', FAdditive.Link));{2}
end;

procedure TFhirSpecimenContainer.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierList.add(propValue as TFhirIdentifier){2}
  else if (propName = 'description') then DescriptionObject := propValue as TFhirString{5a}
  else if (propName = 'type') then Type_ := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'capacity') then Capacity := propValue as TFhirQuantity{4b}
  else if (propName = 'specimenQuantity') then SpecimenQuantity := propValue as TFhirQuantity{4b}
  else if (propName = 'additive') then Additive := propValue as TFhirResourceReference{TFhirSubstance}{4b}
  else inherited;
end;

function TFhirSpecimenContainer.FhirType : string;
begin
  result := 'container';
end;

function TFhirSpecimenContainer.Link : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(inherited Link);
end;

function TFhirSpecimenContainer.Clone : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(inherited Clone);
end;

{ TFhirSpecimenContainer }

Procedure TFhirSpecimenContainer.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSpecimenContainer.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirSpecimenContainer.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirSpecimenContainer.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSpecimenContainer.SetCapacity(value : TFhirQuantity);
begin
  FCapacity.free;
  FCapacity := value;
end;

Procedure TFhirSpecimenContainer.SetSpecimenQuantity(value : TFhirQuantity);
begin
  FSpecimenQuantity.free;
  FSpecimenQuantity := value;
end;

Procedure TFhirSpecimenContainer.SetAdditive(value : TFhirResourceReference{TFhirSubstance});
begin
  FAdditive.free;
  FAdditive := value;
end;


{ TFhirSpecimenContainerListEnumerator }

Constructor TFhirSpecimenContainerListEnumerator.Create(list : TFhirSpecimenContainerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirSpecimenContainerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenContainerListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirSpecimenContainerListEnumerator.GetCurrent : TFhirSpecimenContainer;
begin
  Result := FList[FIndex];
end;


{ TFhirSpecimenContainerList }
procedure TFhirSpecimenContainerList.AddItem(value: TFhirSpecimenContainer);
begin
  assert(value.ClassName = 'TFhirSpecimenContainer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenContainer');
  add(value);
end;


function TFhirSpecimenContainerList.Append: TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenContainerList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenContainerList.GetEnumerator : TFhirSpecimenContainerListEnumerator;
begin
  result := TFhirSpecimenContainerListEnumerator.Create(self.link);
end;

function TFhirSpecimenContainerList.Clone: TFhirSpecimenContainerList;
begin
  result := TFhirSpecimenContainerList(inherited Clone);
end;

function TFhirSpecimenContainerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenContainerList.GetItemN(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenContainerList.IndexOf(value: TFhirSpecimenContainer): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSpecimenContainerList.Insert(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSpecimenContainerList.InsertItem(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  Inherited Insert(index, value);
end;

function TFhirSpecimenContainerList.Item(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenContainerList.Link: TFhirSpecimenContainerList;
begin
  result := TFhirSpecimenContainerList(inherited Link);
end;

procedure TFhirSpecimenContainerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenContainerList.SetItemByIndex(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  FhirSpecimenContainers[index] := value;
end;

procedure TFhirSpecimenContainerList.SetItemN(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceInstance }

constructor TFhirSubstanceInstance.Create;
begin
  inherited;
end;

destructor TFhirSubstanceInstance.Destroy;
begin
  FIdentifier.free;
  FExpiry.free;
  FQuantity.free;
  inherited;
end;

procedure TFhirSubstanceInstance.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirSubstanceInstance(oSource).identifier.Clone;
  expiryObject := TFhirSubstanceInstance(oSource).expiryObject.Clone;
  quantity := TFhirSubstanceInstance(oSource).quantity.Clone;
end;

procedure TFhirSubstanceInstance.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(FIdentifier.Link);
  if (child_name = 'expiry') Then
     list.add(FExpiry.Link);
  if (child_name = 'quantity') Then
     list.add(FQuantity.Link);
end;

procedure TFhirSubstanceInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expiry', 'dateTime', FExpiry.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link));{2}
end;

procedure TFhirSubstanceInstance.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'identifier') then Identifier := propValue as TFhirIdentifier{4b}
  else if (propName = 'expiry') then ExpiryObject := propValue as TFhirDateTime{5a}
  else if (propName = 'quantity') then Quantity := propValue as TFhirQuantity{4b}
  else inherited;
end;

function TFhirSubstanceInstance.FhirType : string;
begin
  result := 'instance';
end;

function TFhirSubstanceInstance.Link : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(inherited Link);
end;

function TFhirSubstanceInstance.Clone : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(inherited Clone);
end;

{ TFhirSubstanceInstance }

Procedure TFhirSubstanceInstance.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSubstanceInstance.SetExpiry(value : TFhirDateTime);
begin
  FExpiry.free;
  FExpiry := value;
end;

Function TFhirSubstanceInstance.GetExpiryST : TDateTimeEx;
begin
  if FExpiry = nil then
    result := nil
  else
    result := FExpiry.value;
end;

Procedure TFhirSubstanceInstance.SetExpiryST(value : TDateTimeEx);
begin
  if value <> nil then
  begin
    if FExpiry = nil then
      FExpiry := TFhirDateTime.create;
    FExpiry.value := value
  end
  else if FExpiry <> nil then
    FExpiry.value := nil;
end;

Procedure TFhirSubstanceInstance.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;


{ TFhirSubstanceInstanceListEnumerator }

Constructor TFhirSubstanceInstanceListEnumerator.Create(list : TFhirSubstanceInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirSubstanceInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceInstanceListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirSubstanceInstanceListEnumerator.GetCurrent : TFhirSubstanceInstance;
begin
  Result := FList[FIndex];
end;


{ TFhirSubstanceInstanceList }
procedure TFhirSubstanceInstanceList.AddItem(value: TFhirSubstanceInstance);
begin
  assert(value.ClassName = 'TFhirSubstanceInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceInstance');
  add(value);
end;


function TFhirSubstanceInstanceList.Append: TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSubstanceInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceInstanceList.GetEnumerator : TFhirSubstanceInstanceListEnumerator;
begin
  result := TFhirSubstanceInstanceListEnumerator.Create(self.link);
end;

function TFhirSubstanceInstanceList.Clone: TFhirSubstanceInstanceList;
begin
  result := TFhirSubstanceInstanceList(inherited Clone);
end;

function TFhirSubstanceInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceInstanceList.GetItemN(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(ObjectByIndex[index]);
end;

function TFhirSubstanceInstanceList.IndexOf(value: TFhirSubstanceInstance): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSubstanceInstanceList.Insert(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSubstanceInstanceList.InsertItem(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  Inherited Insert(index, value);
end;

function TFhirSubstanceInstanceList.Item(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(ObjectByIndex[index]);
end;

function TFhirSubstanceInstanceList.Link: TFhirSubstanceInstanceList;
begin
  result := TFhirSubstanceInstanceList(inherited Link);
end;

procedure TFhirSubstanceInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceInstanceList.SetItemByIndex(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  FhirSubstanceInstances[index] := value;
end;

procedure TFhirSubstanceInstanceList.SetItemN(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceIngredient }

constructor TFhirSubstanceIngredient.Create;
begin
  inherited;
end;

destructor TFhirSubstanceIngredient.Destroy;
begin
  FQuantity.free;
  FSubstance.free;
  inherited;
end;

procedure TFhirSubstanceIngredient.Assign(oSource : TAdvObject);
begin
  inherited;
  quantity := TFhirSubstanceIngredient(oSource).quantity.Clone;
  substance := TFhirSubstanceIngredient(oSource).substance.Clone;
end;

procedure TFhirSubstanceIngredient.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(FQuantity.Link);
  if (child_name = 'substance') Then
     list.add(FSubstance.Link);
end;

procedure TFhirSubstanceIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Ratio', FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'substance', 'Resource(Substance)', FSubstance.Link));{2}
end;

procedure TFhirSubstanceIngredient.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'quantity') then Quantity := propValue as TFhirRatio{4b}
  else if (propName = 'substance') then Substance := propValue as TFhirResourceReference{TFhirSubstance}{4b}
  else inherited;
end;

function TFhirSubstanceIngredient.FhirType : string;
begin
  result := 'ingredient';
end;

function TFhirSubstanceIngredient.Link : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(inherited Link);
end;

function TFhirSubstanceIngredient.Clone : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(inherited Clone);
end;

{ TFhirSubstanceIngredient }

Procedure TFhirSubstanceIngredient.SetQuantity(value : TFhirRatio);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSubstanceIngredient.SetSubstance(value : TFhirResourceReference{TFhirSubstance});
begin
  FSubstance.free;
  FSubstance := value;
end;


{ TFhirSubstanceIngredientListEnumerator }

Constructor TFhirSubstanceIngredientListEnumerator.Create(list : TFhirSubstanceIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirSubstanceIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceIngredientListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirSubstanceIngredientListEnumerator.GetCurrent : TFhirSubstanceIngredient;
begin
  Result := FList[FIndex];
end;


{ TFhirSubstanceIngredientList }
procedure TFhirSubstanceIngredientList.AddItem(value: TFhirSubstanceIngredient);
begin
  assert(value.ClassName = 'TFhirSubstanceIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceIngredient');
  add(value);
end;


function TFhirSubstanceIngredientList.Append: TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSubstanceIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceIngredientList.GetEnumerator : TFhirSubstanceIngredientListEnumerator;
begin
  result := TFhirSubstanceIngredientListEnumerator.Create(self.link);
end;

function TFhirSubstanceIngredientList.Clone: TFhirSubstanceIngredientList;
begin
  result := TFhirSubstanceIngredientList(inherited Clone);
end;

function TFhirSubstanceIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceIngredientList.GetItemN(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(ObjectByIndex[index]);
end;

function TFhirSubstanceIngredientList.IndexOf(value: TFhirSubstanceIngredient): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSubstanceIngredientList.Insert(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSubstanceIngredientList.InsertItem(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  Inherited Insert(index, value);
end;

function TFhirSubstanceIngredientList.Item(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(ObjectByIndex[index]);
end;

function TFhirSubstanceIngredientList.Link: TFhirSubstanceIngredientList;
begin
  result := TFhirSubstanceIngredientList(inherited Link);
end;

procedure TFhirSubstanceIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceIngredientList.SetItemByIndex(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  FhirSubstanceIngredients[index] := value;
end;

procedure TFhirSubstanceIngredientList.SetItemN(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirSupplyDispense }

constructor TFhirSupplyDispense.Create;
begin
  inherited;
  FReceiverList := TFhirResourceReferenceList{TFhirPractitioner}.Create;
end;

destructor TFhirSupplyDispense.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FType_.free;
  FQuantity.free;
  FSuppliedItem.free;
  FSupplier.free;
  FWhenPrepared.free;
  FWhenHandedOver.free;
  FDestination.free;
  FReceiverList.Free;
  inherited;
end;

procedure TFhirSupplyDispense.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirSupplyDispense(oSource).identifier.Clone;
  FStatus := TFhirSupplyDispense(oSource).FStatus.Link;
  type_ := TFhirSupplyDispense(oSource).type_.Clone;
  quantity := TFhirSupplyDispense(oSource).quantity.Clone;
  suppliedItem := TFhirSupplyDispense(oSource).suppliedItem.Clone;
  supplier := TFhirSupplyDispense(oSource).supplier.Clone;
  whenPrepared := TFhirSupplyDispense(oSource).whenPrepared.Clone;
  whenHandedOver := TFhirSupplyDispense(oSource).whenHandedOver.Clone;
  destination := TFhirSupplyDispense(oSource).destination.Clone;
  FReceiverList.Assign(TFhirSupplyDispense(oSource).FReceiverList);
end;

procedure TFhirSupplyDispense.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(FStatus.Link);
  if (child_name = 'type') Then
     list.add(FType_.Link);
  if (child_name = 'quantity') Then
     list.add(FQuantity.Link);
  if (child_name = 'suppliedItem') Then
     list.add(FSuppliedItem.Link);
  if (child_name = 'supplier') Then
     list.add(FSupplier.Link);
  if (child_name = 'whenPrepared') Then
     list.add(FWhenPrepared.Link);
  if (child_name = 'whenHandedOver') Then
     list.add(FWhenHandedOver.Link);
  if (child_name = 'destination') Then
     list.add(FDestination.Link);
  if (child_name = 'receiver') Then
     list.addAll(FReceiverList);
end;

procedure TFhirSupplyDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'suppliedItem', 'Resource(Medication|Substance|Device)', FSuppliedItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supplier', 'Resource(Practitioner)', FSupplier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenPrepared', 'Period', FWhenPrepared.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenHandedOver', 'Period', FWhenHandedOver.Link));{2}
  oList.add(TFHIRProperty.create(self, 'destination', 'Resource(Location)', FDestination.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receiver', 'Resource(Practitioner)', FReceiverList.Link)){3};
end;

procedure TFhirSupplyDispense.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'identifier') then Identifier := propValue as TFhirIdentifier{4b}
  else if (propName = 'status') then StatusObject := propValue as TFHIREnum
  else if (propName = 'type') then Type_ := propValue as TFhirCodeableConcept{4b}
  else if (propName = 'quantity') then Quantity := propValue as TFhirQuantity{4b}
  else if (propName = 'suppliedItem') then SuppliedItem := propValue as TFhirResourceReference{Resource}{4b}
  else if (propName = 'supplier') then Supplier := propValue as TFhirResourceReference{TFhirPractitioner}{4b}
  else if (propName = 'whenPrepared') then WhenPrepared := propValue as TFhirPeriod{4b}
  else if (propName = 'whenHandedOver') then WhenHandedOver := propValue as TFhirPeriod{4b}
  else if (propName = 'destination') then Destination := propValue as TFhirResourceReference{TFhirLocation}{4b}
  else if (propName = 'receiver') then ReceiverList.add(propValue as TFhirResourceReference{TFhirPractitioner}){2}
  else inherited;
end;

function TFhirSupplyDispense.FhirType : string;
begin
  result := 'dispense';
end;

function TFhirSupplyDispense.Link : TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense(inherited Link);
end;

function TFhirSupplyDispense.Clone : TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense(inherited Clone);
end;

{ TFhirSupplyDispense }

Procedure TFhirSupplyDispense.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSupplyDispense.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSupplyDispense.GetStatusST : TFhirValuesetSupplyDispenseStatus;
begin
  if FStatus = nil then
    result := TFhirValuesetSupplyDispenseStatus(0)
  else
    result := TFhirValuesetSupplyDispenseStatus(StringArrayIndexOfSensitive(CODES_TFhirValuesetSupplyDispenseStatus, FStatus.value));
end;

Procedure TFhirSupplyDispense.SetStatusST(value : TFhirValuesetSupplyDispenseStatus);
begin
  if ord(value) = 0 then
    StatusObject := nil
  else
    StatusObject := TFhirEnum.create(CODES_TFhirValuesetSupplyDispenseStatus[value]);
end;

Procedure TFhirSupplyDispense.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSupplyDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSupplyDispense.SetSuppliedItem(value : TFhirResourceReference{Resource});
begin
  FSuppliedItem.free;
  FSuppliedItem := value;
end;

Procedure TFhirSupplyDispense.SetSupplier(value : TFhirResourceReference{TFhirPractitioner});
begin
  FSupplier.free;
  FSupplier := value;
end;

Procedure TFhirSupplyDispense.SetWhenPrepared(value : TFhirPeriod);
begin
  FWhenPrepared.free;
  FWhenPrepared := value;
end;

Procedure TFhirSupplyDispense.SetWhenHandedOver(value : TFhirPeriod);
begin
  FWhenHandedOver.free;
  FWhenHandedOver := value;
end;

Procedure TFhirSupplyDispense.SetDestination(value : TFhirResourceReference{TFhirLocation});
begin
  FDestination.free;
  FDestination := value;
end;


{ TFhirSupplyDispenseListEnumerator }

Constructor TFhirSupplyDispenseListEnumerator.Create(list : TFhirSupplyDispenseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirSupplyDispenseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyDispenseListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirSupplyDispenseListEnumerator.GetCurrent : TFhirSupplyDispense;
begin
  Result := FList[FIndex];
end;


{ TFhirSupplyDispenseList }
procedure TFhirSupplyDispenseList.AddItem(value: TFhirSupplyDispense);
begin
  assert(value.ClassName = 'TFhirSupplyDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyDispense');
  add(value);
end;


function TFhirSupplyDispenseList.Append: TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirSupplyDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyDispenseList.GetEnumerator : TFhirSupplyDispenseListEnumerator;
begin
  result := TFhirSupplyDispenseListEnumerator.Create(self.link);
end;

function TFhirSupplyDispenseList.Clone: TFhirSupplyDispenseList;
begin
  result := TFhirSupplyDispenseList(inherited Clone);
end;

function TFhirSupplyDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyDispenseList.GetItemN(index: Integer): TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense(ObjectByIndex[index]);
end;

function TFhirSupplyDispenseList.IndexOf(value: TFhirSupplyDispense): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirSupplyDispenseList.Insert(index: Integer): TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirSupplyDispenseList.InsertItem(index: Integer; value: TFhirSupplyDispense);
begin
  assert(value is TFhirSupplyDispense);
  Inherited Insert(index, value);
end;

function TFhirSupplyDispenseList.Item(index: Integer): TFhirSupplyDispense;
begin
  result := TFhirSupplyDispense(ObjectByIndex[index]);
end;

function TFhirSupplyDispenseList.Link: TFhirSupplyDispenseList;
begin
  result := TFhirSupplyDispenseList(inherited Link);
end;

procedure TFhirSupplyDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyDispenseList.SetItemByIndex(index: Integer; value: TFhirSupplyDispense);
begin
  assert(value is TFhirSupplyDispense);
  FhirSupplyDispenses[index] := value;
end;

procedure TFhirSupplyDispenseList.SetItemN(index: Integer; value: TFhirSupplyDispense);
begin
  assert(value is TFhirSupplyDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetDefine }

constructor TFhirValueSetDefine.Create;
begin
  inherited;
  FConceptList := TFhirValueSetDefineConceptList.Create;
end;

destructor TFhirValueSetDefine.Destroy;
begin
  FSystem.free;
  FVersion.free;
  FCaseSensitive.free;
  FConceptList.Free;
  inherited;
end;

procedure TFhirValueSetDefine.Assign(oSource : TAdvObject);
begin
  inherited;
  systemObject := TFhirValueSetDefine(oSource).systemObject.Clone;
  versionObject := TFhirValueSetDefine(oSource).versionObject.Clone;
  caseSensitiveObject := TFhirValueSetDefine(oSource).caseSensitiveObject.Clone;
  FConceptList.Assign(TFhirValueSetDefine(oSource).FConceptList);
end;

procedure TFhirValueSetDefine.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(FSystem.Link);
  if (child_name = 'version') Then
     list.add(FVersion.Link);
  if (child_name = 'caseSensitive') Then
     list.add(FCaseSensitive.Link);
  if (child_name = 'concept') Then
     list.addAll(FConceptList);
end;

procedure TFhirValueSetDefine.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'caseSensitive', 'boolean', FCaseSensitive.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concept', '', FConceptList.Link)){3};
end;

procedure TFhirValueSetDefine.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'system') then SystemObject := propValue as TFhirUri{5a}
  else if (propName = 'version') then VersionObject := propValue as TFhirString{5a}
  else if (propName = 'caseSensitive') then CaseSensitiveObject := propValue as TFhirBoolean{5a}
  else if (propName = 'concept') then ConceptList.add(propValue as TFhirValueSetDefineConcept){2}
  else inherited;
end;

function TFhirValueSetDefine.FhirType : string;
begin
  result := 'define';
end;

function TFhirValueSetDefine.Link : TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine(inherited Link);
end;

function TFhirValueSetDefine.Clone : TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine(inherited Clone);
end;

{ TFhirValueSetDefine }

Procedure TFhirValueSetDefine.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirValueSetDefine.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirValueSetDefine.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirValueSetDefine.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirValueSetDefine.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirValueSetDefine.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirValueSetDefine.SetCaseSensitive(value : TFhirBoolean);
begin
  FCaseSensitive.free;
  FCaseSensitive := value;
end;

Function TFhirValueSetDefine.GetCaseSensitiveST : Boolean;
begin
  if FCaseSensitive = nil then
    result := false
  else
    result := FCaseSensitive.value;
end;

Procedure TFhirValueSetDefine.SetCaseSensitiveST(value : Boolean);
begin
  if FCaseSensitive = nil then
    FCaseSensitive := TFhirBoolean.create;
  FCaseSensitive.value := value
end;


{ TFhirValueSetDefineListEnumerator }

Constructor TFhirValueSetDefineListEnumerator.Create(list : TFhirValueSetDefineList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirValueSetDefineListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetDefineListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirValueSetDefineListEnumerator.GetCurrent : TFhirValueSetDefine;
begin
  Result := FList[FIndex];
end;


{ TFhirValueSetDefineList }
procedure TFhirValueSetDefineList.AddItem(value: TFhirValueSetDefine);
begin
  assert(value.ClassName = 'TFhirValueSetDefine', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetDefine');
  add(value);
end;


function TFhirValueSetDefineList.Append: TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetDefineList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetDefineList.GetEnumerator : TFhirValueSetDefineListEnumerator;
begin
  result := TFhirValueSetDefineListEnumerator.Create(self.link);
end;

function TFhirValueSetDefineList.Clone: TFhirValueSetDefineList;
begin
  result := TFhirValueSetDefineList(inherited Clone);
end;

function TFhirValueSetDefineList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetDefineList.GetItemN(index: Integer): TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine(ObjectByIndex[index]);
end;

function TFhirValueSetDefineList.IndexOf(value: TFhirValueSetDefine): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetDefineList.Insert(index: Integer): TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetDefineList.InsertItem(index: Integer; value: TFhirValueSetDefine);
begin
  assert(value is TFhirValueSetDefine);
  Inherited Insert(index, value);
end;

function TFhirValueSetDefineList.Item(index: Integer): TFhirValueSetDefine;
begin
  result := TFhirValueSetDefine(ObjectByIndex[index]);
end;

function TFhirValueSetDefineList.Link: TFhirValueSetDefineList;
begin
  result := TFhirValueSetDefineList(inherited Link);
end;

procedure TFhirValueSetDefineList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetDefineList.SetItemByIndex(index: Integer; value: TFhirValueSetDefine);
begin
  assert(value is TFhirValueSetDefine);
  FhirValueSetDefines[index] := value;
end;

procedure TFhirValueSetDefineList.SetItemN(index: Integer; value: TFhirValueSetDefine);
begin
  assert(value is TFhirValueSetDefine);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetDefineConcept }

constructor TFhirValueSetDefineConcept.Create;
begin
  inherited;
  FConceptList := TFhirValueSetDefineConceptList.Create;
end;

destructor TFhirValueSetDefineConcept.Destroy;
begin
  FCode.free;
  FAbstract.free;
  FDisplay.free;
  FDefinition.free;
  FConceptList.Free;
  inherited;
end;

procedure TFhirValueSetDefineConcept.Assign(oSource : TAdvObject);
begin
  inherited;
  codeObject := TFhirValueSetDefineConcept(oSource).codeObject.Clone;
  abstractObject := TFhirValueSetDefineConcept(oSource).abstractObject.Clone;
  displayObject := TFhirValueSetDefineConcept(oSource).displayObject.Clone;
  definitionObject := TFhirValueSetDefineConcept(oSource).definitionObject.Clone;
  FConceptList.Assign(TFhirValueSetDefineConcept(oSource).FConceptList);
end;

procedure TFhirValueSetDefineConcept.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'abstract') Then
     list.add(FAbstract.Link);
  if (child_name = 'display') Then
     list.add(FDisplay.Link);
  if (child_name = 'definition') Then
     list.add(FDefinition.Link);
  if (child_name = 'concept') Then
     list.addAll(FConceptList);
end;

procedure TFhirValueSetDefineConcept.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'abstract', 'boolean', FAbstract.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'string', FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concept', '@ValueSet.define.concept', FConceptList.Link)){3};
end;

procedure TFhirValueSetDefineConcept.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'code') then
    if propValue is TFHIRCode then
      CodeObject := propValue as TFhirCode{5}
    else if propValue is TFHIREnum then
      CodeObject := TFHIRCode.create(TFHIREnum(propValue).value)
    else
      raise Exception.Create('Type mismatch: cannot convert from "'+propValue.className+'" to "TFHIRCode"'){5a}
  else if (propName = 'abstract') then AbstractObject := propValue as TFhirBoolean{5a}
  else if (propName = 'display') then DisplayObject := propValue as TFhirString{5a}
  else if (propName = 'definition') then DefinitionObject := propValue as TFhirString{5a}
  else if (propName = 'concept') then ConceptList.add(propValue as TFhirValueSetDefineConcept){2}
  else inherited;
end;

function TFhirValueSetDefineConcept.FhirType : string;
begin
  result := 'concept';
end;

function TFhirValueSetDefineConcept.Link : TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept(inherited Link);
end;

function TFhirValueSetDefineConcept.Clone : TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept(inherited Clone);
end;

{ TFhirValueSetDefineConcept }

Procedure TFhirValueSetDefineConcept.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirValueSetDefineConcept.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirValueSetDefineConcept.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirValueSetDefineConcept.SetAbstract(value : TFhirBoolean);
begin
  FAbstract.free;
  FAbstract := value;
end;

Function TFhirValueSetDefineConcept.GetAbstractST : Boolean;
begin
  if FAbstract = nil then
    result := false
  else
    result := FAbstract.value;
end;

Procedure TFhirValueSetDefineConcept.SetAbstractST(value : Boolean);
begin
  if FAbstract = nil then
    FAbstract := TFhirBoolean.create;
  FAbstract.value := value
end;

Procedure TFhirValueSetDefineConcept.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirValueSetDefineConcept.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirValueSetDefineConcept.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirValueSetDefineConcept.SetDefinition(value : TFhirString);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirValueSetDefineConcept.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

Procedure TFhirValueSetDefineConcept.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirString.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;


{ TFhirValueSetDefineConceptListEnumerator }

Constructor TFhirValueSetDefineConceptListEnumerator.Create(list : TFhirValueSetDefineConceptList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirValueSetDefineConceptListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetDefineConceptListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirValueSetDefineConceptListEnumerator.GetCurrent : TFhirValueSetDefineConcept;
begin
  Result := FList[FIndex];
end;


{ TFhirValueSetDefineConceptList }
procedure TFhirValueSetDefineConceptList.AddItem(value: TFhirValueSetDefineConcept);
begin
  assert(value.ClassName = 'TFhirValueSetDefineConcept', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetDefineConcept');
  add(value);
end;


function TFhirValueSetDefineConceptList.Append: TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetDefineConceptList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetDefineConceptList.GetEnumerator : TFhirValueSetDefineConceptListEnumerator;
begin
  result := TFhirValueSetDefineConceptListEnumerator.Create(self.link);
end;

function TFhirValueSetDefineConceptList.Clone: TFhirValueSetDefineConceptList;
begin
  result := TFhirValueSetDefineConceptList(inherited Clone);
end;

function TFhirValueSetDefineConceptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetDefineConceptList.GetItemN(index: Integer): TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept(ObjectByIndex[index]);
end;

function TFhirValueSetDefineConceptList.IndexOf(value: TFhirValueSetDefineConcept): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetDefineConceptList.Insert(index: Integer): TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetDefineConceptList.InsertItem(index: Integer; value: TFhirValueSetDefineConcept);
begin
  assert(value is TFhirValueSetDefineConcept);
  Inherited Insert(index, value);
end;

function TFhirValueSetDefineConceptList.Item(index: Integer): TFhirValueSetDefineConcept;
begin
  result := TFhirValueSetDefineConcept(ObjectByIndex[index]);
end;

function TFhirValueSetDefineConceptList.Link: TFhirValueSetDefineConceptList;
begin
  result := TFhirValueSetDefineConceptList(inherited Link);
end;

procedure TFhirValueSetDefineConceptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetDefineConceptList.SetItemByIndex(index: Integer; value: TFhirValueSetDefineConcept);
begin
  assert(value is TFhirValueSetDefineConcept);
  FhirValueSetDefineConcepts[index] := value;
end;

procedure TFhirValueSetDefineConceptList.SetItemN(index: Integer; value: TFhirValueSetDefineConcept);
begin
  assert(value is TFhirValueSetDefineConcept);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetCompose }

constructor TFhirValueSetCompose.Create;
begin
  inherited;
  FImportList := TFhirUriList.Create;
  FIncludeList := TFhirValueSetComposeIncludeList.Create;
  FExcludeList := TFhirValueSetComposeIncludeList.Create;
end;

destructor TFhirValueSetCompose.Destroy;
begin
  FImportList.Free;
  FIncludeList.Free;
  FExcludeList.Free;
  inherited;
end;

procedure TFhirValueSetCompose.Assign(oSource : TAdvObject);
begin
  inherited;
  FImportList.Assign(TFhirValueSetCompose(oSource).FImportList);
  FIncludeList.Assign(TFhirValueSetCompose(oSource).FIncludeList);
  FExcludeList.Assign(TFhirValueSetCompose(oSource).FExcludeList);
end;

procedure TFhirValueSetCompose.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'import') Then
     list.addAll(FImportList);
  if (child_name = 'include') Then
     list.addAll(FIncludeList);
  if (child_name = 'exclude') Then
     list.addAll(FExcludeList);
end;

procedure TFhirValueSetCompose.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'import', 'uri', FImportList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'include', '', FIncludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'exclude', '@ValueSet.compose.include', FExcludeList.Link)){3};
end;

procedure TFhirValueSetCompose.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'import') then ImportList.add(propValue as TFhirUri){2}
  else if (propName = 'include') then IncludeList.add(propValue as TFhirValueSetComposeInclude){2}
  else if (propName = 'exclude') then ExcludeList.add(propValue as TFhirValueSetComposeInclude){2}
  else inherited;
end;

function TFhirValueSetCompose.FhirType : string;
begin
  result := 'compose';
end;

function TFhirValueSetCompose.Link : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(inherited Link);
end;

function TFhirValueSetCompose.Clone : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(inherited Clone);
end;

{ TFhirValueSetCompose }


{ TFhirValueSetComposeListEnumerator }

Constructor TFhirValueSetComposeListEnumerator.Create(list : TFhirValueSetComposeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirValueSetComposeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirValueSetComposeListEnumerator.GetCurrent : TFhirValueSetCompose;
begin
  Result := FList[FIndex];
end;


{ TFhirValueSetComposeList }
procedure TFhirValueSetComposeList.AddItem(value: TFhirValueSetCompose);
begin
  assert(value.ClassName = 'TFhirValueSetCompose', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetCompose');
  add(value);
end;


function TFhirValueSetComposeList.Append: TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeList.GetEnumerator : TFhirValueSetComposeListEnumerator;
begin
  result := TFhirValueSetComposeListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeList.Clone: TFhirValueSetComposeList;
begin
  result := TFhirValueSetComposeList(inherited Clone);
end;

function TFhirValueSetComposeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeList.GetItemN(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(ObjectByIndex[index]);
end;

function TFhirValueSetComposeList.IndexOf(value: TFhirValueSetCompose): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetComposeList.Insert(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeList.InsertItem(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeList.Item(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(ObjectByIndex[index]);
end;

function TFhirValueSetComposeList.Link: TFhirValueSetComposeList;
begin
  result := TFhirValueSetComposeList(inherited Link);
end;

procedure TFhirValueSetComposeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeList.SetItemByIndex(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  FhirValueSetComposes[index] := value;
end;

procedure TFhirValueSetComposeList.SetItemN(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeInclude }

constructor TFhirValueSetComposeInclude.Create;
begin
  inherited;
  FCodeList := TFhirCodeList.Create;
  FFilterList := TFhirValueSetComposeIncludeFilterList.Create;
end;

destructor TFhirValueSetComposeInclude.Destroy;
begin
  FSystem.free;
  FVersion.free;
  FCodeList.Free;
  FFilterList.Free;
  inherited;
end;

procedure TFhirValueSetComposeInclude.Assign(oSource : TAdvObject);
begin
  inherited;
  systemObject := TFhirValueSetComposeInclude(oSource).systemObject.Clone;
  versionObject := TFhirValueSetComposeInclude(oSource).versionObject.Clone;
  FCodeList.Assign(TFhirValueSetComposeInclude(oSource).FCodeList);
  FFilterList.Assign(TFhirValueSetComposeInclude(oSource).FFilterList);
end;

procedure TFhirValueSetComposeInclude.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(FSystem.Link);
  if (child_name = 'version') Then
     list.add(FVersion.Link);
  if (child_name = 'code') Then
     list.addAll(FCodeList);
  if (child_name = 'filter') Then
     list.addAll(FFilterList);
end;

procedure TFhirValueSetComposeInclude.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'filter', '', FFilterList.Link)){3};
end;

procedure TFhirValueSetComposeInclude.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'system') then SystemObject := propValue as TFhirUri{5a}
  else if (propName = 'version') then VersionObject := propValue as TFhirString{5a}
  else if (propName = 'code') then CodeList.add(propValue as TFhirCode){2}
  else if (propName = 'filter') then FilterList.add(propValue as TFhirValueSetComposeIncludeFilter){2}
  else inherited;
end;

function TFhirValueSetComposeInclude.FhirType : string;
begin
  result := 'include';
end;

function TFhirValueSetComposeInclude.Link : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(inherited Link);
end;

function TFhirValueSetComposeInclude.Clone : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(inherited Clone);
end;

{ TFhirValueSetComposeInclude }

Procedure TFhirValueSetComposeInclude.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirValueSetComposeInclude.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirValueSetComposeInclude.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirValueSetComposeInclude.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirValueSetComposeInclude.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirValueSetComposeInclude.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;


{ TFhirValueSetComposeIncludeListEnumerator }

Constructor TFhirValueSetComposeIncludeListEnumerator.Create(list : TFhirValueSetComposeIncludeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirValueSetComposeIncludeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeIncludeListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirValueSetComposeIncludeListEnumerator.GetCurrent : TFhirValueSetComposeInclude;
begin
  Result := FList[FIndex];
end;


{ TFhirValueSetComposeIncludeList }
procedure TFhirValueSetComposeIncludeList.AddItem(value: TFhirValueSetComposeInclude);
begin
  assert(value.ClassName = 'TFhirValueSetComposeInclude', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeInclude');
  add(value);
end;


function TFhirValueSetComposeIncludeList.Append: TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeIncludeList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeList.GetEnumerator : TFhirValueSetComposeIncludeListEnumerator;
begin
  result := TFhirValueSetComposeIncludeListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeIncludeList.Clone: TFhirValueSetComposeIncludeList;
begin
  result := TFhirValueSetComposeIncludeList(inherited Clone);
end;

function TFhirValueSetComposeIncludeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeList.GetItemN(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeList.IndexOf(value: TFhirValueSetComposeInclude): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetComposeIncludeList.Insert(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeIncludeList.InsertItem(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeList.Item(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeList.Link: TFhirValueSetComposeIncludeList;
begin
  result := TFhirValueSetComposeIncludeList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  FhirValueSetComposeIncludes[index] := value;
end;

procedure TFhirValueSetComposeIncludeList.SetItemN(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeIncludeFilter }

constructor TFhirValueSetComposeIncludeFilter.Create;
begin
  inherited;
end;

destructor TFhirValueSetComposeIncludeFilter.Destroy;
begin
  FProperty_.free;
  FOp.free;
  FValue.free;
  inherited;
end;

procedure TFhirValueSetComposeIncludeFilter.Assign(oSource : TAdvObject);
begin
  inherited;
  property_Object := TFhirValueSetComposeIncludeFilter(oSource).property_Object.Clone;
  FOp := TFhirValueSetComposeIncludeFilter(oSource).FOp.Link;
  valueObject := TFhirValueSetComposeIncludeFilter(oSource).valueObject.Clone;
end;

procedure TFhirValueSetComposeIncludeFilter.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'property') Then
     list.add(FProperty_.Link);
  if (child_name = 'op') Then
     list.add(FOp.Link);
  if (child_name = 'value') Then
     list.add(FValue.Link);
end;

procedure TFhirValueSetComposeIncludeFilter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'property', 'code', FProperty_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'op', 'code', FOp.Link));{1}
  oList.add(TFHIRProperty.create(self, 'value', 'code', FValue.Link));{2}
end;

procedure TFhirValueSetComposeIncludeFilter.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'property') then
    if propValue is TFHIRCode then
      Property_Object := propValue as TFhirCode{5}
    else if propValue is TFHIREnum then
      Property_Object := TFHIRCode.create(TFHIREnum(propValue).value)
    else
      raise Exception.Create('Type mismatch: cannot convert from "'+propValue.className+'" to "TFHIRCode"'){5a}
  else if (propName = 'op') then OpObject := propValue as TFHIREnum
  else if (propName = 'value') then
    if propValue is TFHIRCode then
      ValueObject := propValue as TFhirCode{5}
    else if propValue is TFHIREnum then
      ValueObject := TFHIRCode.create(TFHIREnum(propValue).value)
    else
      raise Exception.Create('Type mismatch: cannot convert from "'+propValue.className+'" to "TFHIRCode"'){5a}
  else inherited;
end;

function TFhirValueSetComposeIncludeFilter.FhirType : string;
begin
  result := 'filter';
end;

function TFhirValueSetComposeIncludeFilter.Link : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(inherited Link);
end;

function TFhirValueSetComposeIncludeFilter.Clone : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(inherited Clone);
end;

{ TFhirValueSetComposeIncludeFilter }

Procedure TFhirValueSetComposeIncludeFilter.SetProperty_(value : TFhirCode);
begin
  FProperty_.free;
  FProperty_ := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetProperty_ST : String;
begin
  if FProperty_ = nil then
    result := ''
  else
    result := FProperty_.value;
end;

Procedure TFhirValueSetComposeIncludeFilter.SetProperty_ST(value : String);
begin
  if value <> '' then
  begin
    if FProperty_ = nil then
      FProperty_ := TFhirCode.create;
    FProperty_.value := value
  end
  else if FProperty_ <> nil then
    FProperty_.value := '';
end;

Procedure TFhirValueSetComposeIncludeFilter.SetOp(value : TFhirEnum);
begin
  FOp.free;
  FOp := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetOpST : TFhirFilterOperator;
begin
  if FOp = nil then
    result := TFhirFilterOperator(0)
  else
    result := TFhirFilterOperator(StringArrayIndexOfSensitive(CODES_TFhirFilterOperator, FOp.value));
end;

Procedure TFhirValueSetComposeIncludeFilter.SetOpST(value : TFhirFilterOperator);
begin
  if ord(value) = 0 then
    OpObject := nil
  else
    OpObject := TFhirEnum.create(CODES_TFhirFilterOperator[value]);
end;

Procedure TFhirValueSetComposeIncludeFilter.SetValue(value : TFhirCode);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirValueSetComposeIncludeFilter.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirCode.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;


{ TFhirValueSetComposeIncludeFilterListEnumerator }

Constructor TFhirValueSetComposeIncludeFilterListEnumerator.Create(list : TFhirValueSetComposeIncludeFilterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirValueSetComposeIncludeFilterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeIncludeFilterListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirValueSetComposeIncludeFilterListEnumerator.GetCurrent : TFhirValueSetComposeIncludeFilter;
begin
  Result := FList[FIndex];
end;


{ TFhirValueSetComposeIncludeFilterList }
procedure TFhirValueSetComposeIncludeFilterList.AddItem(value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value.ClassName = 'TFhirValueSetComposeIncludeFilter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeIncludeFilter');
  add(value);
end;


function TFhirValueSetComposeIncludeFilterList.Append: TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeIncludeFilterList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeFilterList.GetEnumerator : TFhirValueSetComposeIncludeFilterListEnumerator;
begin
  result := TFhirValueSetComposeIncludeFilterListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeIncludeFilterList.Clone: TFhirValueSetComposeIncludeFilterList;
begin
  result := TFhirValueSetComposeIncludeFilterList(inherited Clone);
end;

function TFhirValueSetComposeIncludeFilterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeFilterList.GetItemN(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeFilterList.IndexOf(value: TFhirValueSetComposeIncludeFilter): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetComposeIncludeFilterList.Insert(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetComposeIncludeFilterList.InsertItem(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeFilterList.Item(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeFilterList.Link: TFhirValueSetComposeIncludeFilterList;
begin
  result := TFhirValueSetComposeIncludeFilterList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeFilterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeFilterList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  FhirValueSetComposeIncludeFilters[index] := value;
end;

procedure TFhirValueSetComposeIncludeFilterList.SetItemN(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansion }

constructor TFhirValueSetExpansion.Create;
begin
  inherited;
  FContainsList := TFhirValueSetExpansionContainsList.Create;
end;

destructor TFhirValueSetExpansion.Destroy;
begin
  FIdentifier.free;
  FTimestamp.free;
  FContainsList.Free;
  inherited;
end;

procedure TFhirValueSetExpansion.Assign(oSource : TAdvObject);
begin
  inherited;
  identifier := TFhirValueSetExpansion(oSource).identifier.Clone;
  timestampObject := TFhirValueSetExpansion(oSource).timestampObject.Clone;
  FContainsList.Assign(TFhirValueSetExpansion(oSource).FContainsList);
end;

procedure TFhirValueSetExpansion.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(FIdentifier.Link);
  if (child_name = 'timestamp') Then
     list.add(FTimestamp.Link);
  if (child_name = 'contains') Then
     list.addAll(FContainsList);
end;

procedure TFhirValueSetExpansion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timestamp', 'instant', FTimestamp.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contains', '', FContainsList.Link)){3};
end;

procedure TFhirValueSetExpansion.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'identifier') then Identifier := propValue as TFhirIdentifier{4b}
  else if (propName = 'timestamp') then TimestampObject := propValue as TFhirInstant{5a}
  else if (propName = 'contains') then ContainsList.add(propValue as TFhirValueSetExpansionContains){2}
  else inherited;
end;

function TFhirValueSetExpansion.FhirType : string;
begin
  result := 'expansion';
end;

function TFhirValueSetExpansion.Link : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(inherited Link);
end;

function TFhirValueSetExpansion.Clone : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(inherited Clone);
end;

{ TFhirValueSetExpansion }

Procedure TFhirValueSetExpansion.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirValueSetExpansion.SetTimestamp(value : TFhirInstant);
begin
  FTimestamp.free;
  FTimestamp := value;
end;

Function TFhirValueSetExpansion.GetTimestampST : TDateTimeEx;
begin
  if FTimestamp = nil then
    result := nil
  else
    result := FTimestamp.value;
end;

Procedure TFhirValueSetExpansion.SetTimestampST(value : TDateTimeEx);
begin
  if value <> nil then
  begin
    if FTimestamp = nil then
      FTimestamp := TFhirInstant.create;
    FTimestamp.value := value
  end
  else if FTimestamp <> nil then
    FTimestamp.value := nil;
end;


{ TFhirValueSetExpansionListEnumerator }

Constructor TFhirValueSetExpansionListEnumerator.Create(list : TFhirValueSetExpansionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirValueSetExpansionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetExpansionListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirValueSetExpansionListEnumerator.GetCurrent : TFhirValueSetExpansion;
begin
  Result := FList[FIndex];
end;


{ TFhirValueSetExpansionList }
procedure TFhirValueSetExpansionList.AddItem(value: TFhirValueSetExpansion);
begin
  assert(value.ClassName = 'TFhirValueSetExpansion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansion');
  add(value);
end;


function TFhirValueSetExpansionList.Append: TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetExpansionList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionList.GetEnumerator : TFhirValueSetExpansionListEnumerator;
begin
  result := TFhirValueSetExpansionListEnumerator.Create(self.link);
end;

function TFhirValueSetExpansionList.Clone: TFhirValueSetExpansionList;
begin
  result := TFhirValueSetExpansionList(inherited Clone);
end;

function TFhirValueSetExpansionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionList.GetItemN(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionList.IndexOf(value: TFhirValueSetExpansion): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetExpansionList.Insert(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetExpansionList.InsertItem(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionList.Item(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionList.Link: TFhirValueSetExpansionList;
begin
  result := TFhirValueSetExpansionList(inherited Link);
end;

procedure TFhirValueSetExpansionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  FhirValueSetExpansions[index] := value;
end;

procedure TFhirValueSetExpansionList.SetItemN(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansionContains }

constructor TFhirValueSetExpansionContains.Create;
begin
  inherited;
  FContainsList := TFhirValueSetExpansionContainsList.Create;
end;

destructor TFhirValueSetExpansionContains.Destroy;
begin
  FSystem.free;
  FCode.free;
  FDisplay.free;
  FContainsList.Free;
  inherited;
end;

procedure TFhirValueSetExpansionContains.Assign(oSource : TAdvObject);
begin
  inherited;
  systemObject := TFhirValueSetExpansionContains(oSource).systemObject.Clone;
  codeObject := TFhirValueSetExpansionContains(oSource).codeObject.Clone;
  displayObject := TFhirValueSetExpansionContains(oSource).displayObject.Clone;
  FContainsList.Assign(TFhirValueSetExpansionContains(oSource).FContainsList);
end;

procedure TFhirValueSetExpansionContains.GetChildrenByName(child_name : string; list : TFHIRObjectList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(FSystem.Link);
  if (child_name = 'code') Then
     list.add(FCode.Link);
  if (child_name = 'display') Then
     list.add(FDisplay.Link);
  if (child_name = 'contains') Then
     list.addAll(FContainsList);
end;

procedure TFhirValueSetExpansionContains.ListProperties(oList: TFHIRPropertyList; bInheritedProperties: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contains', '@ValueSet.expansion.contains', FContainsList.Link)){3};
end;

procedure TFhirValueSetExpansionContains.setProperty(propName : string; propValue: TFHIRObject);
begin
  if (propName = 'system') then SystemObject := propValue as TFhirUri{5a}
  else if (propName = 'code') then
    if propValue is TFHIRCode then
      CodeObject := propValue as TFhirCode{5}
    else if propValue is TFHIREnum then
      CodeObject := TFHIRCode.create(TFHIREnum(propValue).value)
    else
      raise Exception.Create('Type mismatch: cannot convert from "'+propValue.className+'" to "TFHIRCode"'){5a}
  else if (propName = 'display') then DisplayObject := propValue as TFhirString{5a}
  else if (propName = 'contains') then ContainsList.add(propValue as TFhirValueSetExpansionContains){2}
  else inherited;
end;

function TFhirValueSetExpansionContains.FhirType : string;
begin
  result := 'contains';
end;

function TFhirValueSetExpansionContains.Link : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(inherited Link);
end;

function TFhirValueSetExpansionContains.Clone : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(inherited Clone);
end;

{ TFhirValueSetExpansionContains }

Procedure TFhirValueSetExpansionContains.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirValueSetExpansionContains.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirValueSetExpansionContains.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirValueSetExpansionContains.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirValueSetExpansionContains.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirValueSetExpansionContains.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirValueSetExpansionContains.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirValueSetExpansionContains.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirValueSetExpansionContains.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;


{ TFhirValueSetExpansionContainsListEnumerator }

Constructor TFhirValueSetExpansionContainsListEnumerator.Create(list : TFhirValueSetExpansionContainsList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

Destructor TFhirValueSetExpansionContainsListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetExpansionContainsListEnumerator.MoveNext : boolean;
begin
  Result := FIndex < FList.count;
  if Result then
    Inc(FIndex);
end;

function TFhirValueSetExpansionContainsListEnumerator.GetCurrent : TFhirValueSetExpansionContains;
begin
  Result := FList[FIndex];
end;


{ TFhirValueSetExpansionContainsList }
procedure TFhirValueSetExpansionContainsList.AddItem(value: TFhirValueSetExpansionContains);
begin
  assert(value.ClassName = 'TFhirValueSetExpansionContains', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansionContains');
  add(value);
end;


function TFhirValueSetExpansionContainsList.Append: TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetExpansionContainsList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionContainsList.GetEnumerator : TFhirValueSetExpansionContainsListEnumerator;
begin
  result := TFhirValueSetExpansionContainsListEnumerator.Create(self.link);
end;

function TFhirValueSetExpansionContainsList.Clone: TFhirValueSetExpansionContainsList;
begin
  result := TFhirValueSetExpansionContainsList(inherited Clone);
end;

function TFhirValueSetExpansionContainsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionContainsList.GetItemN(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionContainsList.IndexOf(value: TFhirValueSetExpansionContains): Integer;
begin
  result := IndexByReference(value);
end;


function TFhirValueSetExpansionContainsList.Insert(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    inherited insert(index, result);
  finally
    result.free;
  end;
end;


procedure TFhirValueSetExpansionContainsList.InsertItem(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionContainsList.Item(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionContainsList.Link: TFhirValueSetExpansionContainsList;
begin
  result := TFhirValueSetExpansionContainsList(inherited Link);
end;

procedure TFhirValueSetExpansionContainsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionContainsList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  FhirValueSetExpansionContains[index] := value;
end;

procedure TFhirValueSetExpansionContainsList.SetItemN(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  ObjectByIndex[index] := value;
end;

end.

